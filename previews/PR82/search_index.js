var documenterSearchIndex = {"docs":
[{"location":"data-simulation/#data-simulation","page":"Generating and Fitting Simulated Data","title":"Generating and Fitting Simulated Data","text":"This tutorial demonstrates how to use Octofitter to simulate synthetic data, fit models to that data, and validate the results. This is a crucial workflow for understanding model performance and testing analysis pipelines.\n\nWe'll simulate data from a known set of parameters, fit a model to recover those parameters, and compare the posterior to the true values used for simulation.","category":"section"},{"location":"data-simulation/#Setup","page":"Generating and Fitting Simulated Data","title":"Setup","text":"using Octofitter, OctofitterRadialVelocity, Distributions\nusing CairoMakie, PairPlots, Pigeons\nusing CSV, DataFrames","category":"section"},{"location":"data-simulation/#Define-the-Model","page":"Generating and Fitting Simulated Data","title":"Define the Model","text":"In order to simulate data from Octofitter, you start by defining a real model with data. The simulate step will use the provided epochs, data types, and uncertainties when simulating data. If you don't have real data, you can enter in arbitrary values for e.g. delta R.A., but use expected epochs and uncertainties.\n\nFor this example, we'll use the combined astrometry, proper motion anomaly, and radial velocity model from the Astrometry, PMA, and RV tutorial to define the epochs and uncertainties.\n\n# HGCA likelihood for HD 91312\nhgca_obs = HGCAObs(gaia_id=756291174721509376)\n\n#  relative astrometry data (from discovery paper)\nastrom_dat = Table(;\n    epoch = [mjd(\"2016-12-15\"), mjd(\"2017-03-12\"), mjd(\"2017-03-13\"), mjd(\"2018-02-08\"), mjd(\"2018-11-28\"), mjd(\"2018-12-15\")],\n    ra    = [133., 126., 127., 083., 058., 056.],\n    dec   = [-174., -176., -172., -133., -122., -104.],\n    σ_ra  = [07.0, 04.0, 04.0, 10.0, 10.0, 08.0],\n    σ_dec = [07.0, 04.0, 04.0, 10.0, 20.0, 08.0],\n    cor   = [0.2, 0.3, 0.1, 0.4, 0.3, 0.2]\n)\n\nastrom_obs = PlanetRelAstromObs(\n    astrom_dat,\n    name = \"SCExAO\",\n    variables = @variables begin\n        jitter = 0\n        northangle = 0\n        platescale = 1\n    end\n)\n\n#  RV data\nrv_dat = Table(;\n    epoch = [mjd(\"2008-05-01\"), mjd(\"2010-02-15\"), mjd(\"2016-03-01\")],\n    rv    = [1300, 700, -2700],\n    σ_rv  = [150, 150, 150]\n)\n\nrvlike = StarAbsoluteRVObs(\n    rv_dat,\n    name=\"SOPHIE\",\n    variables=@variables begin\n        jitter ~ truncated(Normal(10, 5), lower=0)\n        offset ~ Normal(0, 1000)\n    end\n)\n\n# Planet model\nplanet_b = Planet(\n    name=\"b\",\n    basis=AbsoluteVisual{KepOrbit},\n    observations=[ObsPriorAstromONeil2019(astrom_obs)],\n    variables=@variables begin\n        a ~ LogUniform(0.1,400)\n        e ~ Uniform(0,0.999)\n        ω ~ Uniform(0, 2pi)\n        i ~ Sine()\n        Ω ~ Uniform(0, 2pi)\n        mass = system.M_sec\n        θ ~ Uniform(0, 2pi)\n        M = system.M\n        tp = θ_at_epoch_to_tperi(θ, 57737.0; M, e, a, i, ω, Ω)\n        F = 0.0\n    end\n)\n\n# System model\nra = 158.30707896392835\ndec = 40.42555422701387\n\nsys = System(\n    name=\"HD91312_simulation\",\n    companions=[planet_b],\n    observations=[hgca_obs, rvlike],\n    variables=@variables begin\n        M_pri ~ truncated(Normal(1.61, 0.1), lower=0.1)\n        M_sec ~ LogUniform(0.5, 1000)\n        M = M_pri + M_sec*Octofitter.mjup2msol\n        plx ~ gaia_plx(gaia_id=756291174721509376)\n        pmra ~ Normal(-137, 10)\n        pmdec ~ Normal(2, 10)\n        ra = $ra\n        dec = $dec\n        rv = 0*1e3\n        ref_epoch = Octofitter.meta_gaia_DR3.ref_epoch_mjd\n    end\n)\n\nmodel = Octofitter.LogDensityModel(sys)\nnothing # hide","category":"section"},{"location":"data-simulation/#Generate-Synthetic-Data","page":"Generating and Fitting Simulated Data","title":"Generate Synthetic Data","text":"We have three choices for generating simulated data:\n\nDraw values from the priors\nUse values from a fitted posterior \nSpecifying values manually\n\nWe will look at each.","category":"section"},{"location":"data-simulation/#1.-Draw-values-from-the-priors","page":"Generating and Fitting Simulated Data","title":"1. Draw values from the priors","text":"We can draw a value from the priors like so:\n\nparams_to_simulate = Octofitter.drawfrompriors(model.system)","category":"section"},{"location":"data-simulation/#2.-Use-values-from-a-fitted-posterior","page":"Generating and Fitting Simulated Data","title":"2. Use values from a fitted posterior","text":"We can select a particular draw from the posterior and use this to generate new data\n\n# Perform MCMC fitting on real data\nusing Pigeons\nchain_real, pt = octofit_pigeons(model, n_rounds=5)\n\n# Use one particular draw as the basis of our simulation\ndraw_number = 1\nparams_to_simulate = Octofitter.mcmcchain2result(model, chain_real, draw_number)","category":"section"},{"location":"data-simulation/#Specifying-values-manually","page":"Generating and Fitting Simulated Data","title":"Specifying values manually","text":"We can also specify all values for the simulation manually. This process is a bit more involved. \n\nStart by drawing parameters from the priors:\n\ntemplate = Octofitter.drawfrompriors(model.system)\n\nCopy this output as a template, and replace values as needed. Note that if some parameters are calculated based on others in your model, you will have to repeat those calculations here.\n\nwarning: Warning\nNote that the output below is just an example, you must generate your own template from your model and modify it as needed. The exact structure is not garuanteed to be stable between versions of Octofitter.\n\n# Define our \"true\" parameter values for simulation\nM_pri = 1.61\nM_sec = 85.0\nM = M_pri + M_sec*Octofitter.mjup2msol\nparams_to_simulate = (\n    M_pri = M_pri, \n    M_sec = M_sec,  # Jupiter masses\n    M = M,\n    plx = 21.5,\n    pmra = -137.0,\n    pmdec = 2.0,\n    ra = ra,\n    dec = dec,\n    rv = 0.0,\n    ref_epoch = Octofitter.meta_gaia_DR3.ref_epoch_mjd,\n    observations = (\n        SOPHIE = (jitter = 15.0, offset = 0.0),\n    ),\n    planets = (\n        b = (\n            a = 45.0,\n            e = 0.15,\n            ω = 1.2,\n            mass = M_sec,\n            i = 0.8,\n            Ω = 2.1,\n            θ = 1.5,\n            M = M,\n            tp = θ_at_epoch_to_tperi(1.5, 57737.0; M=M, e=0.15, a=45.0, i=0.8, ω=1.2, Ω=2.1),\n            F = 0.0,\n            observations = NamedTuple()\n        ),\n    )\n)","category":"section"},{"location":"data-simulation/#Generate-synthetic-system-with-simulated-data","page":"Generating and Fitting Simulated Data","title":"Generate synthetic system with simulated data","text":"sim_system = Octofitter.generate_from_params(model.system, params_to_simulate)\nsim_model = Octofitter.LogDensityModel(sim_system)\n\nLet's plot the simulated orbit and data to see what we generated:\n\n# Convert true parameters to chain format for plotting\ntrue_chain = Octofitter.result2mcmcchain([params_to_simulate])\n\n# Plot the simulated system with true parameters\nfig = octoplot(sim_model, true_chain, colormap=:red)\nfig","category":"section"},{"location":"data-simulation/#Fit-the-Simulated-Data","page":"Generating and Fitting Simulated Data","title":"Fit the Simulated Data","text":"Now we'll sample from the posterior using the simulated data:\n\n# Sample from the simulated data\nchain, pt = octofit_pigeons(sim_model, n_rounds=8, explorer=SliceSampler())\ndisplay(chain)","category":"section"},{"location":"data-simulation/#Compare-Results","page":"Generating and Fitting Simulated Data","title":"Compare Results","text":"Let's visualize how well our sampling recovered the true parameters:\n\n# Plot the posterior from fitting simulated data\nfig = octoplot(sim_model, chain)\nfig","category":"section"},{"location":"data-simulation/#Overlay-True-and-Recovered-Parameters","page":"Generating and Fitting Simulated Data","title":"Overlay True and Recovered Parameters","text":"For a direct comparison, we can overlay the true orbit with the posterior samples:\n\n# Create astrometry plot showing both posterior and true orbit\nfig = Octofitter.astromplot(sim_model, chain, use_arcsec=false, ts=1:2)\nax = fig.content[1]\n\n# Add true orbit in red\nOctofitter.astromplot!(ax, sim_model, true_chain, use_arcsec=false, ts=1:2, colormap=Makie.cgrad([:red]))\n\n# Make true orbit line more visible\nax.scene.plots[6].linewidth = 6\n\nfig","category":"section"},{"location":"data-simulation/#Corner-Plot-Comparison","page":"Generating and Fitting Simulated Data","title":"Corner Plot Comparison","text":"Compare the parameters used to generate the simulated data, and the recovered posterior:\n\n# Create corner plot showing both posterior and true values\noctocorner(\n    sim_model,\n    chain,\n    small=true,\n    truth=(PairPlots.Truth((;\n        M=collect(true_chain[:M][:]),\n        b_a=collect(true_chain[:b_a][:]),\n        b_e=collect(true_chain[:b_e][:]),\n        b_i=collect(true_chain[:b_i][:]),\n        b_mass=collect(true_chain[:b_mass][:]),\n    ),label=\"Simulated Orbit\", color=:red)=>(\n        PairPlots.MarginLines(),\n        PairPlots.BodyLines(),\n    ),)\n)","category":"section"},{"location":"octoplot/#Orbit-Visualization-with-octoplot","page":"Orbit plots with octoplot","title":"Orbit Visualization with octoplot","text":"octoplot is a versatile visualization function that creates publication-quality figures showing orbit fits and data. It can generate multi-panel figures combining:\n\nProjected orbits in the plane of the sky (astrometry)\nPhysical orbits in AU\nTime series of separations and position angles\nRadial velocity curves\nProper motion anomaly\nMass posteriors\nAnd more\n\nHere's a basic example showing how to create a plot from your MCMC chain:\n\nusing Octofitter\n# After running your MCMC fit...\nfig = octoplot(model, chain)\n\nBy default, octoplot will automatically detect what kinds of data are present in your model and create appropriate panels. For example, if you have both astrometry and radial velocity data, it will show both an orbit plot and an RV curve. You can control which panels appear using boolean flags:\n\nfig = octoplot(model, chain;\n    show_astrom=true,         # Show orbit in sky plane (mas)\n    show_physical_orbit=true, # Show orbit in physical units (AU)\n    show_astrom_time=true,    # Show sep/PA vs time\n    show_rv=true,             # Show stellar RV\n    show_relative_rv=true,    # Show planet-star relative RV\n    show_pma=true,            # Show proper motion anomaly\n    show_mass=true            # Show mass posterior\n)\n\nBy default, octoplot draws 250 orbits randomly from your posterior samples. You can adjust this using the N parameter:\n\n# Plot fewer orbits for faster rendering\nfig = octoplot(model, chain, N=50)\n\n# Plot specific posterior samples\nfig = octoplot(model, chain, ii=[1,2,3])  # Plot first three samples\nidx_MAP = argmax(chain[:logpost])\nfig = octoplot(model, chain, ii=[idx_MAP])  # Plot maximum posterior sample","category":"section"},{"location":"octoplot/#Panel-Types","page":"Orbit plots with octoplot","title":"Panel Types","text":"octoplot creates a vertical stack of panels based on the data present in your model and the display options you select. The panels share consistent formatting - all time-based plots share aligned time axes, orbits for each planet use consistent colors, and epoch markers (if specified) appear consistently across all applicable panels.","category":"section"},{"location":"octoplot/#Astrometry-Panels","page":"Orbit plots with octoplot","title":"Astrometry Panels","text":"","category":"section"},{"location":"octoplot/#Sky-Projected-Orbits-(show_astromtrue)","page":"Orbit plots with octoplot","title":"Sky-Projected Orbits (show_astrom=true)","text":"Shows orbits projected onto the plane of the sky, with ΔRA and ΔDec measured in milliarcseconds (mas). The central star is marked with a star symbol at (0,0). If you have relative astrometry data, it will be plotted with error bars. The color of each orbit indicates the mean anomaly (orbit phase), progressing from periastron.","category":"section"},{"location":"octoplot/#Physical-Orbits-(show_physical_orbittrue)","page":"Orbit plots with octoplot","title":"Physical Orbits (show_physical_orbit=true)","text":"Similar to the sky-projected plot, but shows orbits in their true physical scale measured in astronomical units (AU). This can be helpful for understanding the true geometry of the system, especially for orbits viewed at high inclination.","category":"section"},{"location":"octoplot/#Time-Series-Panels","page":"Orbit plots with octoplot","title":"Time Series Panels","text":"","category":"section"},{"location":"octoplot/#Astrometry-vs-Time-(show_astrom_timetrue)","page":"Orbit plots with octoplot","title":"Astrometry vs Time (show_astrom_time=true)","text":"Two linked panels showing:\n\nProjected separation vs time (top)\nPosition angle vs time (bottom)\n\nIf you specified mark_epochs_mjd, the predicted separation and position angle at those epochs will be marked. ","category":"section"},{"location":"octoplot/#Radial-Velocity-(show_rvtrue)","page":"Orbit plots with octoplot","title":"Radial Velocity (show_rv=true)","text":"Shows the stellar radial velocity curve(s). If you have data from multiple instruments, each will be plotted in its own panel. The model includes:\n\nRaw RV measurements with error bars\nlines showing individual orbit draws from the posterior\nColored bands showing uncertainty including jitter and GP model (if present)\n\nIf you specified mark_epochs_mjd, the predicted RV at those epochs will be marked. See rvpostplot for another way to plot RV data.","category":"section"},{"location":"octoplot/#Relative-Radial-Velocity-(show_relative_rvtrue)","page":"Orbit plots with octoplot","title":"Relative Radial Velocity (show_relative_rv=true)","text":"Shows the relative radial velocity between the planet and star. This panel appears when you have PlanetRelativeRVObs data in your model.","category":"section"},{"location":"octoplot/#Proper-Motion-Anomaly-(show_hgcatrue)","page":"Orbit plots with octoplot","title":"Proper Motion Anomaly (show_hgca=true)","text":"Multiple panels showing proper motion data from the Hipparcos-Gaia Catalogue of Accelerations (HGCA):\n\nProper motion in RA vs time\nProper motion in Dec vs time\n2D Proper motion residual plots at the Hipparcos, Gaia, and Hipparcos-Gaia epochs.","category":"section"},{"location":"octoplot/#Mass-Posterior-(show_masstrue)","page":"Orbit plots with octoplot","title":"Mass Posterior (show_mass=true)","text":"A mini corner plot showing the mass posterior(s) for your planet(s). This panel appears at the bottom of the figure when mass is a parameter in your model.\n\nEach of these panels will only appear if:\n\nThe relevant display option is set to true\nYour model includes the appropriate type of data/likelihood\nYour model parameterization supports that type of visualization (e.g., show_physical_orbit requires a full 3D orbit parameterization)","category":"section"},{"location":"octoplot/#Customizing-Appearance","page":"Orbit plots with octoplot","title":"Customizing Appearance","text":"","category":"section"},{"location":"octoplot/#Colormaps","page":"Orbit plots with octoplot","title":"Colormaps","text":"The default colormap (\"plasma\") is used to indicate orbital phase in most panels, varying smoothly from periastron through the orbit. You can customize this in several ways:\n\n# Use a different colormap from the ColorSchemes package\noctoplot(model, chain, colormap=Makie.cgrad(:viridis))\n\n# Use a gradient from light grey to a specific color\noctoplot(model, chain, colormap=\"#0072b2\")  # Blue to grey\n\nFor models with multiple planets, octoplot automatically assigns a different base color to each planet's orbit in the astrometry and astrometry-time panels. The other panels continue to use the default colormap to show orbital phase.\n\ntip: Tip\nWhen choosing a colormap, avoid categorical colormaps in favor of those that vary smoothly. If you don't need to mark the exact location of periastron, you can also use a cyclical colormap.","category":"section"},{"location":"octoplot/#Transparency","page":"Orbit plots with octoplot","title":"Transparency","text":"The alpha parameter controls the transparency of orbit lines. By default, it is automatically scaled based on the number of orbits being plotted to prevent overplotting:\n\n# Override the default transparency\noctoplot(model, chain, alpha=0.1)  # More transparent","category":"section"},{"location":"octoplot/#Figure-Scale","page":"Orbit plots with octoplot","title":"Figure Scale","text":"The overall size of the figure can be adjusted using the figscale parameter:\n\n# Make the figure 50% larger\noctoplot(model, chain, figscale=1.5)","category":"section"},{"location":"octoplot/#Time-Range","page":"Orbit plots with octoplot","title":"Time Range","text":"You can control the time span of the orbital plots using the ts parameter:\n\n# Custom time range in Modified Julian Days\nts = range(50000, 55000, length=200)  # 200 points between MJD 50000 and 55000\noctoplot(model, chain, ts=ts)\n\nnote: Note\nThe number of points should be roughly 150 per orbital period displayed to ensure smooth curves. For highly eccentric orbits, you may need more points to capture the rapid motion near periastron.","category":"section"},{"location":"octoplot/#Marking-Specific-Epochs","page":"Orbit plots with octoplot","title":"Marking Specific Epochs","text":"You can highlight specific epochs across all applicable panels using markepochsmjd:\n\n# Mark three specific dates\nepochs = [\n    mjd(\"2024-01-01\"),\n    mjd(\"2025-01-01\"),\n    mjd(\"2026-01-01\")\n]\noctoplot(model, chain, mark_epochs_mjd=epochs)\n\nThese markers appear consistently across all panels, using the same color and style to show model predictions at those specific times.","category":"section"},{"location":"octoplot/#Post-Creation-Customization","page":"Orbit plots with octoplot","title":"Post-Creation Customization","text":"Since octoplot returns a Makie figure object, you can further customize the plot after creation:\n\n# Create the plot\nfig = octoplot(model, chain)\n\n# Access and modify specific axes\nax_orbit = fig.content[1]  # First axis (usually the orbit plot)\nxlims!(ax_orbit, -100, 100)  # Set x-axis limits in mas\nylims!(ax_orbit, -100, 100)  # Set y-axis limits in mas\n\n# Add a title\nax_orbit.title = \"HD 12345 Orbital Fit\"\nfig","category":"section"},{"location":"octoplot/#Time-Range-Control","page":"Orbit plots with octoplot","title":"Time Range Control","text":"The time span shown in orbit plots can be controlled using the ts parameter. By default, octoplot automatically determines an appropriate range based on:\n\nYour data epochs\nThe median orbital period from your posterior\nA small padding factor for visual clarity\n\nYou can override this behavior by providing your own time range:\n\n# Custom time range\nts = range(mjd(\"2020-01-01\"), mjd(\"2025-01-01\"), length=200)\noctoplot(model, chain, ts=ts)\n\nnote: Note\nThe ts parameter only affects time-based panels (RV curves, proper motion, etc). The sky-projected orbit plots (show_astrom) and physical orbit plots (show_physical_orbit) use a separate internal algorithm to ensure smooth curves.\n\ntip: Tip\nIf you have widely separated data epochs, you might want to zoom in on specific time ranges to better see the detail in your data. For example:\n\n# Zoom in on first epoch\nts = range(mjd(\"2020-01-01\"), mjd(\"2021-01-01\"), length=200)\nfig1 = octoplot(model, chain, ts=ts)","category":"section"},{"location":"octoplot/#Post-Creation-Customization-2","page":"Orbit plots with octoplot","title":"Post-Creation Customization","text":"Since octoplot returns a Makie figure object, you can further customize any aspect of the plot after creation. The figure contains a vertical layout of different plot panels depending on which elements you chose to display.","category":"section"},{"location":"octoplot/#Accessing-Plot-Elements","page":"Orbit plots with octoplot","title":"Accessing Plot Elements","text":"# Create the plot\nfig = octoplot(model, chain)\n\n# Access the axes\naxes = fig.content    # Get all axes\n\n# Common panel indices\norbit_ax = fig.content[1]     # Sky-projected orbit plot (if show_astrom=true)\nrv_ax = fig.content[2]        # RV plot (if show_rv=true)\n# etc.","category":"section"},{"location":"octoplot/#Common-Adjustments","page":"Orbit plots with octoplot","title":"Common Adjustments","text":"# Adjust axis limits\nxlims!(orbit_ax, -100, 100)   # Set x-axis limits in mas\nylims!(orbit_ax, -100, 100)   # Set y-axis limits in mas\n\n# Change axis labels\norbit_ax.xlabel = \"ΔRA [mas]\"\norbit_ax.ylabel = \"ΔDec [mas]\"\n\n# Add a title\norbit_ax.title = \"HD 12345 Orbital Fit\"\n\n# Adjust legend\nLegend(fig[1,2], orbit_ax, \"Posterior Draws\")\n\n# Save the modified figure\nsave(\"orbit_plot.pdf\", fig)\n\ntip: Tip\nTake care when modifying time-based panels (RV, proper motion, etc) as they share synchronized x-axes. Modifying the time limits of one panel will affect all others.","category":"section"},{"location":"octoplot/#Saving-Figures","page":"Orbit plots with octoplot","title":"Saving Figures","text":"When using CairoMakie (recommended for publication-quality outputs), you can save figures in several formats:\n\nfig = octoplot(model, chain)\n\n# Save as PNG (default)\nsave(\"orbit_plot.png\", fig)\n\n# Save as PDF (great for publications)\nsave(\"orbit_plot.pdf\", fig)\n\n# Save as SVG (good for further editing)\nsave(\"orbit_plot.svg\", fig)\n\n# Increase PNG resolution\nsave(\"orbit_plot.png\", fig, px_per_unit=5)  # 5x default resolution\n\nnote: Note\nMany plot elements are internally rasterized to 4 points per pixel for performance, so extremely high pxperunit values may not improve quality.\n\nIf using GLMakie instead of CairoMakie, you get interactive figures that can be zoomed and panned before saving. However, only PNG output is supported. GLMakie is great for exploration, while CairoMakie is preferred for final publication figures.","category":"section"},{"location":"rv-1/#fit-rv","page":"Basic RV Fit","title":"Basic RV Fit","text":"You can use Octofitter to fit radial velocity data, either alone or in combination with other kinds of data. Multiple instruments (any number) are supported, as are arbitrary trends, and gaussian processes to model stellar activity.\n\nnote: Note\nRadial velocity modelling is supported in Octofitter via the extension package OctofitterRadialVelocity. To install it, run  pkg> add OctofitterRadialVelocity\n\nFor this example, we will fit the orbit of the planet K2-131, and reproduce this RadVel tutorial.\n\nWe will use the following packages:\n\nusing Octofitter\nusing OctofitterRadialVelocity\nusing PlanetOrbits\nusing CairoMakie\nusing PairPlots\nusing CSV\nusing DataFrames\nusing Distributions\n\nWe will start by downloading and preparing a table of radial velocity measurements, and create a StarAbsoluteRVObs object to hold them.\n\nThe following functions allow you to directly load data from various public RV databases:\n\nHARPS_DR1_rvs(\"star-name\")\nHARPS_RVBank_observations(\"star-name\")\nLick_rvs(\"star-name\")\nHIRES_rvs(\"star-name\")\n\nMake sure to credit the sources using the citation printed when you first access the catalog. Calling those functions with the name of a star will return a StarAbsoluteRVObs table. \n\nIf you would like to manually specify RV data, use the following format:\n\nrv_data = Table(\n     # epoch is in units of MJD. `jd2mjd` is a helper function to convert.\n    # you can also put `years2mjd(2016.1231)`.\n    # rv and σ_rv are in units of meters/second\n    epoch=jd2mjd.([2455110.97985, 2455171.90825]),\n    rv=[-6.54, -3.33],\n    σ_rv=[1.30, 1.09]\n)\n\nrv_obs = StarAbsoluteRVObs(rv_data, \n    name=\"insert name here\",\n    variables=@variables begin\n        offset ~ Uniform(-1000, 1000) # m/s\n        jitter ~ LogUniform(0.01, 10) # m/s\n    end\n)","category":"section"},{"location":"rv-1/#Basic-Fit","page":"Basic RV Fit","title":"Basic Fit","text":"For this example, to replicate the results of RadVel, we will download their example data for K2-131 and format it for Octofitter:\n\nrv_file = download(\"https://raw.githubusercontent.com/California-Planet-Search/radvel/master/example_data/k2-131.txt\")\nrv_dat_raw = CSV.read(rv_file, DataFrame, delim=' ')\nrv_dat = DataFrame();\nrv_dat.epoch = jd2mjd.(rv_dat_raw.time)\nrv_dat.rv = rv_dat_raw.mnvel\nrv_dat.σ_rv = rv_dat_raw.errvel\ntels = sort(unique(rv_dat_raw.tel))\n\n# This table includes data from two insturments. We create a separate\n# likelihood object for each:\nrvlike_harps = StarAbsoluteRVObs(\n    rv_dat[rv_dat_raw.tel .== \"harps-n\",:],\n    name=\"harps-n\",\n    variables=@variables begin\n        offset ~ Normal(-6693,100) # m/s\n        jitter ~ LogUniform(0.1,100) # m/s\n    end\n)\nrvlike_pfs = StarAbsoluteRVObs(\n    rv_dat[rv_dat_raw.tel .== \"pfs\",:],\n    name=\"pfs\",\n    variables=@variables begin\n        offset ~ Normal(0,100) # m/s\n        jitter ~ LogUniform(0.1,100) # m/s\n    end\n)\n\nNow, create a planet. We can use the RadialVelocityOrbit type from PlanetOrbits.jl that requires fewer parameters (eg no inclination or longitude of ascending node). We could instead use a Visual{KepOrbit} or similar if we wanted to include these parameters and visualize the orbit in the plane of the sky.\n\nplanet_1 = Planet(\n    name=\"b\",\n    basis=RadialVelocityOrbit,\n    observations=[],\n    variables=@variables begin\n        e = 0\n        ω = 0.0\n        # To match RadVel, we set a prior on Period and calculate semi-major axis from it\n        P ~ truncated(\n            Normal(0.3693038/365.256360417, 0.0000091/365.256360417),\n            lower=0.0001\n        )\n        M = system.M\n        a = cbrt(M * P^2) # note the equals sign. \n        τ ~ UniformCircular(1.0)\n        tp = τ*P*365.256360417 + 57782 # reference epoch for τ. Choose an MJD date near your data.\n        # minimum planet mass [jupiter masses]. really m*sin(i)\n        mass ~ LogUniform(0.001, 10)\n    end\n)\n\nsys = System(\n    name = \"k2_132\",\n    companions=[planet_1],\n    observations=[rvlike_harps, rvlike_pfs],\n    variables=@variables begin\n        M ~ truncated(Normal(0.82, 0.02),lower=0.1) # (Baines & Armstrong 2011).\n    end\n)\n\n\nNote how the rvlike object was attached to the k2_132 system instead of the planet. This is because the observed radial velocity is of the star, and is caused by any/all orbiting planets.\n\nThe rv0 and jitter parameters specify priors for the instrument-specific offset and white noise jitter standard deviation. The _i index matches the inst_idx used to create the observation table.\n\nNote also here that the mass variable is really msini, or the minimum mass of the planet.\n\nWe can now prepare our model for sampling.\n\nmodel = Octofitter.LogDensityModel(sys)\n\nInitialize the starting points, and confirm the data are entered correcly:\n\ninit_chain = initialize!(model)\n\nusing CairoMakie\nfig = Octofitter.rvpostplot(model, init_chain)\n\nSample:\n\nusing Random\nrng = Random.Xoshiro(0)\n\nchain = octofit(rng, model)\n\nExcellent! Let's plot an orbit sampled from the posterior:\n\nusing CairoMakie\nfig = Octofitter.rvpostplot(model, chain) # saved to \"k2_132-rvpostplot.png\"\n\nWe can also plot a sample of draws from the posterior:\n\nusing CairoMakie: Makie\noctoplot(model, chain)\n\nAnd create a corner plot:\n\nusing PairPlots, CairoMakie\noctocorner(model, chain)\n\nThis example continues in Fit Gaussian Process.","category":"section"},{"location":"migration/#migration","page":"Migration Guide","title":"Migration Guide","text":"","category":"section"},{"location":"migration/#Table-of-Contents","page":"Migration Guide","title":"Table of Contents","text":"Migrating to v8\nMigrating to v7\n\n","category":"section"},{"location":"migration/#Migrating-to-v8","page":"Migration Guide","title":"Migrating to v8","text":"Octofitter.jl v8 renames observation types from *Likelihood to *Obs (short for observation) for clarity. E.g., PlanetRelAstromLikelihood has been renamed PlanetRelAstromObs. At the same time, the argument likelihoods=[...] to both Planet and System has been renamed observations=[...]. Replace ","category":"section"},{"location":"migration/#Global-Find-and-Replace","page":"Migration Guide","title":"Global Find & Replace","text":"Apply these replacements to update your code:\n\nOld Name (v7) New Name (v8)\nlikelihoods=[...] observations=[...]\nPhotometryLikelihood PhotometryObs\nPlanetRelAstromLikelihood PlanetRelAstromObs\nStarAbsoluteRVLikelihood StarAbsoluteRVObs\nMarginalizedStarAbsoluteRVLikelihood MarginalizedStarAbsoluteRVObs\nStarAbsoluteRVMarginLikelihood MarginalizedStarAbsoluteRVObs\nPlanetRelativeRVLikelihood PlanetRelativeRVObs\nHGCALikelihood HGCAObs\nHGCAInstantaneousLikelihood HGCAInstantaneousObs\nHipparcosIADLikelihood HipparcosIADObs\nGaiaHipparcosUEVAJointLikelihood GaiaHipparcosUEVAJointObs\nGaiaDifferenceLikelihood GaiaDifferenceObs\nGaiaCatalogFitLikelihood GaiaCatalogFitObs\nGaiaUEVALikelihood GaiaUEVAObs\nImageLikelihood ImageObs\nLogLikelihoodMap LogLikelihoodMapObs\nInterferometryLikelihood InterferometryObs\nAbstractInterferometryLikelihood AbstractInterferometryObs\nGRAVITYWideKPLikelihood GRAVITYWideKPObs\n\nNote: Types ending in Prior (e.g., PlanetOrderPrior, UnitLengthPrior) and UserLikelihood keep their original names.\n\n","category":"section"},{"location":"migration/#Migrating-to-v7","page":"Migration Guide","title":"Migrating to v7","text":"This guide helps you migrate your code from Octofitter.jl v6 to v7, which introduced a significant API redesign.","category":"section"},{"location":"migration/#Overview-of-Changes","page":"Migration Guide","title":"Overview of Changes","text":"The v7 API redesign eliminates the @planet and @system macros in favor of explicit Planet() and System() constructors. This change provides better error handling, clearer variable scoping, and more flexible model composition.\n\nThis upgrade is particularly useful for large batch processing systems, and for models with large numbers of instruments.\n\nnote: Note\nPro-tip: paste your old Octofitter scripts and this migration guide into an LLM–-it","category":"section"},{"location":"migration/#Key-Migration-Steps","page":"Migration Guide","title":"Key Migration Steps","text":"","category":"section"},{"location":"migration/#1.-Model-Definition-Syntax","page":"Migration Guide","title":"1. Model Definition Syntax","text":"","category":"section"},{"location":"migration/#Old-Syntax-(v6):","page":"Migration Guide","title":"Old Syntax (v6):","text":"@planet b Visual{KepOrbit} begin\n    a ~ Uniform(0, 100)\n    e ~ Uniform(0.0, 0.5)\n    i ~ Sine()\n    ω ~ UniformCircular()\n    Ω ~ UniformCircular()\n    θ ~ UniformCircular()\n    tp = θ_at_epoch_to_tperi(system, b, 50000)\nend astrom\n\n@system HD1234 begin\n    M ~ truncated(Normal(1.2, 0.1), lower=0.1)\n    plx ~ truncated(Normal(50.0, 0.02), lower=0.1)\nend b","category":"section"},{"location":"migration/#New-Syntax-(v7):","page":"Migration Guide","title":"New Syntax (v7):","text":"planet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    likelihoods=[astrom],\n    variables=@variables begin\n        M ~ truncated(Normal(1.2, 0.1), lower=0.1)  # Total mass for this orbit\n        a ~ Uniform(0, 100)\n        e ~ Uniform(0.0, 0.5)\n        i ~ Sine()\n        ω ~ UniformCircular()\n        Ω ~ UniformCircular()\n        θ ~ UniformCircular()\n        tp = θ_at_epoch_to_tperi(θ, 50000; M, e, a, i, ω, Ω)\n    end\n)\n\nsys = System(\n    name=\"HD1234\",\n    companions=[planet_b],\n    likelihoods=[],\n    variables=@variables begin\n        plx ~ truncated(Normal(50.0, 0.02), lower=0.1)\n    end\n)","category":"section"},{"location":"migration/#2.-Likelihood-Construction","page":"Migration Guide","title":"2. Likelihood Construction","text":"","category":"section"},{"location":"migration/#Old-Syntax-(v6):-2","page":"Migration Guide","title":"Old Syntax (v6):","text":"astrom = PlanetRelAstromLikelihood(Table(\n    epoch = [50000, 50120, 50240],\n    ra = [-505.7, -502.5, -498.2],\n    dec = [-66.9, -37.4, -7.9],\n    σ_ra = [10.0, 10.0, 10.0],\n    σ_dec = [10.0, 10.0, 10.0],\n    cor = [0.0, 0.0, 0.0]\n))","category":"section"},{"location":"migration/#New-Syntax-(v7):-2","page":"Migration Guide","title":"New Syntax (v7):","text":"Your likelihood objects must be given a name in most cases:\n\nastrom_dat = Table(\n    epoch = [50000, 50120, 50240],\n    ra = [-505.7, -502.5, -498.2],\n    dec = [-66.9, -37.4, -7.9],\n    σ_ra = [10.0, 10.0, 10.0],\n    σ_dec = [10.0, 10.0, 10.0],\n    cor = [0.0, 0.0, 0.0]\n)\nastrom = PlanetRelAstromLikelihood(astrom_dat, name=\"GPI astrom\")\n\nAlternative: Vector-of-NamedTuples (still supported): You can still use the vector-of-namedtuples syntax from v6, but now it must be wrapped in a Table first:\n\n# This still works in v7:\nastrom = PlanetRelAstromLikelihood(\n    Table([\n        (epoch=50000, ra=-505.7, dec=-66.9, σ_ra=10.0, σ_dec=10.0, cor=0.0),\n        (epoch=50120, ra=-502.5, dec=-37.4, σ_ra=10.0, σ_dec=10.0, cor=0.0),\n        (epoch=50240, ra=-498.2, dec=-7.9,  σ_ra=10.0, σ_dec=10.0, cor=0.0),\n    ]),\n    name=\"GPI astrom\"\n)","category":"section"},{"location":"migration/#3.-Radial-Velocity-Models","page":"Migration Guide","title":"3. Radial Velocity Models","text":"","category":"section"},{"location":"migration/#Old-Syntax-(v6):-3","page":"Migration Guide","title":"Old Syntax (v6):","text":"rvlike_hires = MarginalizedStarAbsoluteRVLikelihood(\n    hires_data,\n    instrument_name=\"HIRES\",\n    jitter=:jitter_hires,\n)","category":"section"},{"location":"migration/#New-Syntax-(v7):-3","page":"Migration Guide","title":"New Syntax (v7):","text":"Instrument-specific variables are handled directly in the likelihood definition.\n\nrvlike_hires = MarginalizedStarAbsoluteRVLikelihood(\n    hires_data,\n    name=\"HIRES\",\n    variables=@variables begin\n        jitter ~ LogUniform(0.1, 100) # m/s\n    end\n)","category":"section"},{"location":"migration/#4.-Variable-Access-in-Derived-Parameters","page":"Migration Guide","title":"4. Variable Access in Derived Parameters","text":"You no longer have to prefix with the planet name or system. Just use variabels directly.\n\nThe θ_at_epoch_to_tperi function syntax has changed. You now provided the necessary parameters for the calculation directly.","category":"section"},{"location":"migration/#Old-Syntax-(v6):-4","page":"Migration Guide","title":"Old Syntax (v6):","text":"P = √(b.a^3/system.M)\n\ntp = θ_at_epoch_to_tperi(system, b, 50000)","category":"section"},{"location":"migration/#New-Syntax-(v7):-4","page":"Migration Guide","title":"New Syntax (v7):","text":"P = √(a^3/M)\n\n# In planet variables block:\ntp = θ_at_epoch_to_tperi(θ, 50000; M, e, a, i, ω, Ω)\n\n# Access system variables with system. prefix when needed:\nM = system.M  # if planet needs system mass","category":"section"},{"location":"migration/#Key-Differences-Summary","page":"Migration Guide","title":"Key Differences Summary","text":"Model Construction: Replace @planet and @system macros with explicit Planet() and System() constructors\nLikelihood Names: Most likelihoods now require a name parameter\nVariable Scoping: Use direct variable names in derived expressions instead of qualified access\nObservation Variables: Likelihood-specific variables are now defined in the likelihood's @variables block","category":"section"},{"location":"derived/#derived","page":"Derived Variables","title":"Derived Variables","text":"Octofitter has a concept called \"derived variables\" that are inspired by PyMC3. Derived variables are quantities that either have a fixed value, or a fixed mathematical relationship with the main variables in a model.\n\nThis concept is extremely powerful, as it lets you quickly create very sophisticated models.\n\nDerived variables allow you to mark certain properties as constants, reparameterize models, link properties between planets in multi-planet systems, plug in physical models, and more.","category":"section"},{"location":"derived/#System-Variables","page":"Derived Variables","title":"System Variables","text":"Derived variables for the system as a whole can be created as follows:\n\nsys = System(\n    name=\"HD12345\",\n    companions=[],\n    observations=[],\n    variables=@variables begin\n        M = 1.0\n        plx ~ Normal(45., 0.02)\n    end\n)\n\nIn this case, instead of including M as a variable in the model, we define it as a function that always returns 1.0. This is equivalent to passing M=1.0.\n\nIn the following case, let's define M as being calculated based on another variable in the model. This is how you can do reparameterizations in Octofitter.jl\n\nsys = System(\n    name=\"HD12345\",\n    companions=[],\n    observations=[],\n    variables=@variables begin\n        plx ~ Normal(45., 0.02)\n        logM ~ Normal(45., 0.02)\n        M = 10^logM\n    end\n)\n\nWe defined a new variable logM as a prior, and then calculate M from it.\n\nIn general, you can write any function you want to map from any of combination of constants and variables in the model to new variables. The only constraints are that your functions always return the same outputs for the same inputs, and are differentiable. These functions will be called in a tight loop, so you should try to make sure they are as efficient as possible.","category":"section"},{"location":"derived/#Planet-Variables","page":"Derived Variables","title":"Planet Variables","text":"Derived variables for an individual planet are similar, but have access to both the planet's variables and the system as a whole.\n\nHere is an example of reparameterizing e and a on a planet to be logarithmic quantities:\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[],\n    variables=@variables begin\n        ω ~ Normal(0.1, deg2rad(30.))\n        i ~ Normal(0.1, deg2rad(30.))\n        Ω ~ Normal(0.0, deg2rad(30.))\n        loge ~ Uniform(-4, 1)\n        loga ~ Normal(1, 1)\n        e = 10^loge\n        a = 10^loga\n\n        M = system.M\n        τ ~ UniformCircular(1.0)\n        P = √(a^3/M)\n        tp = τ*P*365.25 + 58849 # reference epoch for τ. Choose an MJD date near your data.\n    end\n)\n\nHere e is defined as log-uniform, and a as log-normal.","category":"section"},{"location":"derived/#Linking-Planets","page":"Derived Variables","title":"Linking Planets","text":"Planets can have Derived variables that are calculated from variables defined on the system as a whole. This makes it easy to, for example, create a system of two planets that are co-planar.\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[],\n    variables=@variables begin\n        a ~ Uniform(0, 15)\n        e ~ Uniform(0,0.99)\n        ω ~ Normal(0.1, deg2rad(30.))\n        i = system.i\n        Ω = system.Ω\n\n        M = system.M\n        τ ~ UniformCircular(1.0)\n        P = √(a^3/M)\n        tp = τ*P*365.25 + 58849 # reference epoch for τ. Choose an MJD date near your data.\n    end\n)\n\nplanet_c = Planet(\n    name=\"c\",\n    basis=Visual{KepOrbit},\n    observations=[],\n    variables=@variables begin\n        a ~ Uniform(15, 45)\n        e ~ Uniform(0,0.99)\n        ω ~ Normal(0.1, deg2rad(30.))\n        i = system.i\n        Ω = system.Ω\n\n        M = system.M\n        τ ~ UniformCircular(1.0)\n        P = √(a^3/M)\n        tp = τ*P*365.25 + 58849 # reference epoch for τ. Choose an MJD date near your data.\n    end\n)\n\nsys = System(\n    name=\"HD12345\",\n    companions=[planet_b, planet_c],\n    observations=[],\n    variables=@variables begin\n        plx ~ Normal(45., 0.02)\n        M ~ Normal(45., 0.02)\n        i ~ Normal(0.1, deg2rad(30.))\n        Ω ~ Normal(0.0, deg2rad(30.))\n    end\n)\n\nNotice how i and Ω are defined as variables on the System. The two planets B & C instead just take their values from the System. This way we can enforce co-planarity between planets without e.g. rejection sampling.","category":"section"},{"location":"derived/#Resolution-Order","page":"Derived Variables","title":"Resolution Order","text":"The order that variables are resolved is as follows:\n\nVariables defined as priors for the system and planets\nDerived variables on the system\nDerived variables on each planet\n\nYou can use one derived variable from another based on their order in the @variables block within System() or Planet() constructors.  You cannot access variables from a different planet inside a Planet variables block. If you need to do this, move the variable up to the System variables block.","category":"section"},{"location":"rel-astrom-obs/#Observable-Based-Priors","page":"Observable Priors","title":"Observable-Based Priors","text":"This tutorial shows how to fit an orbit to relative astrometry using the observable-based priors ofO'Neil et al. 2019. Please cite that paper if you use this functionality.\n\nWe will fit the same astrometry as in the previous tutorial, and just change our priors.\n\nusing Octofitter\nusing CairoMakie\nusing PairPlots\nusing Distributions\n\nastrom_dat = Table(;\n    epoch = [50000, 50120, 50240, 50360, 50480, 50600, 50720, 50840],\n    ra    = [-494.4, -495.0, -493.7, -490.4, -485.2, -478.1, -469.1, -458.3],\n    dec   = [-76.7, -44.9, -12.9, 19.1, 51.0, 82.8, 114.3, 145.3],\n    σ_ra  = [12.6, 10.4, 9.9, 8.7, 8.0, 6.9, 5.8, 4.2],\n    σ_dec = [12.6, 10.4, 9.9, 8.7, 8.0, 6.9, 5.8, 4.2],\n    cor   = [0.2, 0.5, 0.1, -0.8, 0.3, -0.0, 0.1, -0.2]\n)\n\nastrom_obs = PlanetRelAstromObs(\n    astrom_dat,\n    name = \"obs_prior_example\",\n    variables = @variables begin\n        # Fixed values for this example - could be free variables:\n        jitter = 0        # mas [could use: jitter ~ Uniform(0, 10)]\n        northangle = 0    # radians [could use: northangle ~ Normal(0, deg2rad(1))]\n        platescale = 1    # relative [could use: platescale ~ truncated(Normal(1, 0.01), lower=0)]\n    end\n)\n# We wrap the likelihood in this prior\nobs_pri_astrom_obs = ObsPriorAstromONeil2019(astrom_obs)\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    # NOTE! We only provide the wrapped obs_pri_astrom_obs\n    observations=[obs_pri_astrom_obs],\n    variables=@variables begin\n        M = system.M\n        e ~ Uniform(0.0, 0.5)\n        i ~ Sine()\n        ω ~ UniformCircular()\n        Ω ~ UniformCircular()\n        # Results will be sensitive to the prior on period\n        P ~  LogUniform(0.1, 150) # Period, years\n        a = ∛(M * P^2)\n        θ_x ~ Normal()\n        θ_y ~ Normal()\n        θ = atan(θ_y, θ_x)\n        tp = θ_at_epoch_to_tperi(θ, 50420; M, e, a, i, ω, Ω)\n    end\n)\n\nsys = System(\n    name=\"TutoriaPrime\",\n    companions=[planet_b],\n    observations=[],\n    variables=@variables begin\n        M ~ truncated(Normal(1.2, 0.1), lower=0.1)\n        plx ~ truncated(Normal(50.0, 0.02), lower=0.1)\n    end\n)\n\nmodel = Octofitter.LogDensityModel(sys)\n\nInitialize the model starting points and confirm the data are entered correctly:\n\ninit_chain = initialize!(model,)\noctoplot(model, init_chain)\n\nNow run the fit:\n\nresults_obspri = octofit(model,iterations=5000,)\n\nPlot the MCMC results:\n\noctoplot(model, results_obspri)\n\nCompare this with the previous fit using uniform priors:\n\nastrom_obs_uniform = PlanetRelAstromObs( # hide\n    astrom_dat, # hide\n    name = \"uniform_prior_example\", # hide\n    variables = @variables begin # hide\n        jitter = 0        # mas # hide\n        northangle = 0    # radians # hide\n        platescale = 1    # relative # hide\n    end # hide\n) # hide\nplanet_b_uniform = Planet( # hide\n    name=\"b\", # hide\n    basis=Visual{KepOrbit}, # hide\n    observations=[astrom_obs_uniform], # hide\n    variables=@variables begin # hide\n        M = system.M # hide\n        a ~ Uniform(0, 100) # hide\n        e ~ Uniform(0.0, 0.5) # hide\n        i ~ Sine() # hide\n        ω_x ~ Normal() # hide\n        ω_y ~ Normal() # hide\n        ω = atan(ω_y, ω_x) # hide\n        Ω ~ Uniform(0,2pi) # hide\n        P = √(a^3/M) # hide\n        θ ~ Uniform(0,2pi) # hide\n        tp = θ_at_epoch_to_tperi(θ, 50420; M, e, a, i, ω, Ω) # hide\n    end # hide\n) # hide\nsys_uniform = System( # hide\n    name=\"Tutoria\", # hide\n    companions=[planet_b_uniform], # hide\n    observations=[], # hide\n    variables=@variables begin # hide\n        M ~ truncated(Normal(1.2, 0.1), lower=0.1) # hide\n        plx ~ truncated(Normal(50.0, 0.02), lower=0.1) # hide\n    end # hide\n) # hide\nmodel_with_uniform_priors = Octofitter.LogDensityModel(sys_uniform) # hide\nresults_unif_pri = octofit(model_with_uniform_priors,iterations=5000,verbosity=0) # hide\noctoplot(model_with_uniform_priors, results_unif_pri)\n\nWe can compare the results in a corner plot:\n\noctocorner(model,results_unif_pri,results_obspri,small=true)","category":"section"},{"location":"gaia-iad/#Fitting-Gaia-DR4-IAD","page":"Gaia DR4 IAD","title":"Fitting Gaia DR4 IAD","text":"This tutorial shows how you can use Octofitter to fit preliminary RV and absolute astrometry data from DR4, using the already published data for the Gaia-BH3 black hole.\n\nThe final format of the Gaia IAD data may change, in which case this tutorial will be updated.\n\nusing CairoMakie\nusing Octofitter\nusing Distributions\nusing CSV, DataFrames\n\nAs a first step, we will load the astrometry data for Gaia-BH3 and plot it:\n\nheaders = [\n    :transit_id\n    :ccd_id\n    :obs_time_tcb\n    :centroid_pos_al\n    :centroid_pos_error_al\n    :parallax_factor_al\n    :scan_pos_angle\n    :outlier_flag\n]\ndf = CSV.read(joinpath(@__DIR__, \"astrom.dat\"), DataFrame, skipto=7, header=headers, delim=' ', ignorerepeated=true)\ndf.epoch = jd2mjd.(df.obs_time_tcb)\n\nscatter(\n    df.obs_time_tcb,\n    df.centroid_pos_al,\n)\n\nWe can now construct a likelihood object for this data. We must also supply the Gaia ID, which will be used to query the full Gaia solution for this object (for now, using DR3):\n\ngaiaIADlike = GaiaDR4Astrom(\n    df, \n    gaia_id=4318465066420528000,\n    variables=@variables begin\n        astrometric_jitter ~ LogUniform(0.00001, 10) # mas\n    end\n)\n\nThis object also has published RV data from Gaia, which we can load and use as normal:\n\nusing CSV, DataFrames\nusing OctofitterRadialVelocity\n\nheaders_rv = [\n    :transit_id,\n    :obs_time_tcb,\n    :radial_velocity_kms,\n    :radial_velocity_err_kms,\n]\ndfrv = CSV.read(joinpath(@__DIR__, \"epochrv.dat\"), DataFrame, skipto=7, header=headers_rv, delim=' ', ignorerepeated=true)\ndfrv.epoch = jd2mjd.(dfrv.obs_time_tcb)\ndfrv.rv = dfrv.radial_velocity_kms * 1e3\ndfrv.σ_rv = dfrv.radial_velocity_err_kms * 1e3\n\n# Calculate mean RV for the prior\nmean_rv = mean(dfrv.rv)\n\nrvlike = StarAbsoluteRVObs(\n    dfrv,\n    name=\"GaiaRV\",\n    variables=@variables begin\n        offset ~ Normal(mean_rv, 10_000)  # wide prior on RV offset centred on mean RV  \n        jitter ~ LogUniform(0.01, 100_000)  # RV jitter parameter\n    end\n)\nerrorbars(\n    dfrv.obs_time_tcb,\n    dfrv.rv,\n    dfrv.σ_rv\n)\n\nNow, we define a model that incorporates this data:\n\nmjup2msol = Octofitter.mjup2msol\nref_epoch_mjd = Octofitter.meta_gaia_DR3.ref_epoch_mjd\norbit_ref_epoch = mean(gaiaIADlike.table.epoch)\n\nb = Planet(\n    name=\"BH\",\n    basis=AbsoluteVisual{KepOrbit},\n    observations=[],\n    variables=@variables begin\n        a ~ Uniform(0, 1000)\n        e ~ Uniform(0, 0.99)\n        ω ~ UniformCircular()\n        i ~ Sine()\n        Ω ~ UniformCircular()\n        θ ~ UniformCircular()\n        tp = θ_at_epoch_to_tperi(θ, $orbit_ref_epoch; M=system.M, e, a, i, ω, Ω)\n        mass = system.M_sec / mjup2msol\n    end\n)\n# DR3 catalog position and reference epoch\ngaia_ra = 294.82786250815144\ngaia_dec = 14.930979608612361\nref_epoch_mjd = Octofitter.meta_gaia_DR3.ref_epoch_mjd\nsys = System(\n    name=\"gaiadr4test\",\n    companions=[b],\n    observations=[gaiaIADlike, rvlike,],\n    variables=@variables begin\n        M_pri ~ truncated(Normal(0.76,0.05),lower=0.1) # M sun\n        M_sec ~ LogUniform(1, 1000) # M sun\n        M = M_pri + M_sec\n        # Note: keep these physically plausible to prevent numerical errors\n        plx ~ Uniform(0.01,100) # mas\n        pmra ~ Uniform(-1000, 1000) # mas/yr\n        pmdec ~  Uniform(-1000, 1000) # mas/yr\n        rv = −333.2e3 # m/s\n\n        # Put a prior of the catalog value +- 10,000 mas on position\n        ra_offset_mas ~ Normal(0, 10000)\n        dec_offset_mas ~ Normal(0, 10000)\n        dec = $gaia_dec + ra_offset_mas / 60 / 60 / 1000\n        ra = $gaia_ra + dec_offset_mas / 60 / 60 / 1000 / cosd(dec)\n        # Important! This is the reference epoch for the ra and dec provided above, *not* necessarily DR4.\n        ref_epoch = $ref_epoch_mjd\n    end\n)\nmodel = Octofitter.LogDensityModel(sys, verbosity=4)\n\nWe will initialize the model starting positions and visualize them:\n\n# Note: you can see the required format for paramter initialization by running:\n# nt = Octofitter.drawfrompriors(model.system);\n# println(nt)\n# then remove any derived parameters (parameters in your model that are on the right of an `=`)\n\ninit_chain = initialize!(model, (;\n    M_pri = 0.7792923132247755,\n    M_sec = 36.032664849109906,\n    plx = 1.6686144513164856,\n    pmra = -27.89740759925553,\n    pmdec = -156.1023951519146,\n    ra_offset_mas = 236.8072112885035,\n    dec_offset_mas = 45.781075653307376,\n    observations = (GaiaDR4 = (astrometric_jitter = 0.027554101045898238,),\n    GaiaRV = (offset = -359481.6706770764,jitter = 2143.4793485877644)),\n    planets = (BH = (\n        a = 18.905647598089196,\n        e = 0.7583328001601555,\n        ωx = -0.19433584569119122,\n        ωy = -0.9414842877197981,\n        i = 1.9216027029499319,\n        Ωx = -0.9890745570284801,\n        Ωy = 0.9268637554445821,\n        θx = 0.4250634152645573,\n        θy = -0.19794636356747858,\n    ),\n)); verbosity=4)\noctoplot(model, init_chain, show_rv=true)\n\nnote: Note\nIf you don't pick the starting point, you cabn also just run Pigeons for 8-10 rounds, which is recommended anyways for convergence, and the sampler will find this result.\n\nNow, we can perform the fit. It is a little slow since we have many hundreds of RV and astrometry data points.\n\nusing Pigeons\nchain, pt = octofit_pigeons(model, n_rounds=6) # might need more rounds to converge\n\nincrement_n_rounds!(pt,1)\nchain,pt = octofit_pigeons(pt)\n\nFinally, we can visualize the results:\n\noctoplot(model, chain, show_rv=true, mark_epochs_mjd=mjd.([\n    \"2017\"\n    \"2022\"\n    \"2027\"\n]))\n\noctocorner(model, chain, small=true)\n\nOctofitter.rvpostplot(model, chain)","category":"section"},{"location":"fit-likemap/#fit-likemap","page":"Likelihood Map","title":"Fitting Likelihood Maps","text":"There are circumstances where you might have a 2D map of planet likelihood vs. position in the plane of the sky (Delta R.A. and Dec.). These could originate from:\n\ncleaned interferometer data \nsome kind of spectroscopic cube model fitting to detect planets\nsome other imaginative modelling process I haven't thought of!\n\nYou can feed such 2D likelihood maps in to Octofitter. Simply pass in a list of maps and a platescale mapping the pixel size to a separation in milliarcseconds.  You can of course also mix these likelihood maps with relative astrometry, radial velocity, proper motion, images, etc.\n\nIf your likelihood map is not centered on the star, you can specify offset dimensions as shown below.\n\nnote: Note\nImage modelling is supported in Octofitter via the extension package OctofitterImages. To install it, run  pkg> add http://github.com/sefffal/Octofitter.jl:OctofitterImages\n\nnote: Note\nFor simple models of interferometer data, OctofitterInterferometry.jl can already handle fitting point sources directly to visibilities.\n\nusing Octofitter\nusing Distributions\nusing OctofitterImages\nusing Pigeons\nusing AstroImages\n\nTypically one would load your likelihood maps from eg. FITS files like so:\n\n# If centred at the star:\nimage1 = AstroImages.recenter(AstroImages.load(\"image-example-1.fits\",1))\n\n# If not centered at the star:\nimage1 = AstroImages.load(\"image-example-1.fits\")\nimage1_offset = AstroImage(\n    image1,\n    # Specify coordinates here:\n    (\n        # X coordinates should go from negative to positive.\n        # The image should have +RA at the left.\n        X(-4.85878653527304:1.0:95.14121346472696),\n        Y(-69.0877222942365:1.0:30.9122777057635)\n    )\n    # Below, there is a platescale option. `platescale` multiplies\n    # these values by a scaling factor. It can be 1 if the coordinates\n    # above are already in milliarcseconds.\n)\nimview(image1_offset)\n\nIf you're using a FITS file, make sure to store your data in 64-bit floating point format.\n\nFor this demonstration, however, we will construct two synthetic likelihood maps using a template orbit. We will create three peaks in two epochs.\n\n\norbit_template = orbit(\n    a = 1.0,\n    e = 0.1,\n    i = 0.0,\n    ω = 0.0,\n    Ω = 0.5,\n    plx = 50.0,\n    M = 1\n)\nepochs = [\n    mjd(\"2024-01-30\"),\n    mjd(\"2024-02-29\"),\n]\n\n## Create simulated data with three likelihood peaks at both epochs\nx1,y1 = raoff(orbit_template,epochs[1]), decoff(orbit_template,epochs[1])\n# The three peaks in our likelihood map\nd1 = MvNormal([x1, y1], [\n    5.0 0.2\n    0.2 8.0\n])\nd2 = MvNormal([x1+8.0,y1+4], [\n    5.0 0.6\n    0.6 5.0\n])\nd3 = MvNormal([x1+9.0, y1-10.0], [\n    6.0 0.6\n    0.6 6.0\n])\nd = MixtureModel([d1, d2, d3], [0.5, 0.3, 0.2])\n\n# Calculate a log-likelihood map over a +-50 mas patch around (x1, x2)\nlm1 = broadcast(x1 .+ (-50:50), y1 .+ (-50:1:50)') do x, y\n    logpdf(d, [x, y])\nend\n\n# Place in an AstroImage with appropriate offset coordinates\nimage1_offset = AstroImage(\n    lm1,\n    # Specify coordinates here:\n    (\n        # X coordinates should go from negative to positive.\n        # The image should have +RA at the left.\n        X(x1 .+ (-50:50)),\n        Y(y1 .+ (-50:1:50))\n    )\n    # Below, there is a platescale option. `platescale` multiplies\n    # these values by a scaling factor. It can be 1 if the coordinates\n    # above are already in milliarcseconds.\n)\nimview(10 .^ image1_offset)\n\nThat was the first epoch. We now generate data for the second epoch:\n\n\nx2,y2 = raoff(orbit_template,epochs[2]), decoff(orbit_template,epochs[2])\n# The three peaks in our likelihood map\nd1 = MvNormal([x2, y2], [\n    5.0 0.2\n    0.2 8.0\n])\nd2 = MvNormal([x2+10.0,y2], [\n    5.0 0.6\n    0.6 5.0\n])\nd3 = MvNormal([x2-4.0, y2-10.0], [\n    6.0 0.6\n    0.6 6.0\n])\nd = MixtureModel([d1, d2, d3], [0.5, 0.3, 0.2])\n\n\n\nlm2 = broadcast(x2 .+ (-50:50), y2 .+ (-50:1:50)') do x, y\n    logpdf(d, [x, y])\nend\n# Place in an AstroImage with appropriate offset coordinates\nimage2_offset = AstroImage(\n    lm2,\n    # Specify coordinates here:\n    (\n        # X coordinates should go from negative to positive.\n        # The image should have +RA at the left.\n        X(x2 .+ (-50:50)),\n        Y(y2 .+ (-50:1:50))\n    )\n    # Below, there is a platescale option. `platescale` multiplies\n    # these values by a scaling factor. It can be 1 if the coordinates\n    # above are already in milliarcseconds.\n)\nimview(10 .^ image2_offset)\n\nOkay, we have our synthetic data. We now set up a LogLikelihoodMapObs object to contain our matrices of log likelihood values:\n\nFirst, create a table of our likelihood map observations:\n\nlikemap_dat = Table(;\n    epoch = epochs,\n    map = [image1_offset, image2_offset],\n    platescale = [1.0, 1.0] # milliarcseconds/pixel of the map\n)\n\nloglikemap = LogLikelihoodMapObs(\n    likemap_dat,\n    name=\"GRAVITY\",\n    variables=@variables begin\n        platescale = 1.0               # Platescale multiplier [could use: platescale ~ truncated(Normal(1, 0.01), lower=0)]\n        northangle = 0.0               # North angle offset in radians [could use: northangle ~ Normal(0, deg2rad(1))]\n    end\n);\n\nnote: Note\nThe likelihood maps will be interpolated using a simple bi-linear interpolation. \n\nWe now create a one-planet model and run the fit using octofit_pigeons. This parallel-tempered sampler is slower than the regular octofit, but is recommended over the default Hamiltonian Monte Carlo sampler due to the multi-modal nature of the data. \n\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[loglikemap],\n    variables=@variables begin\n        a ~ Uniform(0, 10)\n        e ~ Uniform(0.0, 0.5)\n        i ~ Sine()\n        M = system.M\n        ω ~ UniformCircular()\n        Ω ~ UniformCircular()\n        θ ~ UniformCircular()\n        tp = θ_at_epoch_to_tperi(θ, 60339.0; M, e, a, i, ω, Ω)  # reference epoch for θ. Choose an MJD date near your data.\n    end\n)\n\nsys = System(\n    name=\"Tutoria\",\n    companions=[planet_b],\n    observations=[],\n    variables=@variables begin\n        M ~ truncated(Normal(1.0, 0.1), lower=0.1)\n        plx ~ truncated(Normal(50.0, 0.02), lower=0.1)\n    end\n)\n\nmodel = Octofitter.LogDensityModel(sys)\nchain, pt = octofit_pigeons(model, n_rounds=10) # increase n_rounds until log(Z₁/Z₀) converges.\ndisplay(chain)\n\nnote: Note\noctofit_pigeons scales very well across multiple cores. Start julia with julia --threads=auto to make sure you have multiple threads available for sampling.\n\nDisplay the results:\n\nusing CairoMakie\noctoplot(model, chain)\n\nCorner plot:\n\nusing CairoMakie, PairPlots\noctocorner(model,chain,small=true,)\n\nAnd finally let's look at the posterior predictive distributions at both epochs:\n\nels = Octofitter.construct_elements(model, chain,:b, :)\nx = raoff.(els, loglikemap.table.epoch[1])\ny = decoff.(els, loglikemap.table.epoch[1])\npairplot(\n    (;x,y),\n    axis=(\n        x = (;\n            lims=(low=100,high=-100)\n        ),\n        y = (;\n            lims=(low=-100,high=100)\n        )\n    )\n)\n\nx = raoff.(els, loglikemap.table.epoch[2])\ny = decoff.(els, loglikemap.table.epoch[2])\npairplot(\n    (;x,y),\n    axis=(\n        x = (;\n            lims=(low=100,high=-100)\n        ),\n        y = (;\n            lims=(low=-100,high=100)\n        )\n    )\n)","category":"section"},{"location":"fit-likemap/#Resume-sampling-for-additional-rounds","page":"Likelihood Map","title":"Resume sampling for additional rounds","text":"If you would like to add additional rounds of sampling, you may do the following:\n\npt = increment_n_rounds!(pt, 2)\nchain, pt = octofit_pigeons(pt)\n\nUpdated corner plot:\n\nusing CairoMakie, PairPlots\noctocorner(model,chain,small=false,)","category":"section"},{"location":"rel-astrom/#fit-astrometry","page":"Basic Astrom Fit","title":"Basic Astrometry Fit","text":"Here is a worked example of a one-planet model fit to relative astrometry (positions measured between the planet and the host star). \n\nStart by loading the Octofitter and Distributions packages:\n\nusing Octofitter, Distributions","category":"section"},{"location":"rel-astrom/#Specifying-the-data","page":"Basic Astrom Fit","title":"Specifying the data","text":"We will create a likelihood object to contain our relative astrometry data. We can specify this data in several formats. It can be listed in the code or loaded from a file (eg. a CSV file, FITS table, or SQL database). You can use any Julia table object.\n\nastrom_dat_1 = Table(;\n    epoch= [50000,  50120, 50240, 50360,50480, 50600, 50720, 50840,], # MJD (days)\n    ra   = [-505.764, -502.57, -498.209, -492.678,-485.977, -478.11, -469.08, -458.896,], # mas\n    dec  = [-66.9298, -37.4722, -7.92755, 21.6356, 51.1472,  80.5359,  109.729,  138.651, ], # mas\n    # Tip! Type this as \\sigma + <TAB key>!\n    σ_ra = [10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, ],  # mas\n    σ_dec = [10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, ], # mas\n    cor =  [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, ]\n)\nastrom_obs_1 = PlanetRelAstromObs(astrom_dat_1, name=\"relastrom\")\n\nIn Octofitter, epoch is always the modified Julian date (measured in days). If you're not sure what this is, you can get started by just putting in arbitrary time offsets measured in days.\n\nIn this case, we specified ra and dec offsets in milliarcseconds. We could instead specify sep (projected separation) in milliarcseconds and pa in radians. You cannot mix the two formats in a single PlanetRelAstromObs but you can create two different likelihood objects, one for each format, and add them both to your model:\n\nYou can also specify it in separation (mas) and positon angle (rad):\n\nastrom_dat_2 = Table(\n    epoch = [42000, ], # MJD\n    sep = [505.7637580573554, ], # mas\n    pa = [deg2rad(24.1), ], # radians\n    # Tip! Type this as \\sigma + <TAB key>!\n    σ_sep = [70, ],\n    σ_pa = [deg2rad(10.2), ],\n)\nastrom_obs_2 = PlanetRelAstromObs(astrom_dat_2, name=\"relastrom2\")\n\nnote: Note\nTip: You can load data from a CSV file:using CSV\nastrom_dat = CSV.read(\"mydata.csv\", Table)","category":"section"},{"location":"rel-astrom/#Advanced-Options","page":"Basic Astrom Fit","title":"Advanced Options","text":"You can group your data in different likelihood objects, each with their own instrument name. Each group can have its own platescale, northangle, and astrometric jitter variables for modelling instrument-specific systematics.\n\nastrom_obs_1 = PlanetRelAstromObs(\n    astrom_dat_1,\n    name = \"GPI astrom\",\n    variables = @variables begin\n        jitter ~ Uniform(0, 10) # mas [optional]\n        northangle ~ Normal(0, deg2rad(1)) # radians of offset [optional]\n        platescale ~ truncated(Normal(1, 0.01), lower=0) # 1% relative platescale uncertainty \n    end\n)\n\nastrom_obs_2 = PlanetRelAstromObs(\n    astrom_dat_2,\n    name = \"SPHERE astrom\",\n    variables = @variables begin\n        jitter ~ Uniform(0, 10) # mas [optional]\n        northangle ~ Normal(0, deg2rad(1)) # radians of offset [optional]\n        platescale ~ truncated(Normal(1, 0.01), lower=0) # 1% relative platescale uncertainty \n    end\n)\nnothing # hide\n\nIn Octofitter, epoch is always the modified Julian date (measured in days). If you're not sure what this is, you can get started by just putting in arbitrary time offsets measured in days.\n\nIn this case, we specified ra and dec offsets in milliarcseconds. We could instead specify sep (projected separation) in milliarcseconds and pa in radians. You cannot mix the two formats in a single PlanetRelAstromObs but you can create two different likelihood objects, one for each format.","category":"section"},{"location":"rel-astrom/#Creating-a-planet","page":"Basic Astrom Fit","title":"Creating a planet","text":"We now create our first planet model. Let's name it planet b.  The name of the planet will be used in the output results.\n\nIn Octofitter, we specify planet and system models using a \"probabilistic programming language\". Quantities with a ~ are random variables. The distributions on the right hand sides are priors. You must specify a  proper prior for any quantity which is allowed to vary. \n\nWe now create a planet model incorporating our likelihoods and specify our priors.\n\nplanet_1 = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[astrom_obs_1, astrom_obs_2],\n    variables=@variables begin\n        plx = system.plx\n        M ~ truncated(Normal(1.2, 0.1), lower=0.1)\n        a ~ Uniform(0, 100)\n        e ~ Uniform(0.0, 0.5)\n        i ~ Sine()\n        ω ~ UniformCircular()\n        Ω ~ UniformCircular()\n        θ ~ UniformCircular()\n        tp = θ_at_epoch_to_tperi(θ, 50420; M, e, a, i, ω, Ω)\n    end\n)\nnothing # hide\n\nname: Try to give your companion a short name consisting only of letters and/or trailing numbers.\n\nbasis: Visual{KepOrbit} is the type of orbit parameterization. There are several options available in the PlanetOrbits.jl documentation. The basis controls how how the orbit is calculated and what variables must be supplied.\n\nlikelihoods: A list of zero or more likelihood objects containing our data\n\nvariables: The variables block specifies our priors. You must supply every variable needed by your chosen basis, in this case:\n\nM, the total mass of the system in solar masses\nplx, the parallax distance to the system in milliarseconds\na: Semi-major axis, astronomical units (AU)\ni: Inclination, radians\ne: Eccentricity in the range [0, 1)\nω: Argument of periastron, radius\nΩ: Longitude of the ascending node, radians.\ntp: Epoch of periastron passage\n\nPriors can be any distribution from the Distributions.jl package.\n\nMany different distributions are supported as priors, including Uniform, LogNormal, LogUniform, Sine, and Beta. See the section on Priors for more information. The parameters can be specified in any order.\n\nYou can also hardcode a particular value for any parameter if you don't want it to vary. Simply replace eg. e ~ Uniform(0, 0.999) with e = 0.1. This = syntax works for arbitrary mathematical expressions and even functions. We use it here to reparameterize tp as a function of the planet's position angle on a given date. The = syntax also works to access variables from higher levels of the system.\n\nwarning: Warning\nYou must specify a proper prior for any quantity which is allowed to vary.  \"Uninformative\" priors like 1/x must be given bounds, and can be specified with LogUniform(lower, upper).\n\nwarning: Warning\nMake sure that variables like mass and eccentricity can't be negative. You can pass a distribution to truncated to prevent this, e.g. M ~ truncated(Normal(1, 0.1),lower=0).","category":"section"},{"location":"rel-astrom/#Creating-a-system","page":"Basic Astrom Fit","title":"Creating a system","text":"Now, we add our planets to a \"system\". Properties of the whole system are specified here, like parallax distance. For multi-planet systems, it makes sense to create shared variables here for e.g. the mass of the primary which is then used in all planet models. This is also where you will supply data like images, astrometric acceleration, or stellar radial velocity since they don't belong to any planet in particular.\n\nsys = System(\n    name = \"Tutoria\",\n    companions=[planet_1],\n    observations=[],\n    variables=@variables begin\n        plx ~ truncated(Normal(50.0, 0.02), lower=0.1)\n    end\n)\n\nnothing #hide\n\nnote: Note\nThe name of your system will be used for various output file names by default – we suggest naming it something like \"PDS70-astrom-model-v1\".\n\nThe variables block works just like it does for planets. Here, we provided the parallax distance to the system:\n\nplx: Distance to the system expressed in milliarcseconds of parallax.","category":"section"},{"location":"rel-astrom/#Prepare-model","page":"Basic Astrom Fit","title":"Prepare model","text":"We now convert our declarative model into efficient, compiled code:\n\nmodel = Octofitter.LogDensityModel(sys)\n\nThis type implements the julia LogDensityProblems.jl interface and can be passed to a wide variety of samplers.","category":"section"},{"location":"rel-astrom/#Initialize-starting-points-for-chains","page":"Basic Astrom Fit","title":"Initialize starting points for chains","text":"Run the initialize! function to find good starting points for the chain. You can provide guesses for parameters if you want to.\n\ninit_chain = initialize!(model) # No guesses provided, slower global optimization will be used\n\ninit_chain = initialize!(model, (;\n    plx = 50,\n    planets = (;\n        b=(;\n            M = 1.21,\n            a = 10.0,\n            e = 0.01,\n           \n        )\n    )\n))\n\nwarning: Warning\nNever initialize a value on the bounds of the prior. For example, exactly 0.00000 eccentricity is disallowed by the Uniform(0,1) prior. ","category":"section"},{"location":"rel-astrom/#Visualize-the-starting-points","page":"Basic Astrom Fit","title":"Visualize the starting points","text":"Plot the inital values to make sure that they are reasonable, and match your data. This is a great time to confirm that your data were entered in correctly.\n\nusing CairoMakie\noctoplot(model, init_chain)\n\nThe starting points for sampling look reasonable!\n\nnote: Note\nThe return value from initialize! is a \"variational approximation\". You can pass that chain to any function expecting a chain argument, like Octofitter.savechain or octocorner. It gives a very rough approximation of the posterior we expect.","category":"section"},{"location":"rel-astrom/#Sampling","page":"Basic Astrom Fit","title":"Sampling","text":"Now we are ready to draw samples from the posterior:\n\noctofit(model, verbosity = 0,iterations=2,adaptation=2,); # hide\nchain = octofit(model, iterations=1000)\n\nYou will get an output that looks something like this with a progress bar that updates every second or so. You can reduce or completely silence the output by reducing the verbosity value down to 0 from a default of 2 (or get more info with verbosity=4).\n\nOnce complete, the chain object will hold the posterior samples. Displaying it prints out a summary table like the one shown above.\n\nFor a basic model like this with few epochs and well-specified uncertainties, sampling should take less than a minute on a typical laptop.\n\nSampling can take much longer when you have measurements with very small uncertainties (e.g. VLTI-GRAVITY).","category":"section"},{"location":"rel-astrom/#Diagnostics","page":"Basic Astrom Fit","title":"Diagnostics","text":"The first thing you should do with your results is check a few diagnostics to make sure the sampler converged as intended.\n\nA few things to watch out for: check that you aren't getting many numerical errors (ratio_divergent_transitions).  This likely indicates a problem with your model: either invalid values of one or more parameters are encountered (e.g. the prior on semi-major axis includes negative values) or that there is a region of very high curvature that is failing to sample properly. This latter issue can lead to a bias in your results.\n\nOne common mistake is to use a distribution like Normal(10,3) for semi-major axis. This left tail of this distribution includes negative values, and our orbit model is not defined for negative semi-major axes. A better choice is a truncated(Normal(10,3), lower=0.1) distribution (not including zero, since a=0 is not defined).\n\nNext, you can make a trace plot of different variabes to visually inspect the chain:\n\nusing CairoMakie\nlines(\n    chain[\"b_a\"][:],\n    axis=(;\n        xlabel=\"iteration\",\n        ylabel=\"semi-major axis (AU)\"\n    )\n)\n\nAnd an auto-correlation plot:\n\nusing StatsBase\nusing CairoMakie\nlines(\n    autocor(chain[\"b_e\"][:], 1:500),\n    axis=(;\n        xlabel=\"lag\",\n        ylabel=\"autocorrelation\",\n    )\n)\n\nThis plot shows that these samples are not correlated after only about 5 iterations. No thinning is necessary.\n\nTo confirm convergence, you may also examine the rhat column from chains. This diagnostic approaches 1 as the chains converge and should at the very least equal 1.0 to one significant digit (3 recommended).\n\nFinaly, you might consider running multiple chains. Simply run octofit multiple times, and store the result in different variables. Then you can combine the chains using chainscat and run additional inter-chain convergence diagnostics:\n\nusing MCMCChains\nchain1 = octofit(model)\nchain2 = octofit(model)\nchain3 = octofit(model)\nmerged_chains = chainscat(chain1, chain2, chain3)\ngelmandiag(merged_chains)\n\nThis will check that the means and variances are similar between chains that were initialized at different starting points.","category":"section"},{"location":"rel-astrom/#Analysis","page":"Basic Astrom Fit","title":"Analysis","text":"As a first pass, let's plot a sample of orbits drawn from the posterior. The function octoplot is a conveninient way to generate a 9-panel plot of velocities and position:\n\nusing CairoMakie\noctoplot(model,merged_chains)\n\nThis function draws orbits from the posterior and displays them in a plot. Any astrometry points are overplotted. \n\nYou can control what panels are displayed, the time range, colourscheme, etc. See the documentation on octoplot for more details.","category":"section"},{"location":"rel-astrom/#Pair-Plot","page":"Basic Astrom Fit","title":"Pair Plot","text":"A very useful visualization of our results is a pair-plot, or corner plot. We can use the octocorner function and our PairPlots.jl package for this purpose:\n\nusing CairoMakie\nusing PairPlots\noctocorner(model, merged_chains, small=true)\n\nRemove small=true to display all variables.\n\nIn this case, the sampler was able to resolve the complicated degeneracies between eccentricity, the longitude of the ascending node, and argument of periapsis.","category":"section"},{"location":"rel-astrom/#Saving-your-chain","page":"Basic Astrom Fit","title":"Saving your chain","text":"Variables can be retrieved from the chains using the following sytnax: sma_planet_b = chain[\"b_a\",:,:]. The first index is a string or symbol giving the name of the variable in the model. Planet variables are prepended by the name of the planet and an underscore.\n\nYou can save your chain in FITS table format by running:\n\nOctofitter.savechain(\"mychain.fits\", chain)\n\nYou can load it back via:\n\nchain = Octofitter.loadchain(\"mychain.fits\")","category":"section"},{"location":"rel-astrom/#Saving-your-model","page":"Basic Astrom Fit","title":"Saving your model","text":"You may choose to save your model so that you can reload it later to make plots, etc:\n\nusing Serialization\nserialize(\"model1.jls\", model)\n\nWhich can then be loaded at a later time using:\n\nusing Serialization\nusing Octofitter # must include all the same imports as your original script\nmodel = deserialize(\"model1.jls\")\n\nwarning: Warning\nSerialized models are only loadable/restorable on the same computer, version of Octofitter, and version of Julia. They are not intended for long-term archiving. For reproducibility, make sure to keep your original model definition script.","category":"section"},{"location":"rel-astrom/#Comparing-chains","page":"Basic Astrom Fit","title":"Comparing chains","text":"We can compare two different chains by passing them both to octocorner. Let's compare the init_chain with the full results from octofit:\n\noctocorner(model, chain, init_chain, small=true)","category":"section"},{"location":"thiele-innes/#Fit-with-a-Thiele-Innes-Basis","page":"Thiele-Innes Parameters","title":"Fit with a Thiele-Innes Basis","text":"This example shows how to fit relative astrometry using a Thiele-Innes orbital basis instead of the traditional Campbell basis used in other tutorials. The Thiele-Innes basis is more suitable then Campbell for fitting low-eccentricity orbits, because it does not have the issues where ω, Ω, and tp become degenerate as eccentricity and/or inclination fall to zero.\n\nAt the end, we will convert our results back into the Campbell basis to compare.\n\nusing Octofitter\nusing CairoMakie\nusing PairPlots\nusing Distributions\n\nastrom_dat = Table(;\n    epoch = [50000, 50120, 50240, 50360, 50480, 50600, 50720, 50840],\n    ra    = [-505.7637580573554, -502.570356287689, -498.2089148883798, -492.67768482682357, -485.9770335870402, -478.1095526888573, -469.0801731788123, -458.89628893460525],\n    dec   = [-66.92982418533026, -37.47217527025044, -7.927548139010479, 21.63557115669823, 51.147204404903704, 80.53589069730698, 109.72870493064629, 138.65128697876773],\n    σ_ra  = [10, 10, 10, 10, 10, 10, 10, 10],\n    σ_dec = [10, 10, 10, 10, 10, 10, 10, 10],\n    cor   = [0, 0, 0, 0, 0, 0, 0, 0]\n)\n\nastrom_obs = PlanetRelAstromObs(\n    astrom_dat,\n    name = \"GPI\",\n    variables = @variables begin\n        # Fixed values for this example - could be free variables:\n        jitter = 0        # mas [could use: jitter ~ Uniform(0, 10)]\n        northangle = 0    # radians [could use: northangle ~ Normal(0, deg2rad(1))]\n        platescale = 1    # relative [could use: platescale ~ truncated(Normal(1, 0.01), lower=0)]\n    end\n)\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=ThieleInnesOrbit,\n    observations=[astrom_obs],\n    variables=@variables begin\n        e ~ Uniform(0.0, 0.5)\n        A ~ Normal(0, 1000) # milliarcseconds\n        B ~ Normal(0, 1000) # milliarcseconds\n        F ~ Normal(0, 1000) # milliarcseconds\n        G ~ Normal(0, 1000) # milliarcseconds\n        \n        M = system.M\n        θ ~ UniformCircular()\n        tp = θ_at_epoch_to_tperi(θ, 50000.0; system.plx, M, e, A, B, F, G)  # reference epoch for θ. Choose an MJD date near your data.\n    end\n)\n\nsys = System(\n    name=\"TutoriaPrime\",\n    companions=[planet_b],\n    observations=[],\n    variables=@variables begin\n        M ~ truncated(Normal(1.2, 0.1), lower=0.1)\n        plx ~ truncated(Normal(50.0, 0.02), lower=0.1)\n    end\n)\n\nmodel = Octofitter.LogDensityModel(sys)\n\nInitialize the starting points, and confirm the data are entered correcly:\n\ninit_chain = initialize!(model)\noctoplot(model, init_chain)\n\nWe now sample from the model as usual:\n\nresults = octofit(model)\n\nNotice that the fit was very very fast! The Thiele-Innes orbital paramterization is easier to explore than the default Campbell in  many cases.\n\nWe now display the results:\n\noctoplot(model,results)\n\noctocorner(model, results, small=false)","category":"section"},{"location":"thiele-innes/#Conversion-back-to-Campbell-Elements","page":"Thiele-Innes Parameters","title":"Conversion back to Campbell Elements","text":"To convert our chain into the more familiar Campbell parameterization, we have to do a few steps. We start by turning the chain table into a an array of orbit objects, and then convert their type:\n\norbits_ti = Octofitter.construct_elements(model, results, :b, :) # colon means all rows\n\nHere is one of those entries:\n\ndisplay(orbits_ti[1])\n\nWe can now make a table of results (and visualize them in a corner plot) by querying properties of these objects:\n\ntable = (;\n    B_a = semimajoraxis.(orbits_ti),\n    B_e = eccentricity.(orbits_ti),\n    B_i = rad2deg.(inclination.(orbits_ti)),\n)\npairplot(table)\n\nWe can also convert the orbit objects into Campbell parameters:\n\norbits_campbell = Visual{KepOrbit}.(orbits_ti)\norbits_campbell[1]","category":"section"},{"location":"fit-grav-wide/#Fit-GRAVITY-WIDE-Data","page":"GRAVITY Wide Data","title":"Fit GRAVITY-WIDE Data","text":"","category":"section"},{"location":"fit-grav-wide/#Background","page":"GRAVITY Wide Data","title":"Background","text":"Octofitter has support for directly fitting GRAVITY-WIDE closure phase data, in the OI-FITS format emitted by the pipeline. The closure phases are mapped to a set of non-redundant kernel phases. All spectral channels are modelled separately per exposure.\n\nnote: Note\nGRAVITY modelling is supported in Octofitter via the extension package OctofitterInterferometry. To install it, run  pkg> add http://github.com/sefffal/Octofitter.jl:OctofitterInterferometry\n\nThe only supported astrophysical sources at this time are zero or more point sources orbiting a primary body.\n\nInterferometer data is almost always multi-modal, requiring the use of parallel tempering. Multi-wavelength GRAVITY-WIDE data with multiple epochs is fairly expensive to model (can take on the order of 1ms per likelihood evaluation), so one after running some tests locally, one should consider using a compute cluster. You will probably want on the order of 30 cores and 1-5 days, depending on the scale of the problem.","category":"section"},{"location":"fit-grav-wide/#Process","page":"GRAVITY Wide Data","title":"Process","text":"using Octofitter\nusing OctofitterInterferometry\nusing Distributions\nusing CairoMakie\nusing PairPlots\n\nTo model orbits / brightness of a companion from GRAVITY-WIDE data, use the following observation:\n\nvis_obs = GRAVITYWideKPObs(\n    (;\n        filename=\"./GRAVI.2025-01-01T00:11:11.111_dualscivis.fits\",\n        epoch=60676.00776748842,\n        wavelength_min_meters=2.025e-6,\n        wavelength_max_meters=2.15e-6,\n        jitter=:kp_jit,\n        kp_Cy=:kp_Cy,\n    ),\n    # Add more exposures / epochs here if desired...\n    variables=@variables begin\n        # For single planet:\n        flux ~ [Uniform(0, 1)]       # Planet flux/contrast ratio (array with one element)\n        \n        # For multiple planets (array - one per planet):\n        # flux ~ Product([Uniform(0, 1), Uniform(0, 1)])  # flux ratio for each planet\n        \n        # Optional: observation-specific variables can be defined here\n        # kp_jit ~ Uniform(0, 180)  # kernel phase jitter\n        # kp_Cy ~ Uniform(-1, 1)     # spectral correlation parameter\n    end\n)\n\nfilename is the path from your current working directory to the GRAVITY OI-FITS file.\nepoch is the average time of the exposure in MJD (not the start of the exposure!).\nwavelength_min_meters and wavelength_max_meters are wavelength cutoffs for the data if you want to restrict to only include some channels from the file (optional)\nflux variable should be defined in the likelihood's variables block to specify the planet flux/contrast ratio. For multiple planets, use Product([...]) with one distribution per planet.\njitter is a symbol giving the name of a kernel phase jitter variable to use for this exposure. This can be defined in the likelihood's variables block or in the system/planet variables.\nkp_Cy is a symbol giving the name of the spectral correlation variable to use for this exposure (optional). This can be defined in the likelihood's variables block or in the system/planet variables.\n\nFor this example, we won't consider a full orbit. We will just sample from 2D separation and position angle coordinates. To this end, we will use the FixedPosition parameterization for the planet:\n\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{Octofitter.FixedPosition},\n    observations=[vis_obs],\n    variables=@variables begin\n        sep ~ Uniform(0, 10) # mas\n        pa ~ Uniform(0,2pi)\n    end\n)\n\nsys = System(\n    name=\"sys\",\n    companions=[planet_b],\n    observations=[],\n    variables=@variables begin\n        M ~ Normal(1.0, 0.1) # Add mass for orbit models\n        plx = 173.5740\n        # Optional: Kernel phase jitters per epoch can be defined here\n        # kp_jit ~ Uniform(0,180)# 12.8\n        # kp_Cy ~ Uniform(-1,1)\n    end\n)\n\nmodel = Octofitter.LogDensityModel(sys, verbosity=4)\n\nIt is recommended to use Pigeons parallel tempered sampling, and to use the SliceSampler explorer. This non-default option avoids calculating the gradient of the model, which is expensive in this case.\n\nOctofitter.default_initializer!(model,ntries=0)\n\nusing Pigeons\nchain, pt = octofit_pigeons(model, n_chains=8, n_chains_variational=0, n_rounds=9, explorer=SliceSampler())\n\nfig = Figure()\nax = Axis(\n    fig[1,1],\n    xreversed=true,\n    autolimitaspect=1\n)\nxlims!(ax, 10,-10)\nylims!(ax, -10,10)\nx = vec(chain[:b_sep]) .* sin.(vec(chain[:b_pa]))\ny = vec(chain[:b_sep]) .* cos.(vec(chain[:b_pa]))\nscatter!(ax,x,y)\nfig\n\nSince we are only considering a single epoch, we can also go ahead and generate a detection map by performing a grid-search over positions.\n\nks = 0.5:0.5#0.4:0.1:0.6 #0.01:0.1:1.0\nxs =  (-10:0.25:10) .+ 1e-6\nys = (-10:0.25:10)\n\nks_ = reshape(ks, 1,1,:)\nseps = sqrt.(xs.^2 .+ ys'.^2) .+ 0ks_\npas = atan.(xs, ys') .+ 0ks_\nks__ = ks_ .+ 0seps\nLL = fill(NaN,length(xs), length(ys), length(ks))\njit = 12.6\nCy = 0.02\n@time Threads.@threads for i in eachindex(LL)\n    sep = seps[i]\n    if sep > 10\n        continue\n    end\n    pa = rem2pi(pas[i], RoundDown)\n    K = ks__[i]\n    LL[i] = model.ℓπcallback(model.link((jit,Cy,sep,pa,K)),sampled=false)\nend\n\nfig = Figure()\nax = Axis(\n    fig[1,1],\n    xreversed=true,\n    autolimitaspect=1,\n    backgroundcolor=\"#222\",\n    title=\"spec corr = 0.02\"\n)\n\nN_dat = length(vis_obs.table.epoch)*length(vis_obs.table.eff_wave[1])*3 # 3 kern phases\nN_param = 3\nχ²_max = maximum(LL,dims=3)[:,:] ./ (N_dat + N_param)\nh = heatmap!(ax,\n    xs,ys, χ²_max,\n    # LL[:,:,1],\n    colormap=:magma,\n    colorrange=(quantile(filter(isfinite,χ²_max),0.85), maximum(filter(isfinite,χ²_max)))\n    # colorrange=(quantile(filter(isfinite,LL),0.85), maximum(filter(isfinite,LL)))\n    # colorrange=(maximum(filter(isfinite,χ²_max))-3, maximum(filter(isfinite,χ²_max)))\n)\n\n\nColorbar(fig[1,2],h,label=\"Log-Posterior Density\")\n\nfig\n\nThis single-epoch model can then be extended by replacing the FixedPosition parameterization with an orbit type like KepOrbit:\n\nplanet_b_orbit = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[vis_obs],\n    variables=@variables begin\n        M = system.M\n        a ~ Uniform(0, 0.1)\n        e ~ Uniform(0.0, 0.99)\n        i ~ Sine()\n        ω ~ UniformCircular()\n        Ω ~ UniformCircular()\n        θ ~ UniformCircular()\n        tp = θ_at_epoch_to_tperi(θ, 60676; M, e, a, i, ω, Ω)\n    end\n)","category":"section"},{"location":"installation/#install","page":"Installation","title":"Installation","text":"The first step to using Octofitter.jl is to install Julia. If you're used to Python, don't worry –- Julia is easy to install, and you won't need to code anything other than changing your input data.","category":"section"},{"location":"installation/#Installing-Julia","page":"Installation","title":"Installing Julia","text":"Visit the julialang.org Downloads page, and select the latest stable version for your operating system. This is 1.10.0 at the time of writing. Click the [help] links next to your operating system if you require more detailed instructions.","category":"section"},{"location":"installation/#Installing-Octofitter","page":"Installation","title":"Installing Octofitter","text":"Start julia in a terminal by running julia\nType ] to enter package-mode (see Julia documentation for more details)\nType add Octofitter Distributions CairoMakie PairPlots\n\nYou will need the Distributions,jl package so that you can specify priors for different parameters in your models. CairoMakie.jl is used for generating plots and isn't needed if you only want text-based summary outputs. PairPlots.jl (in combination with CairoMakie) is used for generating corner plots and can also be skipped if these aren't of interest.","category":"section"},{"location":"installation/#Extension-Packages","page":"Installation","title":"Extension Packages","text":"Some Octofitter functionality exists in extension packages, including radial velocity fitting. If you need one of these packages you can install them like so:\n\npkg> add OctofitterRadialVelocity\npkg> add http://github.com/sefffal/Octofitter.jl:OctofitterImages\npkg> add http://github.com/sefffal/Octofitter.jl:OctofitterInterferometry\n\nThese aren't included by default since they may include a number of heavier dependencies that aren't needed by all users. They are descibed further in relevant sections of the documentation.","category":"section"},{"location":"installation/#Fitting-your-first-model","page":"Installation","title":"Fitting your first model","text":"Start with the Quick Start tutorial. It shows how one can model the orbit of one planet based on relative astrometry points.","category":"section"},{"location":"astrom-pma-rv/#astrom-pma-rv","page":"Astrometry, PMA, and RV","title":"Fit Proper Motion Anomaly","text":"Octofitter.jl supports fitting orbit models to astrometric motion in the form of GAIA-Hipparcos proper motion anomaly (HGCA; https://arxiv.org/abs/2105.11662). These data points are calculated by finding the difference between a long term proper motion of a star between the Hipparcos and GAIA catalogs, and their proper motion calculated within the windows of each catalog. This gives four data points that can constrain the dynamical mass & orbits of planetary companions (assuming we subtract out the net trend).\n\nIf your star of interest is in the HGCA, all you need is it's GAIA DR3 ID number. You can find this number by searching for your target on SIMBAD.\n\nFor this tutorial, we will examine the star and companion HD 91312 A & B discovered by SCExAO. We will use their published astrometry and proper motion anomaly extracted from the HGCA.\n\nWe will also perform a model comparison: we will fit the same model to four different subsets of data to see how each dataset are impacting the final constraints. This is an important consistency check, especially with proper motion / absolute astrometry data which be susceptible to systematic errors.\n\nThe first step is to find the GAIA source ID for your object. For HD 91312, SIMBAD tells us the GAIA DR3 ID is 756291174721509376.\n\nPages = [\"astrom-pma-rv.md\"]\nDepth = 5","category":"section"},{"location":"astrom-pma-rv/#Model:-PMA-Only","page":"Astrometry, PMA, and RV","title":"Model: PMA Only","text":"Initial setup:\n\nusing Octofitter, Distributions, Random\n\nWe begin by finding orbits that are consistent with the astrometric motion. Later, we will add in relative astrometry to the fit from direct imaging to further constrain the planet's orbit and mass.\n\nCompared to previous tutorials, we will now have to add a few additional variables to our model. The first is a prior on the mass of the companion, called mass. The units used on this variable are Jupiter masses, in contrast to M, the primary's mass, in solar masses.  A reasonable uninformative prior for mass is Uniform(0,1000) or LogUniform(1,1000) depending on the situation.\n\nFor this model, we also want to place a prior on the host star mass rather than system total mass. For exoplanets there is litte difference between these two values, but in this example we have a reasonably informative prior on the host mass, and know from the paper that the companion is has a non-neglible effect on the total system mass.\n\nTo make this parameterization change, we specify priors on both masses in the @system block, and connect it to the planet.","category":"section"},{"location":"astrom-pma-rv/#Retrieving-the-HGCA","page":"Astrometry, PMA, and RV","title":"Retrieving the HGCA","text":"To start, we retrieve the HGCA data for this object.\n\nhgca_obs = HGCAObs(\n    gaia_id=756291174721509376,\n    variables=@variables begin\n        # Optional: flux ratio for luminous companions\n        # fluxratio ~ Product([Uniform(0, 1), Uniform(0, 1), ])  # uncomment if needed for unresolved companions\n    end\n)\n\nYou can optionally provide flux ratio priors in the variables block to represent the flux ratio of the companions to the host star. This is used to account for photocentre offsets caused by luminous companions. For typical exoplanets this can often just be set to 0 in the planet model definition, since they are so dim compared to the star.","category":"section"},{"location":"astrom-pma-rv/#Planet-Model","page":"Astrometry, PMA, and RV","title":"Planet Model","text":"planet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    variables=@variables begin\n        a ~ LogUniform(0.1,20)\n        e ~ Uniform(0,0.999)\n        ω ~ Uniform(0, 2pi)\n        i ~ Sine() # The Sine() distribution is defined by Octofitter\n        Ω ~ Uniform(0, 2pi)\n\n        mass = system.M_sec\n\n        θ ~ Uniform(0, 2pi)\n        M = system.M\n        tp = θ_at_epoch_to_tperi(θ, 57423.0; M, e, a, i, ω, Ω) # epoch of GAIA measurement\n\n        F = 0.0 # optional: set gaia flux ratio of secondary to host\n    end\n)","category":"section"},{"location":"astrom-pma-rv/#System-Model-and-Specifying-Proper-Motion-Anomaly","page":"Astrometry, PMA, and RV","title":"System Model & Specifying Proper Motion Anomaly","text":"Now that we have our planet model, we create a system model to contain it.\n\nWe specify priors on plx as usual, but here we use the gaia_plx helper function to read the parallax and uncertainty directly from the HGCA catalog using its source ID.\n\nWe also add parameters for the star's long term proper motion. This is usually close to the long term trend between the Hipparcos and GAIA measurements. If you're not sure what to use here, try Normal(0, 1000); that is, assume a long-term proper motion of 0 +- 1000 milliarcseconds / year.\n\nsys = System(\n    name=\"HD91312_pma\",\n    companions=[planet_b],\n    observations=[hgca_obs],\n    variables=@variables begin\n        M_pri ~ truncated(Normal(1.61, 0.1), lower=0.1) # Msol\n        M_sec ~ LogUniform(0.5, 1000) # MJup\n        M = M_pri + M_sec*Octofitter.mjup2msol # Msol\n\n        plx ~ gaia_plx(gaia_id=756291174721509376)\n                \n        # Priors on the center of mass proper motion\n        pmra ~ Normal(-137, 10)\n        pmdec ~ Normal(2,  10)\n    end\n)\n\nmodel_pma = Octofitter.LogDensityModel(sys)\n\nAfter the priors, we add the proper motion anomaly measurements from the HGCA. If this is your first time running this code, you will be prompted to automatically download and cache the catalog which may take around 30 seconds.","category":"section"},{"location":"astrom-pma-rv/#Sampling-from-the-posterior-(PMA-only)","page":"Astrometry, PMA, and RV","title":"Sampling from the posterior (PMA only)","text":"Because proper motion anomaly data is quite sparse, it can often produce multi-modal posteriors. If your orbit already has several relative astrometry or RV data points, this is less of an issue. But in many cases it is recommended to use the Pigeons.jl sampler instead of Octofitter's default. This sampler is less efficient for unimodal distributions, but is more robust at exploring posteriors with distinct, widely separated peaks. \n\nTo install and use Pigeons.jl with Octofitter, type using Pigeons at in the terminal and accept the prompt to install the package. You may have to restart Julia.\n\nnote: Note\noctofit_pigeons scales very well across multiple cores. Start julia with julia --threads=auto to make sure you have multiple threads available for sampling.\n\nWe now sample from our model using Pigeons:\n\nusing Pigeons\nchain_pma, pt = octofit_pigeons(model_pma, n_rounds=8, explorer=SliceSampler()) \ndisplay(chain_pma)\n\nNote that octofit_pigeons took somewhat longer to run than octofit typically does; however, as we will see, it sampled successfully from severally completely disconnected modes in the posterior. That makes it a good fit for sampling from proper motion anomaly and relative astrometry with limited orbital coverage.","category":"section"},{"location":"astrom-pma-rv/#Pair-Plot","page":"Astrometry, PMA, and RV","title":"Pair Plot","text":"If we wish to examine the covariance between parameters in more detail, we can construct a pair-plot (aka. corner plot).\n\n# Create a corner plot / pair plot.\n# We can access any property from the chain specified in Variables\nusing CairoMakie\nusing PairPlots\noctocorner(model_pma, chain_pma, small=true)\n\nNotice how there are completely separated peaks? The default Octofitter sample (Hamiltonian Monte Carlo) is capabale of jumping 2-3σ gaps between modes, but such widely separated peaks can cause issues (hence why we used Pigeons in this example).","category":"section"},{"location":"astrom-pma-rv/#Model:-PMA-and-Relative-Astrometry","page":"Astrometry, PMA, and RV","title":"Model: PMA & Relative Astrometry","text":"The first orbit fit to only Hipparcos/GAIA data was very unconstrained. We will now add six epochs of relative astrometry (measured from direct images) gathered from the discovery paper.\n\nastrom_dat = Table(;\n    epoch = [mjd(\"2016-12-15\"), mjd(\"2017-03-12\"), mjd(\"2017-03-13\"), mjd(\"2018-02-08\"), mjd(\"2018-11-28\"), mjd(\"2018-12-15\")],\n    ra    = [133., 126., 127., 083., 058., 056.],\n    dec   = [-174., -176., -172., -133., -122., -104.],\n    σ_ra  = [07.0, 04.0, 04.0, 10.0, 10.0, 08.0],\n    σ_dec = [07.0, 04.0, 04.0, 10.0, 20.0, 08.0],\n    cor   = [0.2, 0.3, 0.1, 0.4, 0.3, 0.2]\n)\n\nastrom_obs = PlanetRelAstromObs(\n    astrom_dat,\n    name = \"SCExAO\",\n    variables = @variables begin\n        # Fixed values for this example - could be free variables:\n        jitter = 0        # mas [could use: jitter ~ Uniform(0, 10)]\n        northangle = 0    # radians [could use: northangle ~ Normal(0, deg2rad(1))]\n        platescale = 1    # relative [could use: platescale ~ truncated(Normal(1, 0.01), lower=0)]\n    end\n)\nscatter(astrom_obs.table.ra, astrom_obs.table.dec)\n\nWe use the same model as before, but now condition the planet model B on the astrometry data by adding astrom_obs to the list of likelihoods in the planet model.\n\nusing OctofitterRadialVelocity\n\nrv_dat = Table(;\n    epoch = [mjd(\"2008-05-01\"), mjd(\"2010-02-15\"), mjd(\"2016-03-01\")],\n    rv    = [1300, 700, -2700],\n    σ_rv  = [150, 150, 150]\n)\n\nrvlike = PlanetRelativeRVObs(\n    rv_dat,\n    name=\"SOPHIE\",\n    variables=@variables begin\n        jitter ~ truncated(Normal(10, 5), lower=0)  # m/s [could fix: jitter = 0]\n    end\n)\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[ObsPriorAstromONeil2019(astrom_obs)],\n    variables=@variables begin\n        a ~ LogUniform(0.1,400)\n        e ~ Uniform(0,0.999)\n        ω ~ Uniform(0, 2pi)\n        i ~ Sine()\n        Ω ~ Uniform(0, 2pi)\n\n        mass = system.M_sec\n\n        θ ~ Uniform(0, 2pi)\n        M = system.M\n        tp = θ_at_epoch_to_tperi(θ, 57737.0; M, e, a, i, ω, Ω) # epoch of astrometry\n\n        F = 0.0\n    end\n)\n\nsys_astrom = System(\n    name=\"HD91312_pma_astrom\",\n    companions=[planet_b],\n    observations=[hgca_obs],\n    variables=@variables begin\n        M_pri ~ truncated(Normal(1.61, 0.1), lower=0.1)\n        M_sec ~ LogUniform(0.5, 1000) # MJup\n        M = M_pri + M_sec*Octofitter.mjup2msol\n\n        plx ~ gaia_plx(gaia_id=756291174721509376)\n\n        # Priors on the centre of mass proper motion\n        pmra ~ Normal(-137, 10)\n        pmdec ~ Normal(2,  10)\n    end\n)\n\nmodel_pma_astrom = Octofitter.LogDensityModel(sys_astrom,verbosity=4)\n\nusing Pigeons\nchain_pma_astrom, pt = octofit_pigeons(model_pma_astrom, n_rounds=7, explorer=SliceSampler())\nnothing # hide\n\noctoplot(model_pma_astrom, chain_pma_astrom)","category":"section"},{"location":"astrom-pma-rv/#Model:-PMA-and-Relative-Astrometry-and-RVs","page":"Astrometry, PMA, and RV","title":"Model: PMA & Relative Astrometry & RVs","text":"We now add in three additional epochs of stellar RVs.\n\nusing OctofitterRadialVelocity\n\nrv_dat_abs = Table(;\n    epoch = [mjd(\"2008-05-01\"), mjd(\"2010-02-15\"), mjd(\"2016-03-01\")],\n    rv    = [1300, 700, -2700],\n    σ_rv  = [150, 150, 150]\n)\n\nrvlike = StarAbsoluteRVObs(\n    rv_dat_abs,\n    name=\"SOPHIE\",\n    variables=@variables begin\n        jitter ~ truncated(Normal(10, 5), lower=0)  # m/s\n        offset ~ Normal(0, 1000)  # m/s\n    end\n)\n\nplanet_b_rv = Planet(\n    name=\"b\",\n    basis=AbsoluteVisual{KepOrbit},\n    observations=[ObsPriorAstromONeil2019(astrom_obs)],\n    variables=@variables begin\n        a ~ LogUniform(0.1,400)\n        e ~ Uniform(0,0.999)\n        ω ~ Uniform(0, 2pi)\n        i ~ Sine()\n        Ω ~ Uniform(0, 2pi)\n\n        mass = system.M_sec\n\n        θ ~ Uniform(0, 2pi)\n        M = system.M\n        tp = θ_at_epoch_to_tperi(θ, 57737.0; M, e, a, i, ω, Ω) # epoch of astrometry\n\n        F = 0.0\n    end\n)\n\n\nra = 158.30707896392835\ndec = 40.42555422701387\n\nsys_rv_astrom = System(\n    name=\"HD91312_pma_rv_astrom\",\n    companions=[planet_b_rv],\n    observations=[hgca_obs, rvlike],\n    variables=@variables begin\n        M_pri ~ truncated(Normal(1.61, 0.1), lower=0.1)\n        M_sec ~ LogUniform(0.5, 1000) # MJup\n        M = M_pri + M_sec*Octofitter.mjup2msol\n\n        plx ~ gaia_plx(gaia_id=756291174721509376)\n                \n        # Priors on the centre of mass proper motion\n        pmra ~ Normal(-137, 10)\n        pmdec ~ Normal(2,  10)\n\n        ra = $ra\n        dec = $dec\n        rv = 0*1e3 # m/s\n        ref_epoch = Octofitter.meta_gaia_DR3.ref_epoch_mjd\n    end\n)\n\nmodel_pma_rv_astrom = Octofitter.LogDensityModel(sys_rv_astrom,verbosity=4)\nchain_pma_rv_astrom, pt = octofit_pigeons(model_pma_rv_astrom, n_rounds=7, explorer=SliceSampler())\ndisplay(chain_pma_rv_astrom)\n\nThe mass vs. semi-major axis posterior is now much more constrained:\n\nusing CairoMakie, PairPlots\npairplot(\n    (; a=chain_pma_rv_astrom[\"b_a\"][:], mass=chain_pma_rv_astrom[\"b_mass\"][:]) =>\n        (\n            PairPlots.Scatter(color=:red,markersize=5),\n            PairPlots.MarginHist(),\n            PairPlots.MarginQuantileText()\n        ),\n    labels=Dict(:mass=>\"mass [Mⱼᵤₚ]\", :a=>\"sma. [au]\"),\n)\n\nIt is now useful to display the orbits projected onto the plane of the sky using octoplot. This function produces a nine-panel figure showing posterior predictive distributions for velocity (in three dimensions), projected positions vs. time in the plane of the sky,  and various other two and three-dimensional views.\n\noctoplot(model_pma_rv_astrom, chain_pma_rv_astrom, show_mass=true)","category":"section"},{"location":"astrom-pma-rv/#Model:-Relative-Astrometry-and-RVs-(no-PMA)","page":"Astrometry, PMA, and RV","title":"Model:  Relative Astrometry & RVs (no PMA)","text":"There is a final model we should consider: one using the RV and astrometry data, but not the proper motion anomaly:\n\nusing OctofitterRadialVelocity\n\nplanet_b_final = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[ObsPriorAstromONeil2019(astrom_obs)],\n    variables=@variables begin\n        a ~ LogUniform(0.1,400)\n        e ~ Uniform(0,0.999)\n        ω ~ Uniform(0, 2pi)\n        i ~ Sine()\n        Ω ~ Uniform(0, 2pi)\n\n        mass = system.M_sec\n\n        θ ~ Uniform(0, 2pi)\n        M = system.M\n        tp = θ_at_epoch_to_tperi(θ, 57737.0; M, e, a, i, ω, Ω) # epoch of astrometry\n    end\n)\n\nsys_final = System(\n    name=\"HD91312_rv_astrom\",\n    companions=[planet_b_final],\n    observations=[rvlike],\n    variables=@variables begin\n        M_pri ~ truncated(Normal(1.61, 0.1), lower=0.1)\n        M_sec ~ LogUniform(0.5, 1000) # MJup\n        M = M_pri + M_sec*Octofitter.mjup2msol\n\n        plx ~ gaia_plx(gaia_id=756291174721509376)\n    end\n)\n\nmodel_rv_astrom = Octofitter.LogDensityModel(sys_final,verbosity=4)\n\nchain_rv_astrom, pt = octofit_pigeons(model_rv_astrom, n_rounds=12)\nnothing # hide\n\noctoplot(model_rv_astrom, chain_rv_astrom)","category":"section"},{"location":"astrom-pma-rv/#Model-Comparison","page":"Astrometry, PMA, and RV","title":"Model Comparison","text":"Let's now display the constraints provided by each data set in a single corner plot\n\n# Create a corner plot / pair plot.\nusing CairoMakie: Makie\nusing PairPlots\noctocorner(\n    model_pma,\n    chain_pma,\n    chain_pma_astrom,\n    chain_rv_astrom,\n    chain_pma_rv_astrom,\n    small=false, \n    axis=(;\n        b_a = (;lims=(low=0, high=25))\n    ),\n    viz=(\n        PairPlots.MarginDensity(),\n        PairPlots.Scatter()\n    )\n)\n\nWe see that the constraints provided by the PMA, the astrometry, and the radial velocity data all individually overlap, and agree with the joint model constraint.  This is means that none of the datasets are in tension with each other, which might suggest an issue with the data or with the modelling assumptions (e.g. single planet). ","category":"section"},{"location":"limits/#Detection-Limits","page":"Calculate Detection Limits","title":"Detection Limits","text":"warning: Warning\nThis tutorial is a work in progress.\n\nThis guide shows how to calculate detection limits, in mass, or in photometry, as a function of orbital parameters for different combinations of data.\n\nThere are a few use cases for this:\n\nMass limit vs semi-major axis given one or more images and/or contrast curves\nMass limit vs semi-major axis given an RV non-detection\nMass limit vs semi-major axis given proper motion anomaly from the GAIA-Hipparcos Catalog of Accelerations\nAny combination of the above\n\nWe will once more use some sample data from the system HD 91312 A & B discovered by SCExAO. \n\nusing Octofitter\nusing OctofitterImages\nusing OctofitterRadialVelocity\nusing Distributions\nusing Pigeons\nusing CairoMakie\nusing PairPlots","category":"section"},{"location":"limits/#Photometry-Model","page":"Calculate Detection Limits","title":"Photometry Model","text":"We will need to decide on an atmosphere model to map image intensities into mass. Here we use the Sonora Bobcat cooling and atmosphere models which will be auto-downloaded by Octofitter:\n\nconst cooling_tracks = Octofitter.sonora_cooling_interpolator()\nconst sonora_temp_mass_L = Octofitter.sonora_photometry_interpolator(:Keck_L′)","category":"section"},{"location":"limits/#Proper-Motion-Anomaly-Data","page":"Calculate Detection Limits","title":"Proper Motion Anomaly Data","text":"We start by defining and sampling from a model that only includes proper motion anomaly data from the HGCA:\n\nB = Planet(\n    name=\"B\",\n    basis=Visual{KepOrbit},\n    observations=[],\n    variables=@variables begin\n        a ~ LogUniform(1, 65)\n        e ~ Uniform(0,0.9)\n        ω ~ Uniform(0,2pi)\n        i ~ Sine() # The Sine() distribution is defined by Octofitter\n        Ω ~ Uniform(0,pi)\n        mass = system.M_sec\n        θ ~ Uniform(0,2pi)\n        tp = θ_at_epoch_to_tperi(θ, 57423.0; M=system.M, e, a, i, ω, Ω) # epoch of GAIA measurement\n    end\n)\nHD91312_pma = System(\n    name=\"HD91312_pma\",\n    companions=[B],\n    observations=[HGCAInstantaneousObs(gaia_id=6166183842771027328)],\n    variables=@variables begin\n        M_pri ~ truncated(Normal(0.95, 0.05), lower=0.1) # Msol\n        M_sec ~ LogUniform(0.2, 65) # MJup\n        M = M_pri + M_sec*Octofitter.mjup2msol # Msol\n\n        plx ~ gaia_plx(gaia_id=6166183842771027328)\n                \n        # Priors on the center of mass proper motion\n        pmra ~ Normal(0, 1000)\n        pmdec ~ Normal(0,  1000)\n    end\n)\nmodel_pma = Octofitter.LogDensityModel(HD91312_pma)\n\nSample:\n\nusing Pigeons\nchain_pma, pt = octofit_pigeons(model_pma, n_chains=16, n_chains_variational=16, n_rounds=12);\nnothing # hide\n\nPlot the marginal mass vs. semi-major axis posterior with contours using PairPlots.jl:\n\npairplot(\n    PairPlots.Series(\n        (;\n            sma=log.(chain_pma[:B_a][:],),\n            mass=log.(chain_pma[:B_mass][:]),\n        ),\n        label=\"PMA\",\n        color=Makie.wong_colors()[1],\n    )=>(\n        PairPlots.Scatter(markersize=3,alpha=0.35),\n        PairPlots.Contour(sigmas=[1,3]),\n        PairPlots.MarginStepHist(),\n    ),\n    labels=Dict(\n        :sma=>\"log Semi-major axis [au]\",\n        :mass=>\"log Mass [Mⱼᵤₚ]\"\n    )\n)","category":"section"},{"location":"limits/#Image-Data","page":"Calculate Detection Limits","title":"Image Data","text":"using AstroImages\n# download(\n#     \"https://github.com/sefffal/Octofitter.jl/raw/main/docs/image-examples-1.fits\",\n#     \"image-examples-1.fits\"\n# )\n\n# Or multi-extension FITS (this example)\nimage = AstroImages.load(\"image-examples-1.fits\").*2e-7 # units of contrast\nimg_dat_table = Table([\n     (image=AstroImages.recenter(image), platescale=4.0, epoch=57423.6),\n])\n\nimage_data = ImageObs(\n    img_dat_table,\n    name=\"imgdat-sim\",\n    variables=@variables begin\n        # Planet flux in image units -- could be contrast, mags, Jy, or arb. as long as it's consistent with the units of the data you provide\n        flux = planet.L\n        # The following are optional parameters for marginalizing over instrument systematics:\n        # Platescale uncertainty multiplier [could use: platescale ~ truncated(Normal(1, 0.01), lower=0)]\n        platescale = 1.0\n        # North angle offset in radians [could use: northangle ~ Normal(0, deg2rad(1))]\n        northangle = 0.0\n    end\n)\n\nB = Planet(\n    name=\"B\",\n    basis=Visual{KepOrbit},\n    observations=[image_data],\n    variables=@variables begin\n        a ~ LogUniform(1, 65)\n        e ~ Uniform(0,0.9)\n        ω ~ Uniform(0,2pi)\n        i ~ Sine() # The Sine() distribution is defined by Octofitter\n        Ω ~ Uniform(0,pi)\n        mass = system.M_sec\n\n        # Calculate planet temperature from cooling track and planet mass variable\n        tempK = $cooling_tracks(system.age, mass)\n        # Calculate absolute magnitude\n        abs_mag_L = $sonora_temp_mass_L(tempK, mass)\n        # Deal with out-of-grid values by clamping to grid max and min\n        abs_mal_L′ = if isfinite(abs_mag_L)\n            abs_mag_L\n        elseif mass > 10 \n            8.2 # jump to absurdly bright\n        else\n            16.7 # jump to absurdly dim\n        end\n        # Calculate relative magnitude\n        rel_mag_L = abs_mal_L′ - system.rel_mag + 5log10(1000/system.plx)\n        # Convert to contrast (same units as image)\n        L = 10.0^(rel_mag_L/-2.5)\n\n        θ ~ Uniform(0,2pi)\n        tp = θ_at_epoch_to_tperi(θ, 57423.6; M=system.M, e, a, i, ω, Ω)\n    end\n)\n\nHD91312_img = System(\n    name=\"HD91312_img\",\n    companions=[B],\n    observations=[],\n    variables=@variables begin\n        # age ~ truncated(Normal(40, 15),lower=0, upper=200)\n        age = 10\n        M_pri ~ truncated(Normal(0.95, 0.05), lower=0.1) # Msol\n        # Mass of secondary\n        # Make sure to pick only a mass range that is covered by your models\n        M_sec ~ LogUniform(0.55, 65) # MJup\n        M = M_pri + M_sec*Octofitter.mjup2msol # Msol\n        plx ~ gaia_plx(gaia_id=6166183842771027328)\n        # Priors on the center of mass proper motion\n        # pmra ~ Normal(0, 1000)\n        # pmdec ~ Normal(0,  1000)\n        rel_mag = 5.65\n    end\n)\nmodel_img = Octofitter.LogDensityModel(HD91312_img)\n\nusing Pigeons\nchain_img, pt = octofit_pigeons(model_img, n_chains=5, n_chains_variational=5, n_rounds=7)\n\nPlot mass vs. semi-major axis posterior:\n\nvis_layers = (\n    PairPlots.Contour(sigmas=[1,3]),\n    PairPlots.MarginStepHist(),\n)\npairplot(\n    PairPlots.Series(\n        (;\n            sma=log.(chain_pma[:B_a][:],),\n            mass=log.(chain_pma[:B_mass][:]),\n        ),\n        label=\"PMA\",\n        color=Makie.wong_colors()[1],\n    )=>vis_layers,\n    PairPlots.Series(\n        (;\n            sma=log.(chain_img[:B_a][:],),\n            mass=log.(chain_img[:B_mass][:]),\n        ),\n        label=\"IMG\",\n        color=Makie.wong_colors()[2],\n    )=>vis_layers,\n    labels=Dict(\n        :sma=>\"log Semi-major axis [au]\",\n        :mass=>\"log Mass [Mⱼᵤₚ]\"\n    )\n)","category":"section"},{"location":"limits/#Image-and-PMA-data","page":"Calculate Detection Limits","title":"Image and PMA data","text":"B = Planet(\n    name=\"B\",\n    basis=Visual{KepOrbit},\n    observations=[image_data],\n    variables=@variables begin\n        a ~ LogUniform(1, 65)\n        e ~ Uniform(0,0.9)\n        ω ~ Uniform(0,2pi)\n        i ~ Sine() # The Sine() distribution is defined by Octofitter\n        Ω ~ Uniform(0,pi)\n        mass = system.M_sec\n\n        # Calculate planet temperature from cooling track and planet mass variable\n        tempK = $cooling_tracks(system.age, mass)\n        # Calculate absolute magnitude\n        abs_mag_L = $sonora_temp_mass_L(tempK, mass)\n        # Deal with out-of-grid values by clamping to grid max and min\n        abs_mal_L′ = if isfinite(abs_mag_L)\n            abs_mag_L\n        elseif mass > 10 \n            8.2 # jump to absurdly bright\n        else\n            16.7 # jump to absurdly dim\n        end\n        # Calculate relative magnitude\n        rel_mag_L = abs_mal_L′ - system.rel_mag + 5log10(1000/system.plx)\n        # Convert to contrast (same units as image)\n        L = 10.0^(rel_mag_L/-2.5)\n\n        # L ~ Uniform(0,1)\n\n        θ ~ Uniform(0,2pi)\n        tp = θ_at_epoch_to_tperi(θ, 57423.6; M=system.M, e, a, i, ω, Ω)\n    end\n)\n\nHD91312_both = System(\n    name=\"HD91312_both\",\n    companions=[B],\n    observations=[HGCAInstantaneousObs(gaia_id=6166183842771027328)],\n    variables=@variables begin\n        # age ~ truncated(Normal(40, 15),lower=0, upper=200)\n        age = 10\n        M_pri ~ truncated(Normal(0.95, 0.05), lower=0.1) # Msol\n        # Mass of secondary\n        # Make sure to pick only a mass range that is covered by your models\n        M_sec ~ LogUniform(0.55, 65) # MJup\n        M = M_pri + M_sec*Octofitter.mjup2msol # Msol\n        plx ~ gaia_plx(gaia_id=6166183842771027328)\n        # Priors on the center of mass proper motion\n        pmra ~ Normal(0, 1000)\n        pmdec ~ Normal(0,  1000)\n        rel_mag = 5.65\n    end\n)\nmodel_both = Octofitter.LogDensityModel(HD91312_both)\n\nusing Pigeons\nchain_both, pt = octofit_pigeons(model_both,n_chains=5,n_chains_variational=5,n_rounds=10)\n\nCompare all three posteriors to see limits:\n\nvis_layers = (\n    PairPlots.Contour(sigmas=[1,3]),\n    PairPlots.MarginStepHist(),\n)\npairplot(\n    PairPlots.Series(\n        (;\n            sma=log.(chain_pma[:B_a][:],),\n            mass=log.(chain_pma[:B_mass][:]),\n        ),\n        label=\"PMA\",\n        color=Makie.wong_colors()[1],\n    )=>vis_layers,\n    PairPlots.Series(\n        (;\n            sma=log.(chain_img[:B_a][:],),\n            mass=log.(chain_img[:B_mass][:]),\n        ),\n        label=\"IMG\",\n        color=Makie.wong_colors()[2],\n    )=>vis_layers,\n        PairPlots.Series(\n        (;\n            sma=log.(chain_both[:B_a][:],),\n            mass=log.(chain_both[:B_mass][:]),\n        ),\n        label=\"IMG + PMA\",\n        color=Makie.wong_colors()[3],\n    )=>vis_layers,\n    labels=Dict(\n        :sma=>\"log₂ Semi-major axis [au]\",\n        :mass=>\"log₂ Mass [Mⱼᵤₚ]\"\n    )\n)","category":"section"},{"location":"loading-saving/#loading-saving","page":"Loading and Saving Data","title":"Loading and Saving Data","text":"","category":"section"},{"location":"loading-saving/#Loading-Observations","page":"Loading and Saving Data","title":"Loading Observations","text":"For models with lots of data points, it becomes cumbersome to write all your data in your model script. Intead, you can load your observations (astrometry, proper motion anomaly, radial velocity, etc) from any Tables.jl compatible source. These could include a TypedTable, a DataFrame, a CSV file, an Arrow file, Excel, etc.\n\nHere is an example of loading data from a CSV file:\n\nusing CSV\nastrom = PlanetRelAstromObs(CSV.File(\"astrom.csv\"))\n# Or equivalently\nastrom = CSV.read(\"astrom.csv\", PlanetRelAstromObs)\n\nThe list of columns necessary for each type of observation are listed in the API documentation for e.g. PlanetRelAstromObs.\n\nThis works for other observation types too:\n\npma = CSV.read(\"pma.csv\", PropMotionAnom)\n\nThis pattern also allows you to load data directly from remote databases using any Tables.jl compatible library.\n\nOnce loaded, you can access the underlying table using e.g. astrom.table.","category":"section"},{"location":"loading-saving/#Saving-Chains","page":"Loading and Saving Data","title":"Saving Chains","text":"There are two ways you can save chains for later analysis. The first is a built in function that stores the chain and metadata into a FITS table. The second is converting the chain to a Table and saving it using any Tables.jl compatible package (CSV, Arrow, SQL, etc.)","category":"section"},{"location":"loading-saving/#Example:-Saving-chains-and-metadata-to-FITS-Table","page":"Loading and Saving Data","title":"Example: Saving chains and metadata to FITS Table","text":"The default, and recommended way to save your chains is to a FITS table:\n\nOctofitter.savechain(\"mychain.fits\", chain)\n\nchain = Octofitter.loadchain(fname)","category":"section"},{"location":"loading-saving/#Example:-Saving-chains-to-Orbitize-format","page":"Loading and Saving Data","title":"Example: Saving chains to Orbitize format","text":"For compatbility purposes, orbit posteriors can be exported and loaded from the Orbitize! HDF5 format. This only works for basic two-object orbits. FITS format (above) should be preferred.\n\nOctofitter.savehdf5(\"mychain.h5\", chain)\n\nchain = Octofitter.loadhdf5(fname)","category":"section"},{"location":"loading-saving/#Example:-Saving-to-CSV","page":"Loading and Saving Data","title":"Example: Saving to CSV","text":"Converting chain to a TypedTables.jl Table (re-exported by this package)\n\ntbl = Table(chain)\n\nConverting chain to a DataFrames.jl DataFrame:\n\ndf = DataFrame(Chain)\n\nSaving chains:\n\nusing CSV\nCSV.write(\"chains.csv\", tbl) # or df\n\nusing Arrow\nArrow.write(\"chains.arrow\", tbl) # or df\n\nYou can also convert a chain object to general Array which you can save in any format you wish:\n\narr = Array(chains)","category":"section"},{"location":"loading-saving/#Saving-and-Restoring-Models","page":"Loading and Saving Data","title":"Saving and Restoring Models","text":"We recommend that you save each model as a script that generates the model, e.g. in a julia file called model-systemname.jl. \n\nFor convenience, it is also possible to save and restore the full model. This is not garuanteed to work across Julia versions or between computers, but is very fast for interactive work etc.\n\nSaving model:\n\nusing Serialization\nserialize(\"mymodel-systemname.jls\", model)\n\nRestoring model:\n\nusing Octofitter # must load all previously used dependencies\nusing Serialization \nmodel = deserialize(\"mymodel-systemname.jls\")","category":"section"},{"location":"eccentric-or-circular/#Marginalizing-over-Circular-or-Eccentric-Hypotheses","page":"Circular or Eccentric? Model Comparison","title":"Marginalizing over Circular or Eccentric Hypotheses","text":"This tutorial demonstrates how to simultaneously model both circular and eccentric orbit possibilities in a single fit, allowing you to rigorously evaluate whether eccentricity is necessary to explain your data.","category":"section"},{"location":"eccentric-or-circular/#Motivation","page":"Circular or Eccentric? Model Comparison","title":"Motivation","text":"When fitting orbits, a common question arises: Is the orbit circular, or is eccentricity required by the data?\n\nA naive approach might be to simply fit with a prior like e ~ Uniform(0, 0.99) and check if the posterior excludes zero. However, this approach has a subtle problem: it doesn't properly account for the different model complexities. An eccentric orbit has more free parameters (eccentricity e and argument of periastron ω) compared to a circular orbit where these parameters are undefined or fixed.\n\nA more rigorous approach is to marginalize over both hypotheses simultaneously using a discrete indicator variable. This allows us to:\n\nLet the data determine which hypothesis is preferred\nCalculate a Bayes factor comparing the two models\nAvoid artificially penalizing the circular model by forcing it to explore unnecessary parameter space","category":"section"},{"location":"eccentric-or-circular/#The-Spike-and-Slab-Prior","page":"Circular or Eccentric? Model Comparison","title":"The Spike-and-Slab Prior","text":"The technique we'll use is called a spike-and-slab prior. The idea is simple but powerful:\n\nThe \"spike\" represents the circular orbit hypothesis (e = 0)\nThe \"slab\" represents the eccentric orbit hypothesis (e > 0)\nWe use a discrete indicator variable to switch between them\n\nMathematically, we can write:\n\neccentric ~ Bernoulli(0.5)        # 50% prior probability for each hypothesis\ne′ ~ Uniform(0.0, 0.99)           # If eccentric, what is e?\ne = eccentric × e′                 # Spike at zero when eccentric=0, slab when eccentric=1\n\nWhen eccentric = 0, we get e = 0 (the spike). When eccentric = 1, we get e = e′ (the slab, uniformly distributed).\n\nThis prior structure naturally encodes both hypotheses and allows the posterior probability P(eccentric = 1 | data) to tell us which model the data prefer.","category":"section"},{"location":"eccentric-or-circular/#Why-This-Differs-from-Just-Using-a-Uniform-Prior","page":"Circular or Eccentric? Model Comparison","title":"Why This Differs from Just Using a Uniform Prior","text":"You might wonder: why not just use e ~ Uniform(0, 0.99) and see if the posterior includes zero?\n\nThe key difference is in model comparison. With a simple uniform prior:\n\nYou're always fitting an eccentric model, even when e ≈ 0\nThe parameter ω is being fit even when it's physically meaningless (for circular orbits)\nYou can't as easily calculate a Bayes factor between circular and eccentric hypotheses\n\nWith the spike-and-slab approach:\n\nWhen eccentric = 0, the model actually becomes circular with fewer degrees of freedom\nThe posterior mean of the eccentric parameter directly gives you the probability of the eccentric hypothesis\nYou can calculate a proper Bayes factor to quantify the evidence","category":"section"},{"location":"eccentric-or-circular/#Setting-Up-the-Model","page":"Circular or Eccentric? Model Comparison","title":"Setting Up the Model","text":"Let's start by loading the necessary packages:\n\nusing Octofitter, Distributions\nusing CairoMakie, PairPlots\n\nWe'll use the same synthetic astrometry data from the basic tutorial:\n\nastrom_dat = Table(;\n    epoch = [50000, 50120, 50240, 50360, 50480, 50600, 50720, 50840,], # MJD (days)\n    ra    = [-505.764, -502.57, -498.209, -492.678, -485.977, -478.11, -469.08, -458.896,], # mas\n    dec   = [-66.9298, -37.4722, -7.92755, 21.6356, 51.1472, 80.5359, 109.729, 138.651,], # mas\n    σ_ra  = [10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0,], # mas\n    σ_dec = [10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0,], # mas\n    cor   = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,]\n)\nastrom_obs = PlanetRelAstromObs(astrom_dat, name=\"relastrom\")\n\nNow we define our planet model with the spike-and-slab prior on eccentricity:\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[astrom_obs],\n    variables=@variables begin\n        M = system.M\n        plx = system.plx\n        a ~ Uniform(0, 100)\n\n        # Spike-and-slab prior for eccentricity\n        eccentric ~ Bernoulli(0.5)      # 50% prior odds for eccentric vs circular\n        e′ ~ Uniform(0.0, 0.99)         # If eccentric, what eccentricity?\n        e = eccentric * e′              # Spike at 0 when eccentric=0, slab when eccentric=1\n\n\n        # ω is also multiplied by eccentric because it's undefined for circular orbits\n        ω′ ~ UniformCircular()\n        ω = eccentric * ω′              # When e=0, ω has no physical meaning\n\n        i ~ Sine()\n        Ω ~ UniformCircular()\n        θ ~ UniformCircular()\n        tp = θ_at_epoch_to_tperi(θ, 50420; M, e, a, i, ω, Ω)\n    end\n)\nnothing # hide\n\nnote: Why multiply ω by the indicator variable?\nWhen an orbit is circular (e = 0), the argument of periastron ω becomes undefined—there is no periastron! By multiplying ω by the eccentric indicator, we ensure that when the model is circular, ω is automatically set to zero and doesn't waste computational effort exploring meaningless values. \n\nNow we complete the system definition:\n\nsys = System(\n    name=\"CircularOrEccentric\",\n    companions=[planet_b],\n    observations=[],\n    variables=@variables begin\n        M ~ truncated(Normal(1.2, 0.1), lower=0.1)\n        plx ~ truncated(Normal(50.0, 0.02), lower=0.1)\n    end\n)\n\nmodel = Octofitter.LogDensityModel(sys)","category":"section"},{"location":"eccentric-or-circular/#Sampling-with-Pigeons","page":"Circular or Eccentric? Model Comparison","title":"Sampling with Pigeons","text":"warning: Important: Use Pigeons for Discrete Variables\nThe default HMC sampler (octofit) is not compatible with discrete variables like our eccentric indicator. You must use the Pigeons sampler via octofit_pigeons for models with discrete parameters.Make sure you have Pigeons installed:using Pkg\nPkg.add(\"Pigeons\")\n\nLet's sample from our model using Pigeons:\n\nusing Pigeons\nchain, pt = octofit_pigeons(model, n_rounds=10)\n\nThe Pigeons sampler with the default SliceSampler can explore both discrete and continuous parameter spaces. It automatically handles the switching between circular and eccentric hypotheses.","category":"section"},{"location":"eccentric-or-circular/#Interpreting-the-Results","page":"Circular or Eccentric? Model Comparison","title":"Interpreting the Results","text":"Let's look at the posterior distribution of our indicator variable:\n\nusing Statistics\nmean_eccentric = mean(chain[:b_eccentric][:])\nprintln(\"Posterior probability of eccentric orbit: \", round(mean_eccentric, digits=3))\n\nThe mean of the eccentric indicator variable directly gives us the posterior probability that the orbit is eccentric (given the data and our priors).","category":"section"},{"location":"eccentric-or-circular/#Calculating-the-Bayes-Factor","page":"Circular or Eccentric? Model Comparison","title":"Calculating the Bayes Factor","text":"One of the most powerful aspects of this approach is that we can calculate a Bayes factor comparing the two hypotheses. The Bayes factor is defined as:\n\ntextBF = fracP(textdata  texteccentric model)P(textdata  textcircular model)\n\nIt turns out that for a spike-and-slab model with equal prior odds (Bernoulli(0.5)), the Bayes factor can be calculated directly from the posterior mean of the indicator variable:\n\ntextBF = fracbarI1 - barI\n\nwhere barI is the posterior mean of the eccentric indicator.\n\nnote: Mathematical Intuition\nWhy does this work? By Bayes' theorem, the posterior odds equal the prior odds times the Bayes factor:fracP(texteccentric  textdata)P(textcircular  textdata) = fracP(texteccentric)P(textcircular) times textBFSince we used Bernoulli(0.5), our prior odds are 1:1. Therefore, the posterior odds are the Bayes factor. The posterior mean barI gives us P(texteccentric  textdata), so 1 - barI gives us P(textcircular  textdata), and their ratio is the Bayes factor.\n\nLet's calculate it:\n\nbayes_factor = mean_eccentric / (1 - mean_eccentric)\nprintln(\"Bayes factor (eccentric vs circular): \", round(bayes_factor, digits=2))\nprintln(\"Bayes factor (circular vs eccentric): \", round(1/bayes_factor, digits=2))\n\nInterpreting Bayes Factors:\n\nBF > 10: Strong evidence for eccentric orbit\nBF = 3-10: Moderate evidence for eccentric orbit\nBF = 1/3-3: Data are ambiguous\nBF < 1/10: Strong evidence for circular orbit\n\nIn this case, you can interpret the Bayes factor to determine whether eccentricity is justified by your data.","category":"section"},{"location":"eccentric-or-circular/#Visualizing-Results","page":"Circular or Eccentric? Model Comparison","title":"Visualizing Results","text":"","category":"section"},{"location":"eccentric-or-circular/#All-Samples","page":"Circular or Eccentric? Model Comparison","title":"All Samples","text":"Let's first plot all posterior samples together:\n\noctoplot(model, chain)\n\nThis plot includes both circular (when eccentric = 0) and eccentric (when eccentric = 1) samples, which is why you might see orbits with a range of eccentricities.","category":"section"},{"location":"eccentric-or-circular/#Eccentric-Samples-Only","page":"Circular or Eccentric? Model Comparison","title":"Eccentric Samples Only","text":"We can subset the chain to show only the eccentric orbit samples:\n\nchain_eccentric = chain[chain[:b_eccentric][:] .> 0]\nprintln(\"Number of eccentric samples: \", length(chain_eccentric))\noctoplot(model, chain_eccentric)","category":"section"},{"location":"eccentric-or-circular/#Circular-Samples-Only","page":"Circular or Eccentric? Model Comparison","title":"Circular Samples Only","text":"Similarly, we can plot only the circular orbit samples:\n\nchain_circular = chain[chain[:b_eccentric][:] .== 0]\nprintln(\"Number of circular samples: \", length(chain_circular))\noctoplot(model, chain_circular)\n\nThese subsetted plots help you visualize what each hypothesis predicts for your data.\n\ntip: Understanding the Split\nThe ratio of eccentric to circular samples in your chain reflects the posterior probability of each hypothesis. If you have roughly equal numbers, the data don't strongly prefer one model over the other. If one dominates, that tells you the data have a clear preference.","category":"section"},{"location":"eccentric-or-circular/#Corner-Plots","page":"Circular or Eccentric? Model Comparison","title":"Corner Plots","text":"Let's examine the parameter correlations with a corner plot:\n\noctocorner(model, chain, small=true)\n\nNotice how the eccentricity parameter b_e has a spike at zero (circular orbits) and a continuous distribution above zero (eccentric orbits). This is the \"spike and slab\" structure!\n\nYou can also compare the eccentric and circular subsets:\n\noctocorner(model, chain_eccentric, chain_circular, small=true)","category":"section"},{"location":"eccentric-or-circular/#Generallization","page":"Circular or Eccentric? Model Comparison","title":"Generallization","text":"Generalization: This technique can be extended to other discrete model choices, such as:\nCoplanar vs non-coplanar multi-planet systems\nIncluding vs excluding a Gaussian process for stellar activity\nDifferent numbers of planets","category":"section"},{"location":"rv-multi-planet/#fit-rv-multi","page":"Multiple Planets","title":"Multi-Planet RV Fits","text":"This tutorial shows how to perform a multi-planet RV fit, and compare the bayesian evidence between the two models.\n\nusing Octofitter\nusing OctofitterRadialVelocity\nusing CairoMakie\nusing PairPlots\nusing Distributions\nusing PlanetOrbits\n\nTo begin, we create simulated data. We imagine that we have two different instruments.\n\nusing Random\nRandom.seed!(1)\n\norb_template_1 = orbit(a = 1.0,e = 0.05,ω = 1π/4,M = 1.0,tp =58800)\nmass_1 = 0.25*1e-3\norb_template_2 = orbit(a = 5.0,e = 0.4,ω = 1π/4,M = 1.0,tp =59800)\nmass_2 = 1.0*1e-3\n\nepochs = (58400:150:69400) .+ 10 .* randn.()\nrv = radvel.(orb_template_1, epochs, mass_1) .+ radvel.(orb_template_2, epochs, mass_2)\nrvlike1 = MarginalizedStarAbsoluteRVObs(\n    Table(epoch=epochs, rv=rv .+ 4 .* randn.(), σ_rv=[4 .* abs.(randn.()) .+ 1 for _ in 1:length(epochs)]),\n    name=\"DATA 1\",\n    variables=@variables begin\n        jitter ~ LogUniform(0.1, 100) # m/s\n    end\n)\n\nepochs = (65400:100:71400) .+ 10 .* randn.()\nrv = radvel.(orb_template_1, epochs, mass_1) .+ radvel.(orb_template_2, epochs, mass_2)\nrvlike2 = MarginalizedStarAbsoluteRVObs(\n    Table(epoch=epochs, rv=rv .+ 2 .* randn.() .+ 7, σ_rv=[2 .* abs.(randn.()) .+ 1 for _ in 1:length(epochs)]),\n    name=\"DATA 2\",\n    variables=@variables begin\n        jitter ~ LogUniform(0.1, 100) # m/s\n    end\n)\n\nfig = Figure()\nax = Axis(\n    fig[1,1],\n    xlabel=\"epoch [mjd]\",\n    ylabel=\"rv [m/s]\"\n)\nMakie.scatter!(ax, rvlike1.table.epoch, rvlike1.table.rv)\nMakie.errorbars!(ax, rvlike1.table.epoch, rvlike1.table.rv, rvlike1.table.σ_rv)\nMakie.scatter!(ax, rvlike2.table.epoch, rvlike2.table.rv)\nMakie.errorbars!(ax, rvlike2.table.epoch, rvlike2.table.rv, rvlike2.table.σ_rv)\nfig","category":"section"},{"location":"rv-multi-planet/#Two-Planet-Model","page":"Multiple Planets","title":"Two Planet Model","text":"planet_b = Planet(\n    name=\"b\",\n    basis=RadialVelocityOrbit,\n    observations=[],\n    variables=@variables begin\n        M_pri = system.M_pri\n        M_b = system.M_b\n        M_c = system.M_c\n        M = M_pri + (M_b + M_c) * Octofitter.mjup2msol\n        e ~ Uniform(0,0.999999)\n        mass = M_b\n        ω ~ Uniform(0,2pi)\n        τ ~ Uniform(0,1.0)\n\n        P_kep_yrs ~ Uniform(0, 100)\n        a = ∛(M * P_kep_yrs^2)\n        tp = τ*P_kep_yrs*365.25 + 58400\n    end\n)\n\nplanet_c = Planet(\n    name=\"c\",\n    basis=RadialVelocityOrbit,\n    observations=[],\n    variables=@variables begin\n        M_pri = system.M_pri\n        M_c = system.M_c\n        M = M_pri + M_c * Octofitter.mjup2msol\n        e ~ Uniform(0,0.999999)\n        mass = M_c\n        ω ~ Uniform(0,2pi)\n        τ ~ Uniform(0,1.0)\n\n        P_kep_yrs ~ Uniform(0, 100)\n        a = ∛(M * P_kep_yrs^2)\n        tp = τ*P_kep_yrs*365.25 + 58400\n    end\n)\n\nsim_2p = System(\n    name=\"sim_2p\",\n    companions=[planet_b, planet_c],\n    observations=[rvlike1, rvlike2],\n    variables=@variables begin\n        M_pri = 1.0\n        M_b ~ Uniform(0, 10)\n        M_c ~ Uniform(0, 10)\n    end\n)\n\nmodel_2p = Octofitter.LogDensityModel(sim_2p)\n\nSample from the posterior\n\nusing Pigeons\nresults_2p, pt_2p = octofit_pigeons(model_2p, n_rounds=10)\n\nPlot RV curve, phase folded curve, and binned residuals:\n\nOctofitter.rvpostplot(model_2p, results_2p)","category":"section"},{"location":"rv-multi-planet/#One-Planet-Model","page":"Multiple Planets","title":"One Planet Model","text":"We now create a new system object that only includes one planet (we dropped c, in this case).\n\nsim_1p = System(\n    name=\"sim_1p\",\n    companions=[planet_b],\n    observations=[rvlike1, rvlike2],\n    variables=@variables begin\n        M_pri = 1.0\n        M_b ~ Uniform(0, 10)\n        M_c = 0.0\n    end\n)\n\nmodel_1p = Octofitter.LogDensityModel(sim_1p)\n\nSample from the posterior\n\nusing Pigeons\nresults_1p, pt_1p = octofit_pigeons(model_1p, n_rounds=10)\n\nPlot RV curve, phase folded curve, and binned residuals:\n\nOctofitter.rvpostplot(model_1p, results_1p)","category":"section"},{"location":"rv-multi-planet/#Model-Comparison:-Bayesian-Evidence","page":"Multiple Planets","title":"Model Comparison: Bayesian Evidence","text":"Octofitter with Pigeons directly calculates the (natural) log Bayesian evidence using the \"stepping stone\" method. This should be more reliable than even nested sampling, and certainly more reliable than approximate methods like the BIC/WAIC etc.\n\nZ1 = stepping_stone(pt_1p)\nZ2 = stepping_stone(pt_2p)\n\nln_BF₁₀ = Z2-Z1\n\nHere is a standard guideline you can use to interpret the evidence:\n\nLog Bayes Factor ln(BF₁₀) Interpretation\n> 3.00 Extreme evidence for H_A\n1.61 - 3.00 Very strong evidence for H_A\n1.10 - 1.61 Strong evidence for H_A\n0.69 - 1.10 Moderate evidence for H_A\n0 - 0.69 Anecdotal evidence for H_A\n0 No evidence\n-0.69 - 0 Anecdotal evidence for H_B\n-1.10 - -0.69 Moderate evidence for H_B\n-1.61 - -1.10 Strong evidence for H_B\n-3.00 - -1.61 Very strong evidence for H_B\n< -3.00 Extreme evidence for H_B\n\nAs you can see, the evidence for there being two planets is \"extreme\" in this case. Try adjusting the masses of the two planets and see how this changes!","category":"section"},{"location":"rv-multi-planet/#Parameterizations","page":"Multiple Planets","title":"Parameterizations","text":"When using the evidence for model comparisons, a model with more specific priors will have more evidence than an quivalent model with broad priors.\n\nIn our two planet model above, we made two exactly equivalent planets. If you inspect the chains, you may notice that the two planets often flip back and forth – sometimes b has the longer period, and sometimes c does. \n\nFor example, here is a histogram of the period of planet b:\n\nhist(vec(results_2p[:b_P_kep_yrs]), bins=100)\n\nWe can refine the two planet model a bit by adjusting the priors such that planet c always has a longer period than planet b.\n\nThis will make analysis a little more straightforward, but crucially it will also increase the evidence of this model, by approximately halving the prior volume–-thus making a more specific prediction.\n\nThere are several ways we could do this. Here, we add a \"nominal period\" variable and reparameterize the two planets as ratios of this nominal period.\n\nplanet_b_v2 = Planet(\n    name=\"b\",\n    basis=RadialVelocityOrbit,\n    observations=[],\n    variables=@variables begin\n        M_pri = system.M_pri\n        M_b = system.M_b\n        M_c = system.M_c\n        M = M_pri + (M_b + M_c) * Octofitter.mjup2msol\n        e ~ Uniform(0,0.999999)\n        mass = M_b\n        ω ~ Uniform(0,2pi)\n        τ ~ Uniform(0,1.0)\n\n        P_yrs_nom = system.P_yrs_nom\n        P_ratio_b = system.P_ratio_b\n        P_kep_yrs = P_yrs_nom * P_ratio_b\n        a = ∛(M * P_kep_yrs^2)\n        tp = τ*P_kep_yrs*365.25 + 58400\n    end\n)\n\nplanet_c_v2 = Planet(\n    name=\"c\",\n    basis=RadialVelocityOrbit,\n    observations=[],\n    variables=@variables begin\n        M_pri = system.M_pri\n        M_c = system.M_c\n        M = M_pri + M_c * Octofitter.mjup2msol\n        e ~ Uniform(0,0.999999)\n        mass = M_c\n        ω ~ Uniform(0,2pi)\n        τ ~ Uniform(0,1.0)\n\n        P_yrs_nom = system.P_yrs_nom\n        P_ratio_c = system.P_ratio_c\n        P_kep_yrs = P_yrs_nom * P_ratio_c\n        a = ∛(M * P_kep_yrs^2)\n        tp = τ*P_kep_yrs*365.25 + 58400\n    end\n)\n\n\nsim_2p_v2 = System(\n    name=\"sim_2p_v2\",\n    companions=[planet_b_v2, planet_c_v2],\n    observations=[rvlike1, rvlike2],\n    variables=@variables begin\n        M_pri = 1.0\n        M_b ~ Uniform(0, 10)\n        M_c ~ Uniform(0, 10)\n        \n        P_yrs_nom ~ Uniform(0, 100)\n        P_ratio_b ~ Uniform(0, 0.5)\n        P_ratio_c ~ Uniform(0.5, 1)\n    end\n)\n\nmodel_2p_v2 = Octofitter.LogDensityModel(sim_2p_v2)\n\nSample from the posterior\n\nusing Pigeons\nresults_2p_v2, pt_2p_v2 = octofit_pigeons(model_2p_v2, n_rounds=10)\n\nThe planet with the wider orbit is now consistently plotted in the bottom panel (meaning that planet b and c are no longer trading back and forth):\n\nOctofitter.rvpostplot(model_2p_v2, results_2p_v2)\n\nIf we look again at the log-evidence, we see that this parameterization (Z3) is even more favoured. This is because this small change in parameterization makes considerably \n\nZ1 = stepping_stone(pt_1p)\nZ2 = stepping_stone(pt_2p)\nZ3 = stepping_stone(pt_2p_v2)\n\nZ1, Z2, Z3\n\nAs a final treat, let's animate the orbit plots. All the previous images were visualizing a single posterior draw. In this animation, we'll loop over many different samples:\n\nOctofitter.rvpostplot_animated(model_2p_v2, results_2p_v2)\n\n<video src=\"rv-posterior.mp4\" autoplay loop width=300 height=300>","category":"section"},{"location":"rv-multi-planet/#Note-about-the-evidence-ratio","page":"Multiple Planets","title":"Note about the evidence ratio","text":"The pigeons method returns the log evidence ratio. If the priors are properly normalized, this is equal to the log evidence.\n\nIn other cases (e.g. if using ObsPriorAstromONeil2019 or UniformCircular) you may need to calculate the log_Z0 term yourself. This can be done as follows:\n\nprior_model = Octofitter.LogDensityModel(Octofitter.prior_only_model(model_1p.system, exclude_all=true))\n_, pt_prior = octofit_pigeons(prior_model, n_rounds=10) # should be very quick!\nlog_Z0 = stepping_stone(pt_prior)\n\nSubtract this from the stepping stone value to get the true evidence:\n\nlog_Z1_over_Z0 = stepping_stone(pt_1p)\nlog_Z1 = log_Z1_over_Z0 - log_Z0","category":"section"},{"location":"custom-likelihood/#Adding-a-Custom-Observation-Type","page":"Custom Likelihoods","title":"Adding a Custom Observation Type","text":"It's fairly straightforward to add support for a new kind of observation to Octofitter.jl You can also follow the same workflow if you want to handle an existing kind of observation in a new way—say, tweaking a calculation, or using Gaussian processes to better model noise in radial velocity data.\n\nAll the existing observation types are listed in  src/likelihoods and can be used as examples.\n\nNote that these examples won't run if you copy and paste them, you'll need to modify them to suite your purposes.","category":"section"},{"location":"custom-likelihood/#Creating-an-Observation-type","page":"Custom Likelihoods","title":"Creating an Observation type","text":"The first step is to create a new data type to hold the observations.\n\n\"\"\"\n    data = Table(\n        (epoch=50000, my_measurement=1.2, σ_measurement=0.1),\n        (epoch=50100, my_measurement=1.5, σ_measurement=0.1),\n    )\n    MyObs(\n        data,\n        name=\"MY_INSTRUMENT\",\n        variables=@variables begin\n            my_parameter ~ Normal(0, 1)\n        end\n    )\n\nA custom observation type for my specific type of data.\n\"\"\"\nstruct MyObs{TTable<:Table} <: AbstractObs\n    table::TTable\n    name::String\n    priors::Priors\n    derived::Derived\n    function MyObs(\n            observations;\n            name=\"MY_OBS\",\n            variables::Tuple{Priors,Derived}=(@variables begin;end)\n        )\n        (priors,derived)=variables\n        table = Table(observations)\n        if !equal_length_cols(table)\n            error(\"The columns in the input data do not all have the same length\")\n        end\n        # Add any column validation here, e.g.:\n        # expected_cols = (:epoch, :my_measurement, :σ_measurement)\n        # if !issubset(expected_cols, Tables.columnnames(table))\n        #     error(\"Expected columns $expected_cols\")\n        # end\n        return new{typeof(table)}(table, name, priors, derived)\n    end\nend\n\n# Backwards compatibility alias (optional but recommended)\nconst MyLikelihood = MyObs\n\nexport MyObs, MyLikelihood\n\nHere we create a struct MyObs that is a subtype of AbstractObs (previously called AbstractLikelihood). The observation type includes:\n\ntable: The observational data as a TypedTables.Table\nname: Used for variable naming in MCMC chains\npriors and derived: Observation-specific variables from the @variables block\n\nTry to follow the advice in the Julia Manual's performance tips section to ensure you've created a fully \"concrete\" type. This won't affect correctness, but will be important for performance down the road.","category":"section"},{"location":"custom-likelihood/#Create-likelihood-functions","page":"Custom Likelihoods","title":"Create likelihood functions","text":"Now, create a method that extends Octofitter.ln_obs for your custom observation type.\n\nIf the observations are specific to a planet (like astrometry, where the data is attached to a planet instead of the system) then the method signature should use PlanetObservationContext:\n\n# MyObs: attached to a planet\nfunction Octofitter.ln_obs(obs::MyObs, ctx::PlanetObservationContext)\n    # Destructure the context to access parameters\n    (; θ_system, θ_planet, θ_obs, orbits, orbit_solutions, i_planet, orbit_solutions_i_epoch_start) = ctx\n\n    T = Octofitter._system_number_type(θ_system)\n    ll = zero(T)\n\n    # Access your data from the table\n    for i_epoch in eachindex(obs.table.epoch)\n        epoch = obs.table.epoch[i_epoch]\n        measurement = obs.table.my_measurement[i_epoch]\n        σ_measurement = obs.table.σ_measurement[i_epoch]\n\n        # Access planet variables\n        # θ_planet.e, θ_planet.a, etc.\n\n        # Access observation-specific variables\n        my_param = θ_obs.my_parameter\n\n        # Method 1: Use pre-solved orbit solutions (efficient!)\n        # Get the pre-solved orbit solution for this planet at this epoch\n        sol = orbit_solutions[i_planet][i_epoch + orbit_solutions_i_epoch_start]\n\n        # Extract position from pre-solved solution\n        predicted = raoff(sol) + my_param  # example calculation using pre-solved position\n\n        # Method 2: Alternative - solve orbit on-the-fly (less efficient)\n        # this_orbit = orbits[i_planet]\n        # predicted = raoff(this_orbit, epoch) + my_param\n\n        # Calculate likelihood contribution\n        resid = predicted - measurement\n        σ² = σ_measurement^2\n        χ² = -(1/2) * resid^2 / σ² - log(sqrt(2π * σ²))\n        ll += χ²\n    end\n\n    return ll\nend\n\nIf the observations are attached to the system as a whole (like radial velocity), the method signature should use SystemObservationContext:\n\n# MyObs: attached to a system\nfunction Octofitter.ln_obs(obs::MyObs, ctx::SystemObservationContext)\n    # Destructure the context to access parameters\n    (; θ_system, θ_obs, orbits, orbit_solutions, orbit_solutions_i_epoch_start) = ctx\n\n    T = Octofitter._system_number_type(θ_system)\n    ll = zero(T)\n\n    # Access your data from the table\n    for i_epoch in eachindex(obs.table.epoch)\n        epoch = obs.table.epoch[i_epoch]\n        measurement = obs.table.my_measurement[i_epoch]\n        σ_measurement = obs.table.σ_measurement[i_epoch]\n\n        # Access system variables\n        # θ_system.M, θ_system.plx, etc.\n\n        # Access observation-specific variables\n        my_param = θ_obs.my_parameter\n\n        # Method 1: Use pre-solved orbit solutions for all planets (efficient!)\n        predicted = zero(T)\n        for planet_i in eachindex(orbits)\n            # Get pre-solved solution for this planet at this epoch\n            sol = orbit_solutions[planet_i][i_epoch + orbit_solutions_i_epoch_start]\n\n            # Access planet-specific variables from θ_system.planets\n            planet_keys = keys(θ_system.planets)\n            planet_key = planet_keys[planet_i]\n            θ_planet = θ_system.planets[planet_key]\n\n            # Example: sum radial velocity contributions from all planets\n            predicted += radvel(sol) * θ_planet.mass  # example calculation\n        end\n        predicted += my_param  # Add observation-specific offset\n\n        # Method 2: Alternative - solve orbits on-the-fly (less efficient)\n        # for planet_i in eachindex(orbits)\n        #     orbit = orbits[planet_i]\n        #     predicted += radvel(orbit, epoch) * θ_system.planets[planet_i].mass\n        # end\n\n        # Calculate likelihood contribution\n        resid = predicted - measurement\n        σ² = σ_measurement^2\n        χ² = -(1/2) * resid^2 / σ² - log(sqrt(2π * σ²))\n        ll += χ²\n    end\n\n    return ll\nend\n\nInside your method, you should calculate the log-likelihood of the data stored in your observation object given the parameters.\n\nThe observation context bundles all parameters needed for evaluation:\n\nθ_system: System-level parameters like M (total mass), plx (parallax)\nθ_planet: Planet-specific parameters like a (semi-major axis), e (eccentricity) (only in PlanetObservationContext)\nθ_obs: Observation-specific parameters defined in the observation's @variables block\norbits, orbit_solutions, i_planet, orbit_solutions_i_epoch_start: Pre-computed orbital information for performance","category":"section"},{"location":"custom-likelihood/#Pre-solved-Orbit-Solutions-(Performance-Optimization)","page":"Custom Likelihoods","title":"Pre-solved Orbit Solutions (Performance Optimization)","text":"For performance, Octofitter pre-solves orbits at all observation epochs and passes these solutions to your likelihood function:\n\norbits: PlanetOrbits.jl orbit objects, one per planet\norbit_solutions: Pre-solved orbit positions at each epoch\norbit_solutions_i_epoch_start: Starting indices for epoch arrays (planet case) or per-planet (system case)\n\nKey advantages of using pre-solved solutions:\n\nMuch faster: Orbit solving is expensive, pre-solving avoids repeated calculations\nShared across likelihoods: Multiple likelihood objects can use the same pre-solved positions\nConsistent: All likelihoods see the same orbital positions for the same parameters\n\nUsage patterns:\n\n# Planet case: Get solution for this planet at epoch i\nsol = orbit_solutions[i_planet][i_epoch + orbit_solutions_i_epoch_start]\n\n# System case: Get solution for planet j at epoch i  \nsol = orbit_solutions[j][i_epoch + orbit_solutions_i_epoch_start[j]]\n\n# Extract positions from solution\nra_offset = raoff(sol)      # RA offset in mas\ndec_offset = decoff(sol)    # Dec offset in mas\nradial_vel = radvel(sol)    # Radial velocity in m/s\n# ... and many other functions available\n\nIf your likelihood requires new parameters, define them in the variables block of the likelihood constructor using the @variables begin; end syntax. These will be accessible in the θ_obs parameter.\n\nIf any parameter has a restricted domain where it is valid, ensure the prior is truncated using Distributions.truncated(). The code will automatically remap the variable using Bijectors.jl to prevent invalid values.","category":"section"},{"location":"custom-likelihood/#Using-your-custom-observation","page":"Custom Likelihoods","title":"Using your custom observation","text":"Once you've defined your observation type and methods, you can use it in a model like any other observation:\n\n# Create your data table\ndata = Table(\n    (epoch=50000, my_measurement=1.2, σ_measurement=0.1),\n    (epoch=50100, my_measurement=1.5, σ_measurement=0.1),\n    (epoch=50200, my_measurement=1.1, σ_measurement=0.1),\n)\n\n# Create the observation with observation-specific variables\nmy_obs = MyObs(\n    data,\n    name=\"MY_INSTRUMENT\",\n    variables=@variables begin\n        my_parameter ~ Normal(0, 0.5)  # Some calibration parameter\n        jitter ~ LogUniform(0.01, 1.0)  # Additional uncertainty\n    end\n)\n\n# Use it in a planet or system\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[my_obs],  # Include your custom observation\n    variables=@variables begin\n        # Planet orbital parameters...\n        a ~ Uniform(0, 100)\n        e ~ Uniform(0.0, 0.5)\n        # etc.\n    end\n)","category":"section"},{"location":"custom-likelihood/#Bonus:-Generative-model","page":"Custom Likelihoods","title":"Bonus: Generative model","text":"The above is sufficient to start sampling from the posterior. Ideally, you will also add a function that does the reverse: generate observations from a set of parameters. This is useful for a variety of statistical tests.\n\nSimply extend the Octofitter.generate_from_params function for your data type:\n\n# Generate new observations from model parameters\nfunction Octofitter.generate_from_params(like::MyObs, θ_system, θ_planet, θ_obs, orbits, orbit_solutions, i_planet, orbit_solutions_i_epoch_start; add_noise)\n\n    # Get epochs from original observations\n    epochs = like.table.epoch\n\n    # Generate new data at those epochs based on current parameters\n    # i.e. \"what would we observe at epoch X if the true parameters were θ_planet and θ_obs\"\n    simulated_measurements = []\n    for i_epoch in eachindex(like.table.epoch)\n        # Get the pre-solved orbit solution for this planet at this epoch\n        sol = orbit_solutions[i_planet][i_epoch + orbit_solutions_i_epoch_start]\n\n        # Calculate predicted measurement using pre-solved position\n        predicted = raoff(sol) + θ_obs.my_parameter  # example\n\n        # Add noise based on original uncertainties if requested\n        σ = like.table.σ_measurement[i_epoch]\n        noisy_measurement = add_noise ? predicted + σ * randn() : predicted\n        push!(simulated_measurements, noisy_measurement)\n    end\n\n    # Create new table with simulated data\n    simulated_table = Table(\n        epoch=epochs,\n        my_measurement=simulated_measurements,\n        σ_measurement=like.table.σ_measurement  # Keep original uncertainties\n    )\n\n    # Return new observation object with simulated data\n    return MyObs(\n        simulated_table,\n        name=like.name,\n        variables=(like.priors, like.derived)\n    )\nend","category":"section"},{"location":"custom-likelihood/#Additional-methods","page":"Custom Likelihoods","title":"Additional methods","text":"You may also need to implement:\n\n# For epoch subsetting (used in cross-validation)\nfunction Octofitter.likeobj_from_epoch_subset(obs::MyObs, obs_inds)\n    return MyObs(\n        obs.table[obs_inds,:,1];\n        name=obs.name,\n        variables=(obs.priors, obs.derived)\n    )\nend\n\nThis allows Octofitter to create subsets of your data for validation and testing purposes.","category":"section"},{"location":"fit-rv-rel/#Fit-Relative-RV-Data","page":"Relative RV Data","title":"Fit Relative RV Data","text":"Octofitter includes support for fitting relative radial velocity data. Currently this is only tested with a single companion. Please open an issue if you would like to fit multiple companions simultaneously.\n\nThe convention we adopt is that positive relative radial velocity is the velocity of the companion (exoplanets) minus the velocity of the host (star).\n\nTo fit relative RV data, start by creating a likelihood object:\n\nusing Octofitter\nusing OctofitterRadialVelocity\nusing CairoMakie\nusing Distributions\n\nrv_dat_1 = Table(\n    epoch=55000:100:57400,\n    rv = [\n         -24022.74\n        -18571.33\n        14221.56\n        26076.89\n        -459.26\n        -26319.26\n        -13430.96\n        19230.96\n        23580.26\n        -6786.28\n        -27161.78\n        -7548.58\n        23177.95\n        19780.94\n        -12738.39\n        -26503.74\n        -1249.19\n        25844.47\n        14888.83\n        -17986.76\n        -24381.49\n        5119.22\n        27083.2\n        9174.18\n        -22241.45\n    ],\n    # Hint! Type as \\sigma + <TAB>\n    σ_rv= fill(15000.0, 25),\n)\n\n\nrel_rv_obs = PlanetRelativeRVObs(\n    rv_dat_1, \n    name=\"simulated data\",\n    variables = @variables begin\n        jitter ~ LogUniform(0.1, 1000) # m/s\n    end\n)\n\nSee the standard radial velocity tutorial for examples on how this data can be loaded from a CSV file.\n\nThe relative RV likelihood does not incorporate an instrument-specific RV offset. A jitter parameter can still be specified in the likelihood's @variables block, as can parameters for a gaussian process model of stellar noise. Currently only a single instrument jitter parameter is supported. If you need to model relative radial velocities from multiple instruments with different jitters, please open an issue on GitHub.\n\nNext, create a planet and system model, attaching the relative rv likelihood to the planet.\n\nplanet_1 = Planet(\n    name=\"b\",\n    basis=RadialVelocityOrbit,\n    observations=[rel_rv_obs],\n    variables=@variables begin\n        M ~ truncated(Normal(1.2, 0.1), lower=0.1) # total mass in solar masses\n        a ~ Uniform(0,10)\n        e ~ Uniform(0.0, 0.5)\n        i ~ Sine()\n        ω ~ Uniform(0, 2pi)\n        Ω ~ Uniform(0, 2pi)\n        τ ~ Uniform(0, 1.0)\n        P = √(a^3/M)\n        tp = τ*P*365.25 + 60000 # reference epoch for τ. Choose an MJD date near your data.\n\n    end\n)\nsys = System(\n    name = \"Example-System\",\n    companions=[planet_1],\n    observations=[],\n    variables=@variables begin\n    end\n)\n\nmodel = Octofitter.LogDensityModel(sys)","category":"section"},{"location":"fit-rv-rel/#Initialize-the-model-and-verify-starting-point","page":"Relative RV Data","title":"Initialize the model and verify starting point","text":"init_chain = initialize!(model)\n\noctoplot(model, init_chain)\n\nusing Random\nrng = Random.Xoshiro(123)\nchain = octofit(rng, model)\n\noctoplot(model, chain, show_physical_orbit=true, mark_epochs_mjd=[mjd(\"2015-07-15\")])","category":"section"},{"location":"pma/#fit-pma","page":"Proper Motion Anomaly","title":"Fit Proper Motion Anomaly","text":"Octofitter.jl supports fitting orbit models to astrometric motion in the form of GAIA-Hipparcos proper motion anomaly (HGCA; https://arxiv.org/abs/2105.11662). These data points are calculated by finding the difference between a long term proper motion of a star between the Hipparcos and GAIA catalogs, and their proper motion calculated within the windows of each catalog. This gives four data points that can constrain the dynamical mass & orbits of planetary companions (assuming we subtract out the net trend).\n\nIf your star of interest is in the HGCA, all you need is it's GAIA DR3 ID number. You can find this number by searching for your target on SIMBAD.\n\nFor this tutorial, we will examine the star and companion HD 91312 A & B discovered by SCExAO. We will use their published astrometry and proper motion anomaly extracted from the HGCA.\n\nWe will also perform a model comparison: we will fit the same model to four different subsets of data to see how each dataset are impacting the final constraints. This is an important consistency check, especially with proper motion / absolute astrometry data which be susceptible to systematic errors.\n\nThe first step is to find the GAIA source ID for your object. For HD 91312, SIMBAD tells us the GAIA DR3 ID is 756291174721509376.","category":"section"},{"location":"pma/#Fitting-Astrometric-Motion-Only","page":"Proper Motion Anomaly","title":"Fitting Astrometric Motion Only","text":"Initial setup:\n\nusing Octofitter, Distributions, Random\n\nWe begin by finding orbits that are consistent with the astrometric motion. Later, we will add in relative astrometry to the fit from direct imaging to further constrain the planet's orbit and mass.\n\nCompared to previous tutorials, we will now have to add a few additional variables to our model. The first is a prior on the mass of the companion, called mass. The units used on this variable are Jupiter masses, in contrast to M, the primary's mass, in solar masses.  A reasonable uninformative prior for mass is Uniform(0,1000) or LogUniform(1,1000) depending on the situation.\n\nFor this model, we also want to place a prior on the host star mass rather than system total mass. For exoplanets there is litte difference between these two values, but in this example we have a reasonably informative prior on the host mass, and know from the paper that the companion is has a non-neglible effect on the total system mass.\n\nTo make this parameterization change, we specify priors on both masses in the @system block, and connect it to the planet.","category":"section"},{"location":"pma/#Retrieving-the-HGCA","page":"Proper Motion Anomaly","title":"Retrieving the HGCA","text":"To start, we retrieve the HGCA data for this object.\n\nhgca_obs = HGCAObs(\n    gaia_id=3937211745905473024,\n    variables=@variables begin\n        # Optional: flux ratio for luminous companions, one entry per companion\n        # fluxratio ~ Product([Uniform(0, 1), Uniform(0, 1), ])  # uncomment if needed for unresolved companions\n    end\n)\n\nYou can optionally provide flux ratio priors in the variables block to represent the flux ratio of the companions to the host, if you don't want to approximate it as zero. This is to handle luminous companions that are unresolved by gaia.\n\nIf you're in a hurry, and you're study orbits with periods much longer than the mission durations of Gaia or Hipparcos (>> 4 years) then you might consider using a faster approximation that the Gaia and Hipparcos measurements were instantaneous. You can do so as follows:\n\nhgca_obs = HGCAInstantaneousObs(gaia_id=756291174721509376, N_ave=1) \n\nN_ave is an optional argument to control over how many epochs the measurements are approximated, e.g. N_ave=10 implies that the position and proper motion was measured instantaneously 10 times over each mission and averaged.","category":"section"},{"location":"pma/#Planet-Model","page":"Proper Motion Anomaly","title":"Planet Model","text":"planet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    variables=@variables begin\n        a ~ LogUniform(0.1,20)\n        e ~ Uniform(0,0.999)\n        ω ~ UniformCircular()\n        i ~ Sine() # The Sine() distribution is defined by Octofitter\n        Ω ~ UniformCircular()\n\n        mass = system.M_sec\n\n        M = system.M\n        θ ~ UniformCircular()\n        tp = θ_at_epoch_to_tperi(θ, 57423.0; M, e, a, i, ω, Ω) # epoch of GAIA measurement\n    end\n)","category":"section"},{"location":"pma/#System-Model-and-Specifying-Proper-Motion-Anomaly","page":"Proper Motion Anomaly","title":"System Model & Specifying Proper Motion Anomaly","text":"Now that we have our planet model, we create a system model to contain it.\n\nWe specify priors on plx as usual, but here we use the gaia_plx helper function to read the parallax and uncertainty directly from the HGCA catalog using its source ID.\n\nWe also add parameters for the star's long term proper motion. This is usually close to the long term trend between the Hipparcos and GAIA measurements. If you're not sure what to use here, try Normal(0, 1000); that is, assume a long-term proper motion of 0 +- 1000 milliarcseconds / year.\n\nsys = System(\n    name=\"HD91312_pma\",\n    companions=[planet_b],\n    observations=[hgca_obs],\n    variables=@variables begin\n        M_pri ~ truncated(Normal(1.61, 0.1), lower=0.1) # Msol\n        M_sec ~ LogUniform(0.5, 1000) # MJup\n        M = M_pri + M_sec*Octofitter.mjup2msol # Msol\n\n        plx ~ gaia_plx(gaia_id=756291174721509376)\n                \n        # Priors on the center of mass proper motion\n        pmra ~ Normal(-137, 10)\n        pmdec ~ Normal(2,  10)\n    end\n)\n\nmodel_pma = Octofitter.LogDensityModel(sys)\n\nAfter the priors, we add the proper motion anomaly measurements from the HGCA. If this is your first time running this code, you will be prompted to automatically download and cache the catalog which may take around 30 seconds.","category":"section"},{"location":"pma/#Sampling-from-the-posterior-(PMA-only)","page":"Proper Motion Anomaly","title":"Sampling from the posterior (PMA only)","text":"Because proper motion anomaly data is quite sparse, it can often produce multi-modal posteriors. If your orbit already has several relative astrometry or RV data points, this is less of an issue. But in many cases it is recommended to use the Pigeons.jl sampler instead of Octofitter's default. This sampler is less efficient for unimodal distributions, but is more robust at exploring posteriors with distinct, widely separated peaks. \n\nTo install and use Pigeons.jl with Octofitter, type using Pigeons at in the terminal and accept the prompt to install the package. You may have to restart Julia.\n\nnote: Note\noctofit_pigeons scales very well across multiple cores. Start julia with julia --threads=auto to make sure you have multiple threads available for sampling.\n\nWe now sample from our model using Pigeons:\n\nusing Pigeons\nchain_pma, pt = octofit_pigeons(model_pma, n_rounds=13, explorer=SliceSampler()) \ndisplay(chain_pma)\n\nNote that octofit_pigeons took somewhat longer to run than octofit typically does; however, as we will see, it sampled successfully from severally completely disconnected modes in the posterior. That makes it a good fit for sampling from proper motion anomaly and relative astrometry with limited orbital coverage.","category":"section"},{"location":"pma/#Analysis","page":"Proper Motion Anomaly","title":"Analysis","text":"The first step is to look at the table output above generated by MCMCChains.jl. The rhat column gives a convergence measure. Each parameter should have an rhat very close to 1.000. If not, you may need to run the model for more iterations or tweak the parameterization of the model to improve sampling. The ess column gives an estimate of the effective sample size. The mean and std columns give the mean and standard deviation of each parameter.\n\nThe second table summarizes the 2.5, 25, 50, 75, and 97.5 percentiles of each parameter in the model.","category":"section"},{"location":"pma/#Pair-Plot","page":"Proper Motion Anomaly","title":"Pair Plot","text":"If we wish to examine the covariance between parameters in more detail, we can construct a pair-plot (aka. corner plot).\n\n# Create a corner plot / pair plot.\n# We can access any property from the chain specified in Variables\nusing CairoMakie: Makie\nusing PairPlots\noctocorner(model_pma, chain_pma, small=true)\n\nNotice how there are completely separated peaks? The default Octofitter sample (Hamiltonian Monte Carlo) is capabale of jumping 2-3σ gaps between modes, but such widely separated peaks can cause issues (hence why we used Pigeons in this example).","category":"section"},{"location":"pma/#Posterior-Mass-vs.-Semi-Major-Axis","page":"Proper Motion Anomaly","title":"Posterior Mass vs. Semi-Major Axis","text":"Given that this posterior is quite unconstrained, it is useful to make a simplified plot marginalizing over all orbital  parameters besides semi-major axis. We can do this using PairPlots.jl:\n\nusing CairoMakie, PairPlots\npairplot(\n    (; a=chain_pma[\"b_a\"][:], mass=chain_pma[\"b_mass\"][:]) =>\n        (\n            PairPlots.Scatter(color=:red),\n            PairPlots.MarginHist(),\n            PairPlots.MarginQuantileLines(),\n            PairPlots.MarginQuantileText(),\n        ),\n    labels=Dict(:mass=>\"mass [Mⱼᵤₚ]\", :a=>\"sma. [au]\"),\n    axis = (;\n        a = (;\n            scale=Makie.pseudolog10,\n            ticks=2 .^ (0:1:6)\n        )\n    )\n)","category":"section"},{"location":"quick-start/#Quick-Start-(@id-quick-start)","page":"Quick Start","title":"Quick Start (@id quick-start)","text":"This guide introduces the key concepts in Octofitter:\n\nObservation objects to hold your data\nPlanet and System models to specify variables, priors, and system architecture\nSampling from the posterior using MCMC\nPlotting the results\nSaving the chain\n\nFor installation instructions, see Installation.","category":"section"},{"location":"quick-start/#Example:-Fit-a-Single-Planet-Orbit-to-Relative-Astrometry","page":"Quick Start","title":"Example: Fit a Single Planet Orbit to Relative Astrometry","text":"Load the required packages:\n\nusing Octofitter, Distributions, CairoMakie, PairPlots\n\nCreate a PlanetRelAstromObs object containing your observational data. In this case its the position of the planet relative to the star, but many other kinds of data are supported:\n\nastrom_dat = Table(\n    epoch = [50000, 50120, 50240],      # Dates in MJD\n    ra = [-505.7, -502.5, -498.2],      # [mas] East positive\n    dec = [-66.9, -37.4, -7.9],         # [mas] North positive\n    σ_ra = [10.0, 10.0, 10.0],          # [mas] Uncertainties\n    σ_dec = [10.0, 10.0, 10.0],         # [mas] Uncertainties\n    cor = [0.0, 0.0, 0.0]               # RA/Dec correlations\n)\nastrom = PlanetRelAstromObs(astrom_dat, name=\"GPI astrom\") # must give a name for each group of observations\n\nDefine a planet model with orbital elements and their prior distributions:\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[astrom],\n    variables=@variables begin\n        M ~ truncated(Normal(1.2, 0.1), lower=0.1)  # Total mass (solar masses) for this orbit\n        a ~ Uniform(0, 100)        # Semi-major axis [AU]\n        e ~ Uniform(0.0, 0.5)      # Eccentricity  \n        i ~ Sine()                 # Inclination [rad]\n        ω ~ UniformCircular()      # Argument of periastron [rad]\n        Ω ~ UniformCircular()      # Longitude of ascending node [rad]\n        θ ~ UniformCircular()      # Position angle at reference epoch [rad]\n        # Epoch of periastron passage\n        # We calculate it from the position angle above\n        tp = θ_at_epoch_to_tperi(θ, 50000; M, e, a, i, ω, Ω)  \n    end\n)\n\nnote: Note\nMake sure to adjust the epoch 50000 above to match your most constraining data epoch.\n\nDefine the system with its mass and distance - see System Construction for more options:\n\nsys = System(\n    name=\"HD1234\",\n    companions=[planet_b],\n    observations=[],\n    variables=@variables begin\n        plx ~ truncated(Normal(50.0, 0.02), lower=0.1)  # Parallax (mas)\n    end\n)\n\nThat there are many different orbit parameterizations, each requiring different of parameters names. The KepOrbit is a full 3D keplerian orbit with Campbell parameters. Visual means that we have a defined parallax distance plx that can map separations in AU to arcseconds.\n\nCompile the model into efficient sampling code:\n\nmodel = Octofitter.LogDensityModel(sys)\n\nInitialize the starting points for the chains. You can optionally provide starting values directly for certain variables (UniformCircular priors are a special case, see docs for details).\n\ninit_chain = initialize!(model, (;\n    plx = 50.001,\n    planets = (;\n        b=(;\n            M = 1.18,\n            a = 10.0,\n            e = 0.01,\n        )\n    )\n)) \n\nVisualize the starting point. You can use this plot to make absolutely sure your data is entered in correctly:\n\noctoplot(model, init_chain)\n\nSample from the posterior using Hamiltonian Monte Carlo (see Samplers for other options):\n\nchain = octofit(model, iterations=1000)\n\nVisualize the results with orbit plots and a corner plot:\n\noctoplot(model, chain)     # Plot orbits and data\n\noctocorner(model, chain)   # Corner plot of posterior\n\nSave the results to a FITS file (see Loading and Saving Data for other formats):\n\nOctofitter.savechain(\"output.fits\", chain)","category":"section"},{"location":"quick-start/#Working-with-Dates","page":"Quick Start","title":"Working with Dates","text":"These functions may help you convert dates to and from Modified Julian Days using these helper functions:\n\nmjd(\"2020-01-01\")     # Date string to MJD\nyears2mjd(2020.0)     # Decimal year to MJD\nmjd2date(50000)       # MJD to date","category":"section"},{"location":"quick-start/#Next-Steps","page":"Quick Start","title":"Next Steps","text":"See the Tutorials section for complete examples.","category":"section"},{"location":"api/#API-Documentation","page":"Full API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"api/#Octofitter.@variables","page":"Full API Documentation","title":"Octofitter.@variables","text":"@variables begin\n    [prior_1] ~ [UnivariateDistribution]\n    [prior_2] ~ [UnivariateDistribution]\n    calculation_3 = obs.[prior_1] + obs.[prior_2]\nend\n\n\n\n\n\n","category":"macro"},{"location":"api/#Octofitter.Planet","page":"Full API Documentation","title":"Octofitter.Planet","text":"Planet([derived,] priors, [astrometry,], name=:symbol)\n\nA planet (or substellar companion) part of a model. Must be constructed with a block of priors, and optionally additional derived parameters and/or sastrometry. name must be a symbol, e.g. :b.\n\n\n\n\n\n","category":"type"},{"location":"api/#Octofitter.System","page":"Full API Documentation","title":"Octofitter.System","text":"System([derived,] priors, [images,] [propermotionanom,] planets..., name=:symbol)\n\nConstruct a model of a system. Must be constructed with a block of priors, and optionally additional derived parameters. You may provide ProperMotionAnomLikelihood() and/or Images() of the system. Finally, planet models are listed last. name must be a symbol e.g. :HD56441.\n\n\n\n\n\n","category":"type"},{"location":"api/#Octofitter.PlanetRelAstromObs","page":"Full API Documentation","title":"Octofitter.PlanetRelAstromObs","text":"data = Table(\n    (epoch = 5000, ra = -505.7637580573554, dec = -66.92982418533026, σ_ra = 10, σ_dec = 10, cor=0),\n    (epoch = 5050, ra = -505.7637580573554, dec = -66.92982418533026, σ_ra = 10, σ_dec = 10, cor=0),\n    (epoch = 5100, ra = -505.7637580573554, dec = -66.92982418533026, σ_ra = 10, σ_dec = 10, cor=0),\n)\nPlanetRelAstromObs(data)\n\nRepresents relative astrometry observations between a host star and a secondary body. :epoch is a required column, in addition to either :ra, :dec, :σ_ra, :σ_dec or :pa, :sep, :σ_pa, :σ_sep. All units are in milliarcseconds or radians as appropriate.\n\nIn addition to the example above, any Tables.jl compatible source can be provided.\n\n\n\n\n\n","category":"type"},{"location":"api/#OctofitterRadialVelocity.StarAbsoluteRVObs","page":"Full API Documentation","title":"OctofitterRadialVelocity.StarAbsoluteRVObs","text":"StarAbsoluteRVObs(\n    (;epoch=5000.0,  rv=−6.54, σ_rv=1.30),\n    (;epoch=5050.1,  rv=−3.33, σ_rv=1.09),\n    (;epoch=5100.2,  rv=7.90,  σ_rv=.11);\n\n    name=\"inst name\",\n    variables=@variables begin\n        offset ~ Normal(0, 100)           # RV zero-point (m/s)\n        jitter ~ LogUniform(0.1, 100.0)  # RV jitter (m/s)\n    end\n)\n\n# Example with trend function and Gaussian Process:\nStarAbsoluteRVObs(\n    (;epoch=5000.0,  rv=−6.54, σ_rv=1.30),\n    (;epoch=5050.1,  rv=−3.33, σ_rv=1.09),\n    (;epoch=5100.2,  rv=7.90,  σ_rv=.11);\n\n    name=\"inst name\",\n    trend_function = (θ_obs, epoch) -> θ_obs.trend_slope * (epoch - 57000),  # Linear trend\n    gaussian_process = θ_obs -> GP(θ_obs.gp_η₁^2 * SqExponentialKernel() ∘ ScaleTransform(1/θ_obs.gp_η₂)),\n    variables=@variables begin\n        offset ~ Normal(0, 100)             # RV zero-point (m/s)\n        jitter ~ LogUniform(0.1, 100.0)    # RV jitter (m/s)\n        trend_slope ~ Normal(0, 1)          # Linear trend slope (m/s/day)\n        gp_η₁ ~ LogUniform(1.0, 100.0)      # GP amplitude\n        gp_η₂ ~ LogUniform(1.0, 100.0)      # GP length scale\n    end\n)\n\nRepresents a likelihood function of absolute radial velocity of a host star. :epoch (mjd), :rv (m/s), and :σ_rv (m/s) are all required.\n\nIn addition to the example above, any Tables.jl compatible source can be provided.\n\nThe offset and jitter variables should be defined in the variables block and represent the RV zero-point and additional uncertainty to be added in quadrature to the formal measurement errors.\n\nWhen using a trend function, it should be a function that takes θ_obs (observation parameters) and epoch and returns an RV offset. Trend parameters should be defined in the variables block.\n\nWhen using a Gaussian process, the gaussian_process parameter should be a function that takes θ_obs (observation parameters) and returns a GP kernel. GP hyperparameters should be defined in the variables block and accessed via θ_obs.parameter_name.\n\nnote: Note\nIf you don't supply a variables argument, the detault priors are offset ~ Uniform(-1000, 1000) and jitter ~ LogUniform(0.001, 100)\n\n\n\n\n\n","category":"type"},{"location":"api/#OctofitterRadialVelocity.PlanetRelativeRVObs","page":"Full API Documentation","title":"OctofitterRadialVelocity.PlanetRelativeRVObs","text":"PlanetRelativeRVObs(\n    (;epoch=5000.0,  rv=−6.54, σ_rv=1.30),\n    (;epoch=5050.1,  rv=−3.33, σ_rv=1.09),\n    (;epoch=5100.2,  rv=7.90,  σ_rv=.11);\n\n    name=\"inst name\",\n    variables=@variables begin\n        jitter ~ LogUniform(0.1, 100.0)  # RV jitter (m/s)\n    end\n)\n\n# Example with Gaussian Process:\nPlanetRelativeRVObs(\n    (;epoch=5000.0,  rv=−6.54, σ_rv=1.30),\n    (;epoch=5050.1,  rv=−3.33, σ_rv=1.09),\n    (;epoch=5100.2,  rv=7.90,  σ_rv=.11);\n\n    name=\"inst name\",\n    gaussian_process = θ_obs -> GP(θ_obs.gp_η₁^2 * SqExponentialKernel() ∘ ScaleTransform(1/θ_obs.gp_η₂)),\n    variables=@variables begin\n        jitter ~ LogUniform(0.1, 100.0)     # RV jitter (m/s)\n        gp_η₁ ~ LogUniform(1.0, 100.0)      # GP amplitude\n        gp_η₂ ~ LogUniform(1.0, 100.0)      # GP length scale\n    end\n)\n\nRepresents a likelihood function of relative radial velocity between a host star and a secondary body. :epoch (mjd), :rv (m/s), and :σ_rv (m/s) are all required.\n\nIn addition to the example above, any Tables.jl compatible source can be provided.\n\nThe jitter variable should be defined in the variables block and represents additional uncertainty to be added in quadrature to the formal measurement errors.\n\nWhen using a Gaussian process, the gaussian_process parameter should be a function that takes θ_obs (observation parameters) and returns a GP kernel. GP hyperparameters should be defined in the variables block and accessed via θ_obs.parameter_name.\n\n\n\n\n\n","category":"type"},{"location":"api/#Octofitter.PhotometryObs","page":"Full API Documentation","title":"Octofitter.PhotometryObs","text":"data = Table(\n    (phot=15.0, σ_phot=3.0),\n    (phot=14.8, σ_phot=0.5),\n)\nPhotometryObs(\n    data,\n    name=\"INSTRUMENT\",\n    variables=@variables begin\n        flux ~ Uniform(0, 10)\n    end\n)\n\nAn observation type for comparing measured photometry points in a single filter band to data (provided here). Requires the :phot and :σ_phot columns. Can be provided with any Tables.jl compatible data source.\n\nFor multiple bands, create separate PhotometryObs objects.\n\nThe flux variable should be defined in the variables block rather than in the planet definition. This can be derived from physical models that take planet mass and other system parameters as input.\n\nThe name is used for variable naming in the chain output.\n\n\n\n\n\n","category":"type"},{"location":"api/#Octofitter.HGCAObs","page":"Full API Documentation","title":"Octofitter.HGCAObs","text":"HGCAObs(;\n    gaia_id=1234,\n    variables=@variables begin\n        fluxratio ~ [Uniform(0, 1), Uniform(0, 1)]  # array for each companion\n    end\n)\n\nModel Hipparcos-Gaia Catalog of Accelerations (Brandt et al) data using a full model of the Gaia and Hipparcos measurement process and linear models.\n\nThe fluxratio variable should be an array containing the flux ratio of each companion in the same order as the planets in the system.\n\nUpon first load, you will be prompted to accept the download of the eDR3 version of the HGCA catalog.\n\n\n\n\n\n","category":"type"},{"location":"api/#Octofitter.ObsPriorAstromONeil2019","page":"Full API Documentation","title":"Octofitter.ObsPriorAstromONeil2019","text":"ObsPriorAstromONeil2019(astrometry_likelihood, period_prior)\n\nGiven a an astrometry likelihood (PlanetRelAstromLikelihood), apply the \"observable based priors\" of K. O'Neil 2019 \"Improving Orbit Estimates for Incomplete Orbits with a New Approach to Priors: with Applications from Black Holes to Planets\".\n\nThis prior correction is only correct if you supply Uniform priors on  all Campbell orbital parameters and a Uniform prior on Period (not semi-major axis). This period prior has a significant impact in the fit and recommendations for its range were not published in the original paper.\n\nExamples\n\nastrom_like = PlanetRelAstromLikelihood(astrom_table)\n\n# Apply observable based priors ontop of our uniform Campbell priors:\nobs_prior = ObsPriorAstromONeil2019(astrom_like)\n\n# The astrometry lieklihood object is passed as a first parameter\n# since the obserable-based priors depend on the observation \n# epochs.\n\n@planet b Visual{KepOrbit} begin\n    # Instead of a prior on sma\n    # a ~ Uniform(0.001, 10000)\n\n    # Put a prior on period:\n\tP ~ Uniform(0.001, 2000) # yrs\n    a = cbrt(system.M * b.P^2)\n\n    # Keep sine prior on inclination\n    i ~ Sine()\n\n    # Rest are uniform\n    e ~ Uniform(0.0, 1.0)\n    ω ~ UniformCircular()\n    Ω ~ UniformCircular()\n    τ ~ UniformCircular(1.0)\nend astrom_like obs_prior\n\n\n\n\n\n","category":"type"},{"location":"api/#Octofitter.Sine","page":"Full API Documentation","title":"Octofitter.Sine","text":"Sine()\n\nA custom univariate distribution. The pdf is a sine function defined between 0 and π. This is a common prior distribution used when fitting orbits to astrometry.\n\nThe full Distributions.jl interface is not yet defined for this distribution, but the following methods work: pdf, logpdf, minimum, maximum, insupport, mean, var, cdf, quantile\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.mjd","page":"Full API Documentation","title":"PlanetOrbits.mjd","text":"mjd(\"2020-01-01\")\n\nGet the modfied julian day of a date, or in general a UTC timestamp.\n\n\n\n\n\nmjd(Date(\"2020-01-01\"))\n\nGet the modfied julian day of a Date or DateTime object.\n\n\n\n\n\nmjd()\n\nGet the current modified julian day of right now.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.years2mjd","page":"Full API Documentation","title":"PlanetOrbits.years2mjd","text":"years2mjd()\n\nConvert from decimal years (e.g. 1995.25) into modified julian date, rounded to closest second\n\n\n\n\n\n","category":"function"},{"location":"api/#Octofitter.gaia_plx","page":"Full API Documentation","title":"Octofitter.gaia_plx","text":"gaia_plx(gaia_id=12123)\n\nGet a distribution (truncated Normal) of parallax distance in mas of a source with  GAIA catalog id gaia_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#Octofitter.advancedhmc","page":"Full API Documentation","title":"Octofitter.advancedhmc","text":"The method signature of Octofitter.hmc is as follows:\n\nchain = advancedhmc(\n    [rng::Random.AbstractRNG],\n    model::Octofitter.LogDensityModel\n    target_accept::Number=0.8,\n    adaptation=1000,\n    iterations=1000,\n    drop_warmup=true,\n    max_depth=12,\n)\n\nSample from the posterior defined by model using Hamiltonian Monte Carlo with  the No U-Turn Sampler from AdvancedHMC.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.Visual","page":"Full API Documentation","title":"PlanetOrbits.Visual","text":"Visual{OrbitType}(..., plx=...)\n\nThis wraps another orbit to add the parallax distance field plx, thus allowing projected quantities to be calculated. It forwards everything else to the parent orbit.\n\nFor example, the KepOrbit type supports calculating x and y positions in AU. A Visual{KepOrbit} additionally supports calculating projected right ascension and declination offsets.\n\nnote: Note\nThe ThieleInnesOrbit type does not need to be wrapped in Visual as it the Thiele-Innes constants are already expressed in milliarcseconds and thus it always requires a plx value.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.AbsoluteVisual","page":"Full API Documentation","title":"PlanetOrbits.AbsoluteVisual","text":"AbsoluteVisual{OrbitType}(..., ref_epoch=, ra=, dec=, plx=, rv=, pmra=, pmdec=)\n\nThis wraps another orbit object to add parallax, proper motion, and RV fields, at a given reference epoch. \n\nLike a Visual{OrbitType} this allows for calculating projected quantities, eg. separation in milliarcseconds.\n\nWhat this type additionally does is correct for the star's 3D motion through space (RV and proper motion) and differential light travel-time compared to a reference epoch when calculating various quantities.  This becomes necessary when computing eg. RVs over a long time period.\n\nra        : degrees dec       : degrees parallax  : mas pmra      : mas/yr pmdec     : mas/yr rv        : m/s ref_epoch : years\n\nTODO: account for viewing angle differences and differential light travel time between a planet and its host.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.RadialVelocityOrbit","page":"Full API Documentation","title":"PlanetOrbits.RadialVelocityOrbit","text":"RadialVelocityOrbit(a, e, ω, tp, M)\n\nRepresents an orbit of a planet with only the information retrievable from radial velocity measurements. That is, without inclination, longitude of ascending node, or distance to the system.\n\n\n\n\n\n","category":"type"},{"location":"api/#Octofitter.sonora_photometry_interpolator","page":"Full API Documentation","title":"Octofitter.sonora_photometry_interpolator","text":"sonora_photometry_interpolator(:Keck_L′, [metalicity=\"+0.0\"])\n\nGiven a supported photometric band and [M/H] metalicity (default=solar), return a function of temperature (K) and mass (M_jup) that gives the  absolute magnitude of the planet in that bandpass.\n\nSupported bands: :MKOY, :MKOZ, :MKOJ, :MKOH, :MKOK, :MKOL′, :MKOM′, :TwoMASSJ, :TwoMASSH, :TwoMASSKs, :KeckKs, :KeckL′, :KeckMs, :SDSSg′, :SDSSr′, :SDSSi′, :SDSSz′, :IRAC36, :IRAC45, :IRAC57, :IRAC79, :WISEW1, :WISEW2, :WISEW3, :WISE_W4\n\nSupported metalicities: \"+0.0\", \"-0.5\", \"+0.5\"\n\n\n\n\n\n","category":"function"},{"location":"api/#Octofitter.sonora_cooling_interpolator","page":"Full API Documentation","title":"Octofitter.sonora_cooling_interpolator","text":"itp = sonora_cooling_interpolator()\n\nCreate a function mapping (ageMyr, massMjup) -> temp_K using Sonora Bobcat cooling model grids.\n\n\n\n\n\n","category":"function"},{"location":"api/#Octofitter.plotchains","page":"Full API Documentation","title":"Octofitter.plotchains","text":"plotchains(\n    chain, planet_key;\n    N=1500,\n    ii = rand(1:size(chain,1)*size(chain,3), N),\n    color=length(model.system.planets) == 0 || !haskey(chain, string(planet_key)*\"_a\") ? nothing : string(planet_key)*\"_a\",\n    colorbartitle=color,\n    clims=nothing,\n    cmap=:plasma,\n    alpha=30/length(ii),\n    attime=nothing,\n    kwargs...,\n)\n\nDraw samples from a posterior chain for a given planet given by name planet_key and visualize them in some way. Use kind to control what plot is made. A few options: :astrometry, :radvel, :trueanom, :meananom, :eccanom, :x, :y, :z, (:x, :y), :raoff, :decoff, :pmra, :pmdec, :accra, :accdec, :radvel, :posangle, :projectedseparation. See PlanetOrbits documentation for more details.\n\nInputs:\n\nchain                   The chain to draw from\nplanet_key              Planet name in the model (symbol)\nN=1500                  Number of samples to draw for the plot \nkind=nothing            Specify what kind of plot to make. \nii=...                  Specific row numbers to use, if you want to e.g. plot the same 100 samples in a few different plots\ncolor=\"planetkeya\"   Column name to to map colors to. Semi-major axis by default but can be any column or an arbitrary array.\ncolorbartitle=color     Name for colourbar\nclims=nothing           Tuple of colour limits (min and max)\ncmap=:plasma            Colormap\nalpha=...               Transparency of the lines\n\n\n\n\n\n","category":"function"},{"location":"api/#Octofitter.projectpositions","page":"Full API Documentation","title":"Octofitter.projectpositions","text":"projectpositions(model, chains.planets[1], mjd(\"2020-02-02\"))\n\nGiven the posterior for a particular planet in the model and a modified julian date(s), return ra and dec offsets in mas for each sampling in the posterior.\n\n\n\n\n\n","category":"function"},{"location":"api/#Octofitter.octofit","page":"Full API Documentation","title":"Octofitter.octofit","text":"octofit(\n    [rng::Random.AbstractRNG],\n    model::Octofitter.LogDensityModel\n    target_accept::Number=0.8,\n    ensemble::AbstractMCMC.AbstractMCMCEnsemble=MCMCSerial();\n    adaptation,\n    iterations,\n    drop_warmup=true,\n    max_depth=12,\n    initial_samples= pathfinder ? 500 : 250_000,  # deprecated\n    initial_parameters=nothing, # deprecated\n    step_size=nothing,\n    verbosity=2,\n)\n\nSample from the posterior defined by model using Hamiltonian Monte Carlo with  the No U-Turn Sampler from AdvancedHMC.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#Octofitter.octofit_pigeons","page":"Full API Documentation","title":"Octofitter.octofit_pigeons","text":"using Pigeons\noctofit_pigeons(model; nrounds, n_chains=16, n_chains_variational=16)\n\nUse Pigeons.jl to sample from intractable posterior distributions. Pigeons must be loaded by the user.\n\nusing Pigeons\nmodel = Octofitter.LogDensityModel(System, autodiff=:ForwardDiff, verbosity=4)\nchain, pt = octofit_pigeons(model)\n\n\n\n\n\n","category":"function"},{"location":"api/#Octofitter.initialize!","page":"Full API Documentation","title":"Octofitter.initialize!","text":"initialize!(model::LogDensityModel, fixed_params=nothing; kwargs...)\n\nInitialize the model with optional fixed parameters provided as a named tuple. Fixed parameters will be held constant during optimization and sampling.\n\nThe fixed_params can include:\n\nSystem-level variables: (; plx=24.4, pmra=10.2, ...)\nPlanet variables: (; planets=(; b=(; a=1.5, e=0.1, ...), ...))  \nObservation variables: (; observations=(; ObsName=(; var1=val1, var2=val2, ...), ...))\n\nAvailable keyword arguments include:\n\nverbosity=1: control extra logging, can be 0 for silent, up to 4 for debugging info\npathfinder_autodiff=AutoForwardDiff(): what autodiff backend to use for initialization (not necessarily the same one used for the model in general)\nnruns=8: how many runs of multi-pathfinder to use \nntries=2: how many times can pathfinder fail and restart\nndraws=1000: how many draws to return from the pathfinder approximation\n\nExample:\n\ninit_chain = initialize!(model, (;\n    plx=24.4,\n    pmra=10.2,\n    planets=(;\n        b=(;\n            a=1.5,\n            e=0.1,\n        )\n    ),\n    observations=(;\n        GaiaRV=(;\n            offset_gaiarv=-50.0,\n            jitter_gaiarv=0.1,\n        ),\n        GaiaDR4=(;\n            astrometric_jitter=0.05,\n        )\n    )\n))\n\n\n\n\n\n","category":"function"},{"location":"api/#Octofitter.savechain","page":"Full API Documentation","title":"Octofitter.savechain","text":"Octofitter.savechain(\"saved-chain.fits\", chain)\n\nSave an MCMCChain to a FITS file binary table.\n\n\n\n\n\n","category":"function"},{"location":"api/#Octofitter.loadchain","page":"Full API Documentation","title":"Octofitter.loadchain","text":"Octofitter.loadchain(\"saved-chain.fits\")\n\nLoad an MCMCChain from a FITS file binary table.\n\n\n\n\n\n","category":"function"},{"location":"rv-gp/#fit-rv-gp","page":"Gaussian Process","title":"Fit Gaussian Process","text":"This example shows how to fit a Gaussian process to model stellar activity in RV data. It continues from Basic RV Fit.\n\nnote: Note\nRadial velocity modelling is supported in Octofitter via the extension package OctofitterRadialVelocity. To install it, run  pkg> add OctofitterRadialVelocity\n\nThere are two different GP packages supported by OctofitterRadialVelocity: AbstractGPs, and Celerite. Important note: Celerite.jl does not support Julia 1.0+, so we currently bundle a fork that has been patched to work. When / if Celerite.jl is updated we will switch back to the public package.\n\nFor this example, we will fit the orbit of the planet K2-131 to perform the same fit as in the RadVel Gaussian Process Fitting tutorial.\n\nWe will use the following packages:\n\nusing Octofitter\nusing OctofitterRadialVelocity\nusing PlanetOrbits\nusing CairoMakie\nusing PairPlots\nusing CSV\nusing DataFrames\nusing Distributions\n\nWe will pick up from our tutorial Basic RV Fit with the data already downloaded and available as a table called rv_dat:\n\nrv_file = download(\"https://raw.githubusercontent.com/California-Planet-Search/radvel/master/example_data/k2-131.txt\")\nrv_dat_raw = CSV.read(rv_file, DataFrame, delim=' ')\nrv_dat = DataFrame();\nrv_dat.epoch = jd2mjd.(rv_dat_raw.time)\nrv_dat.rv = rv_dat_raw.mnvel\nrv_dat.σ_rv = rv_dat_raw.errvel\ntels = sort(unique(rv_dat_raw.tel))","category":"section"},{"location":"rv-gp/#Gaussian-Process-Fit-with-AbstractGPs","page":"Gaussian Process","title":"Gaussian Process Fit with AbstractGPs","text":"Let us now add a Gaussian process to model stellar activity. This should improve the fit.\n\nWe start by writing a function that creates a Gaussian process kernel from a set of system parameters. We will create a quasi-periodic kernel. We provide this function as an arugment gaussian_process to the likelihood constructor:\n\nusing AbstractGPs\n\ngp_explength_mean = 9.5*sqrt(2.) # sqrt(2)*tau in Dai+ 2017 [days]\ngp_explength_unc = 1.0*sqrt(2.)\ngp_perlength_mean = sqrt(1. /(2. *3.32)) # sqrt(1/(2*gamma)) in Dai+ 2017\ngp_perlength_unc = 0.019\ngp_per_mean = 9.64 # T_bar in Dai+ 2017 [days]\ngp_per_unc = 0.12\n\nrvlike_harps = StarAbsoluteRVObs(\n    rv_dat[rv_dat_raw.tel .== \"harps-n\",:],\n    name=\"harps-n\",\n    variables=(@variables begin\n        offset ~ Normal(-6693,100) # m/s\n        jitter ~ LogUniform(0.1,100) # m/s\n        # Add priors on GP kernel hyper-parameters.\n        η_1 ~ truncated(Normal(25,10),lower=0.1,upper=100)\n        # Important: ensure the period and exponential length scales\n        # have physically plausible lower and upper limits to avoid poor numerical conditioning\n        η_2 ~ truncated(Normal(gp_explength_mean,gp_explength_unc),lower=5,upper=100)\n        η_3 ~ truncated(Normal(gp_per_mean,1),lower=2, upper=100)\n        η_4 ~ truncated(Normal(gp_perlength_mean,gp_perlength_unc),lower=0.2, upper=10)\n    end),\n    gaussian_process = θ_obs -> GP(\n        θ_obs.η_1^2 *  \n        (SqExponentialKernel() ∘ ScaleTransform(1/(θ_obs.η_2))) *\n        (PeriodicKernel(r=[θ_obs.η_4]) ∘ ScaleTransform(1/(θ_obs.η_3)))\n    )\n)\nrvlike_pfs = StarAbsoluteRVObs(\n    rv_dat[rv_dat_raw.tel .== \"pfs\",:],\n    name=\"pfs\",\n    variables=(@variables begin\n        offset ~ Normal(0,100) # m/s\n        jitter ~ LogUniform(0.1,100) # m/s\n        # Add priors on GP kernel hyper-parameters.\n        η_1 ~ truncated(Normal(25,10),lower=0.1,upper=100)\n        # Important: ensure the period and exponential length scales\n        # have physically plausible lower and upper limits to avoid poor numerical conditioning\n        η_2 ~ truncated(Normal(gp_explength_mean,gp_explength_unc),lower=5,upper=100)\n        η_3 ~ truncated(Normal(gp_per_mean,1),lower=2, upper=100)\n        η_4 ~ truncated(Normal(gp_perlength_mean,gp_perlength_unc),lower=0.2, upper=10)\n    end),\n    gaussian_process = θ_obs -> GP(\n        θ_obs.η_1^2 *  \n        (SqExponentialKernel() ∘ ScaleTransform(1/(θ_obs.η_2))) *\n        (PeriodicKernel(r=[θ_obs.η_4]) ∘ ScaleTransform(1/(θ_obs.η_3)))\n    )\n)\n## No change to the rest of the model\n\nplanet_1 = Planet(\n    name=\"b\",\n    basis=RadialVelocityOrbit,\n    observations=[],\n    variables=@variables begin\n        e = 0\n        ω = 0.0\n        # To match RadVel, we set a prior on Period and calculate semi-major axis from it\n        P ~ truncated(\n            Normal(0.3693038/365.256360417, 0.0000091/365.256360417),\n            lower=0.0001\n        )\n        M = system.M\n        a = cbrt(M * P^2) # note the equals sign. \n        τ ~ UniformCircular(1.0)\n        tp = τ*P*365.256360417 + 57782 # reference epoch for τ. Choose an MJD date near your data.\n        # minimum planet mass [jupiter masses]. really m*sin(i)\n        mass ~ LogUniform(0.001, 10)\n    end\n)\n\nsys = System(\n    name = \"k2_132\",\n    companions=[planet_1],\n    observations=[rvlike_harps, rvlike_pfs],\n    variables=@variables begin\n        M ~ truncated(Normal(0.82, 0.02),lower=0.1) # (Baines & Armstrong 2011).\n    end\n)\n\nmodel = Octofitter.LogDensityModel(sys)\n\n\nNote that the two instruments do not need to use the same Gaussian process kernels, nor the same hyper parameter names. \n\nnote: Note\nTip: If you want the instruments to share the Gaussian process kernel hyper parameters, move the variables up to the system's @variables block, and forward them to the observation variables block e.g. η₁ = system.η₁, η₂ = system.η₂.\n\nInitialize the starting points, and confirm the data are entered correcly:\n\ninit_chain = initialize!(model)\nfig = Octofitter.rvpostplot(model, init_chain)\n\nSample from the model using MCMC (the no U-turn sampler)\n\n# Seed the random number generator\nusing Random\nrng = Random.Xoshiro(0)\n\nchain = octofit(\n    rng, model,\n    adaptation = 100,\n    iterations = 100,\n)\n\nFor real data, we would want to increase the adaptation and iterations to about 1000 each.\n\nPlot one sample from the results:\n\nfig = Octofitter.rvpostplot(model, chain) # saved to \"k2_132-rvpostplot.png\"\n\nPlot many samples from the results:\n\nfig = octoplot(\n    model,\n    chain,\n    # Some optional tweaks to the appearance:\n    N=50, # only plot 50 samples\n    figscale=1.5, # make it larger\n    alpha=0.05, # make each sample more transparent\n    colormap=\"#0072b2\",\n) # saved to \"k2_132-plot-grid.png\"\n\nCorner plot:\n\noctocorner(model, chain, small=true) # saved to \"k2_132-pairplot-small.png\"","category":"section"},{"location":"rv-gp/#Gaussian-Process-Fit-with-Celerite","page":"Gaussian Process","title":"Gaussian Process Fit with Celerite","text":"We now demonstrate an approximate quasi-static kernel implemented using Celerite.  For the class of kernels supported by Celerite, the performance scales much better with the number of data points. This makes it a good choice for modelling large RV datasets.\n\nwarning: Warning\nMake sure that you type using OctofitterRadialVelocity.Celerite and not using Celerite.  Celerite.jl does not support Julia 1.0+, so we currently bundle a fork that has been patched to work. When / if Celerite.jl is updated we will switch back to the public package.\n\nusing OctofitterRadialVelocity.Celerite\n\nrvlike_harps = StarAbsoluteRVObs(\n    rv_dat[rv_dat_raw.tel .== \"harps-n\",:],\n    name=\"harps-n\",\n    variables=(@variables begin\n        offset ~ Normal(-6693,100) # m/s\n        jitter ~ LogUniform(0.1,100) # m/s\n        # Add priors on GP kernel hyper-parameters.\n        B ~ Uniform(0.00001, 2000000)\n        C ~ Uniform(0.00001, 200)\n        L ~ Uniform(2, 200)\n        Prot ~ Uniform(8.5, 20)#Uniform(0, 20)\n    end),\n    gaussian_process = θ_obs -> Celerite.CeleriteGP(\n        Celerite.RealTerm(\n            #=log_a=# log(θ_obs.B*(1+θ_obs.C)/(2+θ_obs.C)),\n            #=log_c=# log(1/θ_obs.L)\n        ) + Celerite.ComplexTerm(\n            #=log_a=#  log(θ_obs.B/(2+θ_obs.C)),\n            #=log_b=#  -Inf,\n            #=log_c=#  log(1/θ_obs.L),\n            #=log_d=#  log(2pi/θ_obs.Prot)\n        )\n    )\n)\nrvlike_pfs = StarAbsoluteRVObs(\n    rv_dat[rv_dat_raw.tel .== \"pfs\",:],\n    name=\"pfs\",\n    variables=(@variables begin\n        offset ~ Normal(0,100) # m/s\n        jitter ~ LogUniform(0.1,100) # m/s\n        # Add priors on GP kernel hyper-parameters.\n        B ~ Uniform(0.00001, 2000000)\n        C ~ Uniform(0.00001, 200)\n        L ~ Uniform(2, 200)\n        Prot ~ Uniform(8.5, 20)#Uniform(0, 20)\n    end),\n    gaussian_process = θ_obs -> Celerite.CeleriteGP(\n        Celerite.RealTerm(\n            #=log_a=# log(θ_obs.B*(1+θ_obs.C)/(2+θ_obs.C)),\n            #=log_c=# log(1/θ_obs.L)\n        ) + Celerite.ComplexTerm(\n            #=log_a=#  log(θ_obs.B/(2+θ_obs.C)),\n            #=log_b=#  -Inf,\n            #=log_c=#  log(1/θ_obs.L),\n            #=log_d=#  log(2pi/θ_obs.Prot)\n        )\n    )\n)\n\n## No change to the rest of the model\n\nplanet_1 = Planet(\n    name=\"b\",\n    basis=RadialVelocityOrbit,\n    observations=[],\n    variables=@variables begin\n        e = 0\n        ω = 0.0\n        # To match RadVel, we set a prior on Period and calculate semi-major axis from it\n        P ~ truncated(\n            Normal(0.3693038/365.256360417, 0.0000091/365.256360417),\n            lower=0.0001\n        )\n        M = system.M\n        a = cbrt(M * P^2) # note the equals sign. \n        τ ~ UniformCircular(1.0)\n        tp = τ*P*365.256360417 + 57782 # reference epoch for τ. Choose an MJD date near your data.\n        # minimum planet mass [jupiter masses]. really m*sin(i)\n        mass ~ LogUniform(0.001, 10)\n    end\n)\n\nsys = System(\n    name = \"k2_132\",\n    companions=[planet_1],\n    observations=[rvlike_harps, rvlike_pfs],\n    variables=@variables begin\n        M ~ truncated(Normal(0.82, 0.02),lower=0.1) # (Baines & Armstrong 2011).\n    end\n)\n\nusing DifferentiationInterface\nusing FiniteDiff\nmodel = Octofitter.LogDensityModel(sys, autodiff=AutoFiniteDiff())\n\nThe Celerite implementation doesn't support our default autodiff-backend (ForwardDiff.jl), so we disable autodiff by setting it to finite differences, and then using the Pigeons slice sampler which doesn't require gradients or (B) use Enzyme autodiff, \n\nInitialize the starting points, and confirm the data are entered correcly:\n\ninit_chain = initialize!(model)\nfig = Octofitter.rvpostplot(model, init_chain)\n\nusing Pigeons\nchain, pt = octofit_pigeons(model, n_rounds=7)\nfig = Octofitter.rvpostplot(model, chain)","category":"section"},{"location":"python/#python","page":"Using Python","title":"Calling from Python","text":"This page provides some guidance on how Octofitter can be used from Python.  Our general recomendation is to download Julia and copy-paste the examples as needed, but there may be cases where it useful to embed Octofitter within a larger Python project or pipeline.\n\nIn those cases, you might consider using octofitterpy. This python package uses juliacall.py to make some Octofitter functionality available in python.\n\nBesides the model definition, most functions can be used the same in Python as in Julia. This notebook  provides some examples translated into Python.\n\nSee the octofitterpy site for installation instructions.","category":"section"},{"location":"#*Octofitter*","page":"Home","title":"Octofitter","text":"(Image: GitHub) (Image: Commit Activity) (Image: License) (Image: Stars)\n\nOctofitter is a Julia package for performing Bayesian inference  against a wide variety of exoplanet / binary star data. You can also use Octofitter from Python using the Python guide.\n\nwarning: Upgrading from v6?\nIf you're upgrading from Octofitter v6 or below, please see our Migration Guide\n\n(Image: )\n\nSupported data: Fit exoplanet orbits to\n\nrelative astrometry\nabsolute astrometry (Gaia or Hipparcos)\nabsolute radial velocity data (of a star)\nrelative radial velocity data (of a planet relative to a star)\nsample directly from images (also known as \"deorbiting\")\nsample directly from interferometric visibilities (NIRISS-AMI, or GRAVITY)\n\nYou can freely combine any of the above data types.  Any and all combinations work together.\n\nModelling features:\n\nmultiple planets (zero or more)\ngaussian processes (AbstractGPs or Celerite)\nhyperbolic orbits\nco-planar, and non-coplanar systems\narbitrary priors and parameterizations\noptional O'Neil \"observable based priors\"\nlink mass to photometry via atmosphere models\nhierarchical models (with a bit of work from the user)\nModel stellar activity with Gaussian processes\n\nSpeed:\n\nFit astrometry on your laptop in seconds!\n\nHighly optimized code and derivatives are generated from your model\nHigher order sampler (No U-Turn sampler) which explores the parameter space very efficiently \nThe sampler is automatically warmed up using a variational approximation from the Pathfinder algorithm (Pathfinder.jl) \n\nSee also: the python libraries Orbitize!, orvara, and exoplanet.","category":"section"},{"location":"#Read-the-paper","page":"Home","title":"Read the paper","text":"In addition to these documentation and tutorial pages, you can read the paper published in the Astronomical Journal (open-access).","category":"section"},{"location":"#Attribution","page":"Home","title":"Attribution","text":"If you use Octofitter in your work, please cite Thompson et al:\n\n@article{Thompson_2023,\ndoi = {10.3847/1538-3881/acf5cc},\nurl = {https://dx.doi.org/10.3847/1538-3881/acf5cc},\nyear = {2023},\nmonth = {sep},\npublisher = {The American Astronomical Society},\nvolume = {166},\nnumber = {4},\npages = {164},\nauthor = {William Thompson and Jensen Lawrence and Dori Blakely and Christian Marois and Jason Wang and Mosé Giordano and Timothy Brandt and Doug Johnstone and Jean-Baptiste Ruffio and S. Mark Ammons and Katie A. Crotts and Clarissa R. Do Ó and Eileen C. Gonzales and Malena Rice},\ntitle = {Octofitter: Fast, Flexible, and Accurate Orbit Modeling to Detect Exoplanets},\njournal = {The Astronomical Journal},\n}\n\nIf you use Gaia parallaxes in your work, please cite Gaia DR3 Gaia Collaboration et al. 2023\nPlease cite the HMC sampler backend if you use octofit: Xu et al 2020\nPlease cite the Pigeons paper if you use octofit_pigeons.\nIf you use Hipparcos-GAIA proper motion anomaly, please cite Brandt 2021\nIf you use example data in one of the tutorials, please cite the sources listed\nIf you use one of the included functions for automatically retreiving data from a public dataset, eg HARPS RVBank, please cite the source as appropriate (it will be displayed in the terminal)\nIf you adopt the O'Neil et al. 2019 observable based priors, please cite O'Neil et al. 2019.\nIf you use RV phase folded plot, please consider citing Makie.jl Danisch & Krumbiegel, (2021).\nIf you use the pairplot/cornerplot functionality, please cite:\n\n@misc{Thompson2023,\n  author = {William Thompson},\n  title = {{PairPlots.jl} Beautiful and flexible visualizations of high dimensional data},\n  year = {2023},\n  howpublished = {\\url{https://sefffal.github.io/PairPlots.jl/dev}},\n}","category":"section"},{"location":"#Ready?","page":"Home","title":"Ready?","text":"Ready to get started? Follow our installation guide and then follow our first tutorial.","category":"section"},{"location":"kepler/#Kepler-Solver","page":"Kepler Solver","title":"Kepler Solver","text":"The heart of this package is being able to take a set of Keplerian elements and output relative positions, velocities, etc. For this, we use PlanetOrbits.jl which adopts the same conventions as Orbitize!.\n\nThe Kepler solver used to go from mean anomaly to eccentric anomaly is a tweaked version copied from AstroLib.jl.\n\nFrom AstroLib.jl:\n\nMany different numerical methods exist to solve Kepler's equation. This function implements the algorithm proposed in Markley (1995) Celestial Mechanics and Dynamical Astronomy, 63, 101 (DOI:10.1007/BF00691917). This method is not iterative, requires only four transcendental function evaluations, and has been proved to be fast and efficient over the entire range of elliptic motion 0≤e≤10.\n\nOn my laptop, this solves for a single eccentric anomaly in just 47 ns. Since it is implemented in pure Julia, there is no overhead from calling into a C or Cython compiled function and no need for vectorization.","category":"section"},{"location":"chains/#chains","page":"Chains","title":"Chains","text":"This page describes the format of the Monte Carlo chains created by Octofitter.jl\n\nThe output of the samplers in Octofitter is an MCMCChains.Chains object\n\nA column will be present for each variable in your model, both defined in the Priors blocks or as Derived variables. \n\nVariables defined for the System as a whole can be accessed directly. For example:\n\nchain[\"M\"]\n\nThis will return an array of μ values from the posterior. The format is a matrix of N-samples by N-walkers.\n\nVariables defined for an individual Planet are grouped according to the standard MCMCChains format. For example:\n\nchain[\"b_a\"]\n\nThis returns an array of semi-major axis values (a) for the planet b sampled from the posterior.","category":"section"},{"location":"chains/#Diagnostics","page":"Chains","title":"Diagnostics","text":"Printing the chains will display a number of useful summaries for each quantity, like the mean, 0.25, 0.5, and 0.75 quantiles, and convergence metrics. See MCMCChains documentation for more details.","category":"section"},{"location":"chains/#Exporting-Chains","page":"Chains","title":"Exporting Chains","text":"There are two useful ways to export chains. One is with the JLD2 library which preserves all the information and structure of the chain (but is only easy to open again in Julia) and the other is converting them to tables.","category":"section"},{"location":"chains/#As-a-table","page":"Chains","title":"As a table","text":"You can convert your chains to any Tables.jl compatible table. TypedTables.Table is included with this package, but DataFrames.DataFrame works well too.\n\ntbl = Table(chain)\n\nusing DataFrames\ndf = DataFrame(chain)\n\nYou can then use a wide variety of Tables.jl source or sink libraries to persist your data to a file or database. The easiest is probably Arrow.jl:\n\nArrow.write(\"mychain.csv\", tbl)\n\nOther useful formats could be CSV.jl or SQLite.jl. In these formats, the data can be archived and imported easily into other programs; however, there is not yet an automatic way to return the data into the MCMCChains.Chains format it originated in.","category":"section"},{"location":"post-pred/#Posterior-Predictive-Checks","page":"Posterior Predictive Checks","title":"Posterior Predictive Checks","text":"A posterior predictive check compares our true data with simulated data drawn from the posterior. This allows us to evaluate if the model is able to reproduce our observations appropriately. Samples drawn from the posterior predictive distribution should match the locations of the original data.\n\nTo demonstrate, we will fit a model to relative astrometry data:\n\nusing Octofitter\nusing Distributions\n\nastrom_dat = Table(\n    epoch= [50000,50120,50240,50360,50480,50600,50720,50840,],\n    ra = [-505.764,-502.57,-498.209,-492.678,-485.977,-478.11,-469.08,-458.896,],\n    dec = [-66.9298,-37.4722,-7.92755,21.6356, 51.1472, 80.5359, 109.729, 138.651,],\n    σ_ra = fill(10.0, 8),\n    σ_dec = fill(10.0, 8),\n    cor = fill(0.0, 8)\n)\nastrom_obs = PlanetRelAstromObs(astrom_dat, name=\"simulated astrom\")\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[astrom_obs],\n    variables=@variables begin\n        a ~ truncated(Normal(10, 4), lower=0.1, upper=100)\n        e ~ Uniform(0.0, 0.5)\n        i ~ Sine()\n        ω ~ UniformCircular()\n        Ω ~ UniformCircular()\n        θ ~ UniformCircular()\n        tp = θ_at_epoch_to_tperi(θ,50420; system.M, a, e, i, ω, Ω)  # reference epoch for θ. Choose an MJD date near your data.\n    end\n)\n\nsys = System(\n    name=\"Tutoria\",\n    companions=[planet_b],\n    observations=[],\n    variables=@variables begin\n        M ~ truncated(Normal(1.2, 0.1), lower=0.1)\n        plx ~ truncated(Normal(50.0, 0.02), lower=0.1)\n    end\n)\n\nmodel = Octofitter.LogDensityModel(sys)\n\nusing Random\nRandom.seed!(0)\nchain = octofit(model)\n\nWe now have our posterior as approximated by the MCMC chain. Convert these posterior samples into orbit objects:\n\n# Instead of creating orbit objects for all rows in the chain, just pick\n# every twentieth row.\nii = 1:20:1000\norbits = Octofitter.construct_elements(model, chain, :b, ii)\n\nCalculate and plot the location the planet would be at each observation epoch:\n\nusing CairoMakie \n\nepochs = astrom_obs.table.epoch' # transpose\n\nx = raoff.(orbits, epochs)[:]\ny = decoff.(orbits, epochs)[:]\n\nfig = Figure()\nax = Axis(\n    fig[1,1], xlabel=\"ra offset [mas]\", ylabel=\"dec offset [mas]\",\n    xreversed=true,\n    aspect=1\n)\nfor orbit in orbits\n    Makie.lines!(ax, orbit, color=:lightgrey)\nend\n\nMakie.scatter!(\n    ax,\n    x, y,\n    markersize=3,\n)\nfig\n\nMakie.scatter!(ax, astrom_obs.table.ra, astrom_obs.table.dec,color=:black, label=\"observed\")\nMakie.scatter!(ax, [0],[0], marker='⋆', color=:black, markersize=20,label=\"\")\nMakie.xlims!(400,-700)\nMakie.ylims!(-200,200)\nfig\n\n\nLooks like a great match to the data! Notice how the uncertainty around the middle point is lower than the ends. That's because the orbit's posterior location at that epoch is also constrained by the surrounding data points. We can know the location of the planet in hindsight better than we could measure it!\n\nYou can follow this same procedure for any kind of data modelled with Octofitter.","category":"section"},{"location":"sbc/#Simulation-Based-Calibration-(@id-sbc)","page":"Simulation Based Calibration","title":"Simulation Based Calibration (@id sbc)","text":"Simulation based calibration Talts et al. 2020 is a way to test the correctness and accuracy of a Bayesian model. \n\nIt works by repeatedly generating simulated data from a model's priors, running inference, and examining the posterior.  The result is a histogram that indicates if there is a net bias in the sampling procedure. An unbiased procedure & good model will result in flat histograms for each parameter.\n\nHere is a worked example of performing simulated based calibration with an Octofitter model.\n\nNote that this will not work well for models with very unconstrained priors on mass or semi-major axis / period. For example, if semi-major axis is set to a prior of LogUniform(0.0001, 10000) AU then many simulated systems will have planets unreasonably far or close the star and the uncertainties and epochs of observations will not make sense. Actually, this reveals that these models are not all that reasonable: usually we do have fore-knowledge about the planet's semi-major axis etc. before we run any fits just because we detected it! \n\nWe split this example in three parts: a model definition, a trial script that we run many times, and an analysis script that summarizes the results.","category":"section"},{"location":"sbc/#Octofitter-Model-Template-Script","page":"Simulation Based Calibration","title":"Octofitter Model Template Script","text":"This script defines the model we will be analyzing. The data likelihood we provide could be our real observations, or just arbitrary (even zero). The key parts are the epochs of the observations, number of observations, and uncertainties of the observations. The actual measured values will be repeatedly replaced by simulated values using Octofitter's generative models.\n\nWe will assume you have saved this as sbc-model.jl.\n\nusing Octofitter, Distributions\n\nastrom_obs = PlanetRelAstromObs(\n    (epoch=50000, ra=0.0, dec=0.0, σ_ra=10., σ_dec=10., cor=0),\n    (epoch=50120, ra=0.0, dec=0.0, σ_ra=10., σ_dec=10., cor=0),\n    (epoch=50240, ra=0.0, dec=0.0, σ_ra=10., σ_dec=10., cor=0),\n    (epoch=50360, ra=0.0, dec=0.0, σ_ra=10., σ_dec=10., cor=0),\n    (epoch=50480, ra=0.0, dec=0.0, σ_ra=10., σ_dec=10., cor=0),\n    (epoch=50600, ra=0.0, dec=0.0, σ_ra=10., σ_dec=10., cor=0),\n    (epoch=50720, ra=0.0, dec=0.0, σ_ra=10., σ_dec=10., cor=0),\n    (epoch=50840, ra=0.0, dec=0.0, σ_ra=10., σ_dec=10., cor=0),\n)\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[astrom_obs],\n    variables=@variables begin\n        M = system.M\n        a ~ truncated(Normal(10, 4), lower=0.1, upper=100)\n        e ~ Uniform(0.0, 0.5)\n        i ~ Sine()\n        ω ~ UniformCircular()\n        Ω ~ UniformCircular()\n        τ ~ UniformCircular(1.0)\n        P = √(a^3/M)\n        tp = τ*P*365.25 + 50420 # reference epoch for τ. Choose an MJD date near your data.\n    end\n)\n\nSBC = System(\n    name=\"SBC\",\n    companions=[planet_b],\n    observations=[],\n    variables=@variables begin\n        M ~ truncated(Normal(1.2, 0.1), lower=0.1)\n        plx ~ truncated(Normal(50.0, 0.02), lower=0.1)\n    end\n)\nmodel = Octofitter.LogDensityModel(SBC)","category":"section"},{"location":"sbc/#SBC-Trial-Script","page":"Simulation Based Calibration","title":"SBC Trial Script","text":"This script runs a single SBC trial. If you name it sbc-trial.jl,  then you can run it as julia sbc-trial.jl trial_num where trial_num is a unique number to identify this trial. You would then run this script many times (say, 100+). You could run these trials on a compute cluster if desired.\n\nusing Octofitter, Distributions, PlanetOrbits\nusing Printf\n\ninclude(\"sbc-model.jl\")\n\nsbc_index = parse(Int, ARGS[1])\n\n\n@info \"Running SBC trial $sbc_index\"\noutname = @sprintf(\"sbctest-%04d\", sbc_index)\n\n\n# Seed reproducibly from the index of this trial\nusing Random\nrng = Random.Xoshiro(sbc_index)\n\n# Sample system parameters from priors\nθ_system_flat = model.sample_priors(rng)\n\nsettings = (;\n    # Sampler parameters if desired:\n    # :target_accept=>0.95,\n    # :adaptation=>5000,\n    # :iterations=>5000,\n    # :tree_depth=>13,\n    # :verbosity=>2,\n\n    # Model parameter values\n    θ = θ_system_flat\n)\n\nOctofitter.sbctrial(model.system, settings, outname);\nprintln(\"done $sbc_index\")","category":"section"},{"location":"sbc/#SBC-Analysis-Script","page":"Simulation Based Calibration","title":"SBC Analysis Script","text":"using Octofitter\nusing DataFrames\nusing MCMCChains\nusing TOML\nusing CairoMakie\n\n\n\n# These are the variables we would like to examine\nvars = [\n    :b_a,\n    :b_i,\n    :b_e,\n    :b_Ω,\n    :b_ω,\n    :b_τ,\n    :M,\n    :plx,\n]\n\n# Load statistics from each trial\n\n# Get list of trials\nrankfnames = filter(endswith(\"rank_stats.toml\"), readdir())\nchainnames = filter(endswith(\"chains.fits\"), readdir())\n\n# Check RHat convergence criteria of each posterior.\nii = findall(map(eachindex(chainnames)) do i\n    chainfname = chainnames[i]\n    chn = Octofitter.loadchain(chainfname)\n    rhats = MCMCChains.rhat(chn)[vars][:,2]\n    passed = maximum(abs, 1 .- rhats) .< 0.2\n    if !passed \n        @warn \"Trial $(chainnames[i]) skipped due to poor convergence\"\n    end\n    return passed\nend)\n\n# gather rank statistics\nranks = DataFrame(map(rankfnames[ii]) do rankfname\n    NamedTuple(Symbol(k)=>float(v) for (k,v) in TOML.parsefile(rankfname))\nend)\n\n# How many bins per histogram\nnbins=floor(Int, sqrt(length(ii)))\n\n# How many columns for figure\ncols = 4\n\n\n\nfig = Figure(\n    size=(225cols,200cld(length(vars),cols))\n)\n\n\nfor i in eachindex(vars)\n    col = mod1(i,cols)\n    row = fld1(i,cols)\n    ax = Axis(\n        fig[row,col];\n        xlabel=\"rank\",\n        ylabel=\"counts\",\n        title=string(vars[i]),\n        xgridvisible=false,\n        ygridvisible=false,\n        yaxisposition= col < cols ? :left : :right\n    )\n    # nbins=25\n    xlims!(ax, 0, 100)\n    bin_edges = range(start=0,stop=100+0.001,length=nbins)#.*10\n    hist!(ax, getproperty(ranks, vars[i]), bins=bin_edges, color=Makie.wong_colors()[2])\n    expected = size(ranks,1)/nbins\n    p = Poisson(expected)\n    hspan!(ax,\n        quantile(p, [0.02,0.98])...,\n        color=(:black,0.15)\n    )\n    ylims!(ax, low=0, high=quantile(p, 0.999))\n\n    row == 1 && Makie.hidexdecorations!(ax)\n    1 < col < cols && Makie.hideydecorations!(ax)\nend\nMakie.colgap!.((fig.layout,), 1:(cols-1), 30.0)\nsave(\"sbc-summary.png\", fig)\nsave(\"sbc-summary.pdf\", fig)\nsave(\"sbc-summary.svg\", fig)\nfig\n\n(Image: )\n\nFor a perfectly unbiased model & sampling algorith, the histogram bins should be flat to within about the ±1σ shaded expected region.\n\nIn this example and model, see that the inclination parameter estimates are under confident. That is, on average the computed marginal posterior of the inclination parameter is slightly too wide and the true uncertainty is lower.","category":"section"},{"location":"compat-orbitize/#Compatibility-with-Orbitize!","page":"Orbitize! Compatibility","title":"Compatibility with Orbitize!","text":"The Orbitize! python library is a popular package for fitting astrometric and radial velocity orbits.\n\nOctofitter has support for loading and saving posteriors in HDF5 format–the same format used by Orbitize!. This is useful if you want to load an Orbitize! posterior into Octofitter for plotting or to compare results. Similarily, you can export Octofitter chains to use with Orbitize! analysis tools, including the popular whereistheplanet.com website for predicting planet locations from stored posteriors.\n\nwarning: Warning\nThe Orbitize! import/export functionality only works with simple models with visual orbits and only one companion.\n\nIn addition, it is possible to load a orbit posterior and/or astrometry data directly from whereistheplanet.com by target name.","category":"section"},{"location":"compat-orbitize/#Loading-an-Orbitize!-posterior","page":"Orbitize! Compatibility","title":"Loading an Orbitize! posterior","text":"chain = Octofitter.loadhdf5(\"fname.h5\")","category":"section"},{"location":"compat-orbitize/#Save-a-posterior-in-Orbitize!-format","page":"Orbitize! Compatibility","title":"Save a posterior in Orbitize! format","text":"Octofitter.savehdf5(\"fname.h5\", model, chain)","category":"section"},{"location":"compat-orbitize/#Loading-an-Orbitize!-posterior-saved-to-Whereistheplanet.com","page":"Orbitize! Compatibility","title":"Loading an Orbitize! posterior saved to Whereistheplanet.com","text":"chain = Octofitter.loadhdf5(\"51erib\",)","category":"section"},{"location":"compat-orbitize/#Loading-Astrometry-Data-saved-to-Whereistheplanet.com","page":"Orbitize! Compatibility","title":"Loading Astrometry Data saved to Whereistheplanet.com","text":"astrom_obs1, astro_obs2 = Octofitter.Whereistheplanet_astrom(\"51erib\"; object=1)\n\nTwo different astrometry likelihood objects are returned since orbitize supports both PA/sep and RA/DEC formats. Octofitter also supports both formats, but they must be placed into separate likelihood objects. Simply add both to the model to include all data.","category":"section"},{"location":"extract-phot-astrom/#Extracting-Traditional-Photometry-and-Astrometry","page":"Extract Astrom. and Photometry","title":"Extracting Traditional Photometry and Astrometry","text":"Though not its primary purpose, you can use Octofitter to extract traditional astrometry and photometry from one or more images. This uses the functionality in the Fit Orbits to Images tutorial, but with a much simpler model. \n\nInstead of fitting an entire orbit, we will simply fit an X / Y position and brightness.\n\nStart by loading your images:\n\nusing Octofitter\nusing OctofitterImages\nusing Distributions\nusing Pigeons\nusing AstroImages\nusing CairoMakie\n\n# Load individual iamges\n# image1 = load(\"image1.fits\")\n# image2 = load(\"image2.fits\")\n\n# Or slices from a cube:\n# cube = load(\"cube1.fits\")\n# image1 = cube[:,:,1] \n\n# Download sample images from GitHub\ndownload(\n    \"https://zenodo.org/records/6823071/files/HR8799.2021.fits?download=1\",\n    \"HR8799-2021.fits\"\n)\n\n# Or multi-extension FITS (this example)\nimage = AstroImages.load(\"HR8799-2021.fits\")\n\nYou can preview the image using imview from AstroImages:\n\nimview(image)\n\nNote that to accurately extract astrometry and photometry, the input image should have already been convolved with the star or planet point spread function. If this isn't available, a convolution by a Gaussian or Airy disk might be an acceptable approximation.","category":"section"},{"location":"extract-phot-astrom/#Build-the-model","page":"Extract Astrom. and Photometry","title":"Build the model","text":"First, we create a table of our image data that will be attached to the Planet:\n\nimglike = ImageObs(\n    Table(\n        image=[AstroImages.recenter(image)],\n        platescale=[9.971],\n        epoch=[mjd(\"2021\")]\n    ),\n    variables=@variables begin\n        # Planet flux in image units -- could be contrast, mags, Jy, or arb. as long as it's consistent with the units of the data you provide\n        flux ~ Uniform(0, 1)\n        # The following are optional parameters for marginalizing over instrument systematics:\n        # Platescale uncertainty multiplier [could use: platescale ~ truncated(Normal(1, 0.01), lower=0)]\n        platescale = 1.0\n        # North angle offset in radians [could use: northangle ~ Normal(0, deg2rad(1))]\n        northangle = 0.0\n    end\n)\n\nNote that you can also supply a contrast curve or map directly. If not provided, a simple contrast curve will be calculated directly from the data.\n\nNext create the simplest possible model of 2D position, plus a contrast variable matching the band name used in the ImageObs above:\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{Octofitter.FixedPosition},\n    observations=[imglike],\n    variables=@variables begin\n        sep ~ Uniform(0, 2000)\n        pa ~ Uniform(0,2pi)\n        # Contrast ratio\n    end\n)\n\nsys = System(\n    name=\"sys\",\n    companions=[planet_b],\n    observations=[],\n    variables=@variables begin\n        plx = 24.4620\n    end\n)\n\nmodel = Octofitter.LogDensityModel(sys, verbosity=4)","category":"section"},{"location":"extract-phot-astrom/#Sample-from-the-model-(locally)","page":"Extract Astrom. and Photometry","title":"Sample from the model (locally)","text":"If you already know where the planet is and you only want to extract astrometry from that known location, you can specify a starting point and use hamiltonian monte carlo as follows. This will be very very fast.\n\ninitialize!(model, (;\n    planets=(;\n        b=(;\n            sep=1704,\n            pa=deg2rad(70.63),\n        )\n    )\n))\nchain = octofit(model, iterations=10000)","category":"section"},{"location":"extract-phot-astrom/#Sample-from-the-model-(globally)","page":"Extract Astrom. and Photometry","title":"Sample from the model (globally)","text":"You could also try sampling across the entire image, without necessarily specifying a starting position. Note that if there are multiple candidates, taking the naive mean and standard deviation will average across all planets.\n\nusing Pigeons\ninitialize!(model)\nchain, pt = octofit_pigeons(model, n_rounds=11)","category":"section"},{"location":"extract-phot-astrom/#Access-results","page":"Extract Astrom. and Photometry","title":"Access results","text":"samples_sep = chain[:b_sep]\nsamples_pa = chain[:b_pa]\nprintln(\"The median separation is \", median(samples_sep))\n\nflux = chain[:b_images_flux]\nprintln(\"The flux is \", mean(flux), \" ± \", std(flux))\nprintln(\"The \\\"SNR\\\" is \", mean(flux)/std(flux))","category":"section"},{"location":"extract-phot-astrom/#Visualize","page":"Extract Astrom. and Photometry","title":"Visualize","text":"using CairoMakie, PairPlots\noctocorner(model,chain)","category":"section"},{"location":"faq/#Frequently-Asked-Questions","page":"FAQ","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"faq/#How-do-we-calculate-the-position-of-a-planet-at-a-future-epoch?","page":"FAQ","title":"How do we calculate the position of a planet at a future epoch?","text":"After fitting an orbit, there are two ways to calculate its projected position in the sky at a future epoch.\n\nOption 1\n\nThe easiest way to get a report on the planet's future position is via octoplot\n\noctoplot(model, chain, mark_epochs_mjd=[\n    mjd(\"2028-01-01\"),\n    mjd(\"2029-01-01\"),\n    # etc\n])\n\nThis will add a scatter point at the dates you requested and output a summary to the terminal. You can also control the alpha and number of orbits plotted. Something like this: octoplot(model, chain, mark_epochs_mjd=[mjd(\"2025-01-01\"), mjd(\"2027-01-01\")], N=100, alpha=1.0)\n\nOption 2\n\nThe other is to calculate the positions yourself and plot them however you like.\n\nels = Octofitter.construct_elements(model, chain, :b, :)\n\nWhere :b is the name of the planet you chose, and : means all draws from the chain (you can also pass a particular iteration number of range of numbers). Then, you can solve keplers equation and plot whatever you want:\n\nsols = orbitsolve.(els, mjd(\"2025-01-01\"))\n\n# projected position in mas\nX = raoff.(sols)\nY = decoff.(sols)\n\nProj_sep_mas = projectedseparation.(sols)\nPA_rad = posangle.(sols)\n\n# 3D position in AU\nZ_au = posz.(sols)\nX_au = posx.(sols)\n\n# relative RV between star and companion\nRel_rv = radvel.(sols)\n\nAnd so on. You can also query these values for the star. Then, you can plot them however you like, Eg.\n\nscatter(X, Y, axis=(;xlabel=\"delta ra mas\", autolimitaspect=1.0, xreversed = true))","category":"section"},{"location":"faq/#Can-slope/GP-parameters-be-shared-between-RV-instruments?","page":"FAQ","title":"Can slope/GP parameters be shared between RV instruments?","text":"You can share instrument parameters such as linear our quadratic terms between instruments by defining the variables at the system level, and forwarding them to each instrument's @variables block (see <--- arrows):\n\n# Instrument 1 likelihood\nrvlike_apf = StarAbsoluteRVObs(\n    rv_dat_apf,\n    name=\"APF\",\n\n    # Linear trend\n    trend_function = (θ_obs, epoch) -> θ_obs.trend_slope * (epoch - 57000),\n    \n    variables=@variables begin\n        offset = 0\n        jitter ~ LogUniform(0.1,30) # m/s\n        trend_slope = system.trend_slope  # <-----  \n    end\n)\n# Instrument 2 likelihood\nrvlike_hires = StarAbsoluteRVObs(\n    rv_dat_hires,\n    name=\"HIRES\",\n    \n    # Linear trend:\n    trend_function = (θ_obs, epoch) -> θ_obs.trend_slope * (epoch - 57000), \n    \n    variables=@variables begin\n        offset = 0\n        jitter ~ LogUniform(0.1,30) # m/s\n        trend_slope = system.trend_slope  # <-----  \n    end\n)\nsys = System(\n    name = \"Star1\",\n    companions=[planet_1],\n    observations=[rvlike_apf, rvlike_hires],\n    variables=@variables begin\n        M ~ truncated(Normal(1.5, 0.06),lower=0.1, upper=10)\n\n        trend_slope ~ Uniform(-1,1)  # <-----  \n    end\n)","category":"section"},{"location":"faq/#What-Coordinate-System-does-Octofitter-use?","page":"FAQ","title":"What Coordinate System does Octofitter use?","text":"Octofitter uses a coordinate system where\n\n+x\nincreases to the East (ie, x increases with increasing Right Ascension)\n+y\nincreases to the North\n+z\nincreases away from the observer.\n\nThis coordinate system has several nice properties: +x increases with Right Ascension, +y increases with Declination, and fracpartial zpartial t is positive for positive radial velocity / positive redshift. Note! Since x increases with Right Ascension, that means +X is towards the left in the sky, and in most plots. If this bothers you, one thing to note is that it's also in the direction of increasing \"time\" as the sky rotates overhead AND this convention predates the modern concept of a cartesian graph :-) \n\nYou can read more in the PlanetOrbits.jl docs.","category":"section"},{"location":"faq/#What-is-the-definition-of-\\omega?","page":"FAQ","title":"What is the definition of omega?","text":"omega\n\nis the argument of periastron, which is the location where the planet makes its closest approach to the star, measured from the ascending node. This is consistent with most direct imaging conventions. \n\nNote: this is 180° offset from the typical definition used by codes that only fit radial velocity and/or transit, where the convention it to report the argument of periastron for the star. This is a significant potential source of confusion when comparing results between codes.","category":"section"},{"location":"faq/#What-is-the-definition-of-\\Omega?","page":"FAQ","title":"What is the definition of Omega?","text":"Omega\n\nis the position angle of ascending node, also known as the longitude of ascending node. It is the point in an orbit where the planet (or equivalently, the star) moves from having a negative z coordinate to having a positive z coordinate. This happens where the planet (or star) moves cross the plane of the sky going away from the observer.  Why \"away\" from the observer? That is because Octofitter uses a coordinate system where +z increases away from the observer, such that radial velocity measured as a positive redshift corresponds to a positive velocity.","category":"section"},{"location":"rv/#fit-rv-pma","page":"RV and Proper Motion Anomaly","title":"Fit RV and Proper Motion Anomaly","text":"In this example, we will fit an orbit model to a combination of radial velocity and Hipparcos-GAIA proper motion anomaly for the star epsilon Eridani. We will use some of the radial velocity data collated in Mawet et al 2019.\n\nnote: Note\nRadial velocity modelling is supported in Octofitter via the extension package OctofitterRadialVelocity. To install it, run  pkg> add OctofitterRadialVelocity\n\nDatasets from two different radial velocity insturments are included and modelled together with separate jitters and instrumental offsets.\n\n\n\nusing Octofitter, OctofitterRadialVelocity, Distributions, PlanetOrbits, CairoMakie\n\ngaia_id = 5164707970261890560 \n\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[], # No planet astrometry is included since it has not yet been directly detected\n    variables=@variables begin\n        # For speed of example, we are fitting a circular orbit only.\n        e = 0\n        ω = 0.0\n        mass ~ Uniform(0, 3)\n        a ~ Uniform(3, 10)\n        i ~ Sine()\n        Ω ~ Uniform(0, 2pi)\n        M = system.M\n        τ ~ Uniform(0, 1.0)\n        P = √(a^3/M)\n        tp = τ*P*365.25 + 58849 # reference epoch for τ. Choose an MJD date near your data.\n    end\n)\n\n\n# We will load in data from one RV instruments.\n# We use `MarginalizedStarAbsoluteRVObs` instead of \n# `StarAbsoluteRVObs` to automatically marginalize out\n# the radial velocity zero point of each instrument, saving one parameter.\nhires_data = OctofitterRadialVelocity.HIRES_rvs(\"HD22049\")\nrvlike_hires = MarginalizedStarAbsoluteRVObs(\n    hires_data,\n    name=\"HIRES\",\n    variables=@variables begin\n        jitter ~ LogUniform(0.1, 100) # m/s\n    end\n)\n\nWe load the HGCA data for this target:\n\nhgca_obs = HGCAInstantaneousObs(\n    gaia_id=gaia_id,\n    variables=@variables begin\n        # Optional: flux ratio for luminous companions\n        # fluxratio ~ Product([Uniform(0, 1), Uniform(0, 1), ])  # uncomment if needed for unresolved companions\n    end\n)\n\nIn the interests of time, we use the HGCAInstantaneousObs approximation to speed up the computation. This parameter controls how the model smears out the simulated Gaia and Hipparcos measurements in time. For a real target, leave it at the default value once you have completed testing.\n\nsys = System(\n    name=\"ϵEri\",\n    companions=[planet_b],\n    observations=[hgca_obs, rvlike_hires],\n    variables=@variables begin\n        M ~ truncated(Normal(0.82, 0.02),lower=0.5, upper=1.5) # (Baines & Armstrong 2011).\n        plx ~ gaia_plx(;gaia_id)\n        pmra ~ Normal(-975, 10)\n        pmdec ~ Normal(20,  10)\n    end\n)\n# Build model\nmodel = Octofitter.LogDensityModel(sys)\n\nFind good starting points and visualize the starting position + data:\n\ninit_chain = initialize!(model)\noctoplot(model, init_chain, show_mass=true)\n\nNow sample. You could use HMC via octofit or tempered sampling via octofit_pigeons. When using tempered sampling, make sure to start julia with julia --thread=auto. Each additional round doubles the number of posterior samples, so n_rounds=10 gives 1024 samples. You should adjust n_chains to be roughly double the Λ value printed out during sample, and n_chains_variational to be roughly double the Λ_var column. \n\nusing Pigeons\nresults, pt = octofit_pigeons(model, n_rounds=10, n_chains=10, n_chains_variational=0, explorer=SliceSampler());\nnothing # hide\n\nWe can now plot the results with a multi-panel plot:\n\noctoplot(model, results, show_mass=true)\n\nWe can also plot just the RV curve from the maximum a-posteriori fit:\n\nfig = Octofitter.rvpostplot(model, results)\n\nWe can see what the visual orbit looks like for the maximum a-posteriori sample (note, we would need to run an optimizer to get the true MAP value; this is just the MCMC sample with higest posterior density):\n\ni_max = argmax(results[:logpost][:])\nfig = octoplot(\n    model,\n    results[i_max,:,:],\n    # change the colour map a bit:\n    colormap=Makie.cgrad([Makie.wong_colors()[1], \"#FAFAFA\"]),\n    show_astrom=true,\n    show_astrom_time=false,\n    show_rv=false,\n    show_pma=false,\n    mark_epochs_mjd=[\n        mjd(\"2037\")\n    ]\n)\nLabel(fig[0,1], \"Maximum a-posteriori orbit sample\")\nMakie.resize_to_layout!(fig)\nfig\n\nAnd a corner plot:\n\nusing CairoMakie, PairPlots\noctocorner(model, results, small=true)","category":"section"},{"location":"cross-validation/#Cross-Validation","page":"Cross Validation","title":"Cross-Validation","text":"note: Note\nThis tutorial is currently a stub and will be expanded in future. In the meantime, if you have questions please open an issue on GitHub.","category":"section"},{"location":"cross-validation/#Calculating-Pointwise-Likelihoods","page":"Cross Validation","title":"Calculating Pointwise Likelihoods","text":"After you have defined a model and sampled from its posterior (eg. via octofit), you can see how each datapoint is influencing the posterior via the following functions.\n\n# already have defined `model` and `chain` ...\n\nlikelihood_mat = Octofitter.pointwise_obs(model, chain)\n\nlikelihood_mat is now a Nsample x Ndata matrix. \n\nnote: Note\nThe columns are ordered the same as how the data are defined in the model.\n\nwarning: Warning\nYou may see a few additional entries you didn't expect. Each UniformCircular and ObsPriorAstromONeil2019 adds an additional likelihood object under the hood.","category":"section"},{"location":"cross-validation/#Pareto-Smoothed-Importance-Sampling","page":"Cross Validation","title":"Pareto-Smoothed Importance Sampling","text":"After you have generated the likelihood_mat you can use the Julia package ParetoSmooth.jl to efficiently calculate a leave-one-out cross-validataion score. This technique takes a single posterior chain and, using the pointwise likelihoods, generates N_datapoints new chains where each chain is adjusted as if that datapoint was held out from the model. \n\nIn broad terms, one might say that this test verifies that no individual datapoints are overly skewing the results.\n\nusing ParetoSmooth\nresult = psis_loo(\n    collect(likelihood_mat'),\n    chain_index=ones(Int,size(chain,1))\n)\n\nPlot like so:\n\nusing CairoMakie\n\nfig = Figure()\n\nax = Axis(\n    fig[1,1],\n    xlabel=\"data #\",\n    ylabel=\"Pareto K\"\n)\nscatter!(ax, result.pointwise(:pareto_k))\n\n\nax = Axis(\n    fig[2,1],\n    xlabel=\"data #\",\n    ylabel=\"MCSE\"\n)\nscatter!(ax, result.pointwise(:mcse))\n\n\nax = Axis(\n    fig[3,1],\n    xlabel=\"data #\",\n    ylabel=\"P_EFF\"\n)\nscatter!(ax, result.pointwise(:p_eff))\n\n\nfig","category":"section"},{"location":"dev/architecture/#Architecture-Overview","page":"Architecture Overview","title":"Architecture Overview","text":"This document provides an overview of Octofitter's internal architecture, focusing on how user model specifications are transformed into efficient log prior and log likelihood functions for Bayesian inference.","category":"section"},{"location":"dev/architecture/#High-Level-Flow","page":"Architecture Overview","title":"High-Level Flow","text":"flowchart TD\n    A[User Model Specification] --> B[@variables macro]\n    B --> C[Priors, Derived, UserLikelihoods]\n    C --> D[Planet & System Objects]\n    D --> E[LogDensityModel Construction]\n\n    E --> F[Generated Functions]\n    F --> F1[sample_priors]\n    F --> F2[arr2nt]\n    F --> F3[ln_prior_transformed]\n    F --> F4[ln_like_generated]\n    F --> F5[Bijector_invlinkvec/linkvec]\n\n    F1 & F2 & F3 & F4 & F5 --> G[ℓπcallback & ∇ℓπcallback]\n    G --> H[Sampler: HMC, NUTS, etc.]\n\n    H --> I[θ_transformed]\n    I --> J[Bijector_invlinkvec]\n    J --> K[θ_natural]\n    K --> L[arr2nt]\n    L --> M[θ_nested: NamedTuple]\n    M --> N[log_prior + log_likelihood]\n    N --> O[log_posterior]\n\n    style E fill:#e1f5ff\n    style F fill:#fff4e1\n    style G fill:#e8f5e9\n    style M fill:#fce4ec","category":"section"},{"location":"dev/architecture/#1.-Model-Definition-Layer","page":"Architecture Overview","title":"1. Model Definition Layer","text":"","category":"section"},{"location":"dev/architecture/#The-@variables-Macro","page":"Architecture Overview","title":"The @variables Macro","text":"Location: src/macros.jl, src/variables.jl\n\nThe @variables macro is Octofitter's PPL interface. It parses variable definitions into prior distributions and derived variables:\n\n@variables begin\n    a ~ Uniform(0, 10)      # Prior distribution\n    e ~ Beta(1, 2)          # Prior distribution\n    mass = a^2 * e          # Derived variable\n    Normal(0,1) ~ a + e     # User likelihood constraint\nend\n\nOutput: A tuple (Priors, Derived, [UserLikelihood...]) where:\n\nPriors: Contains an OrderedDict{Symbol,Distribution} of random variables\nDerived: Contains expressions for computed variables plus captured constants (via $variable interpolation)\nUserLikelihood: Optional distribution constraints on expressions","category":"section"},{"location":"dev/architecture/#Special-Parameterizations","page":"Architecture Overview","title":"Special Parameterizations","text":"Certain parameterizations expand into multiple variables. For example, UniformCircular() for angles:\n\nΩ ~ UniformCircular()\n\nExpands to:\n\nΩx ~ Normal(0, 1)        # Priors\nΩy ~ Normal(0, 1)        # Priors\nΩ = atan(Ωy, Ωx)         # Derived variable\n# Plus a UnitLengthPrior likelihood to prevent pinching at origin\n\nThis ensures uniform sampling on the circle while avoiding the pinching problem at the origin that would occur with direct uniform angle sampling.","category":"section"},{"location":"dev/architecture/#Model-Hierarchy","page":"Architecture Overview","title":"Model Hierarchy","text":"System(\n    name=:HD82134,\n    variables=@variables begin\n        M ~ Normal(1.0, 0.1)\n        plx ~ Normal(50.0, 0.02)\n    end,\n    companions=[planet_b, planet_c],\n    likelihoods=[hgca_likelihood, gaia_likelihood]\n)\n\nStructure:\n\nSystem: System-level priors, derived variables, observations, and companion objects\nPlanet: Planet-level priors, derived variables, and observations\nEach can have attached AbstractLikelihood objects representing observational data","category":"section"},{"location":"dev/architecture/#2.-The-arr2nt-Transformation","page":"Architecture Overview","title":"2. The arr2nt Transformation","text":"Location: src/variables.jl:600-902","category":"section"},{"location":"dev/architecture/#Purpose","page":"Architecture Overview","title":"Purpose","text":"The make_arr2nt function generates a specialized function that transforms flat parameter vectors (used by samplers) into nested named tuples (used for model evaluation):\n\narr2nt = make_arr2nt(system)\n\nθ_flat = [1.2, 50.0, 5.0, 0.1, ...]  # From sampler\nθ_nested = arr2nt(θ_flat)\n\n# Returns structured data:\n# (M=1.2, plx=50.0,\n#  planets=(\n#    b=(a=5.0, e=0.1, tp=..., mass=...),\n#    c=(a=10.0, e=0.05, ...)\n#  ))","category":"section"},{"location":"dev/architecture/#Implementation-Strategy","page":"Architecture Overview","title":"Implementation Strategy","text":"The function uses compile-time code generation via RuntimeGeneratedFunctions.jl to create a fully type-stable, unrolled transformation:\n\nDirect indexing: All array accesses are unrolled to arr[1], arr[2], etc.\nDependency ordering: Variables are processed in dependency order:\nSystem priors → System derived → Planet priors → Planet derived → Observation priors → Observation derived\nScope management: Uses nested let blocks to provide proper scoping for derived variables","category":"section"},{"location":"dev/architecture/#Generated-Code-Pattern","page":"Architecture Overview","title":"Generated Code Pattern","text":"For a simple two-planet system, the generated function looks like:\n\nfunction (arr)\n    # System priors (direct indexing)\n    M = arr[1]\n    plx = arr[2]\n    sys0 = (M=M, plx=plx)\n\n    # System derived variables (can reference priors)\n    sys1 = let _prev=sys0\n        (; _prev..., distance = 1000/_prev.plx)\n    end\n    sys = sys1\n\n    # Planet B variables\n    planet_b = begin\n        # Planet priors\n        planet0 = (a=arr[3], e=arr[4], i=arr[5], ...)\n\n        # Planet derived (can reference system AND planet priors)\n        planet1 = let system=sys, _prev=planet0\n            (; _prev...,\n               tp = θ_at_epoch_to_tperi(_prev.θ, 50000;\n                                        M=system.M,\n                                        e=_prev.e,\n                                        a=_prev.a, ...))\n        end\n        planet1\n    end\n\n    # Planet C variables (similar structure)\n    planet_c = begin\n        planet0 = (a=arr[10], e=arr[11], ...)\n        planet1 = let system=sys, _prev=planet0\n            # ... derived variables\n        end\n        planet1\n    end\n\n    # Merge into final nested structure\n    return (;sys..., planets=(b=planet_b, c=planet_c))\nend","category":"section"},{"location":"dev/architecture/#Key-Design-Decisions","page":"Architecture Overview","title":"Key Design Decisions","text":"Type stability: By unrolling everything, Julia can infer concrete types\nZero runtime overhead: All indexing and structure construction is known at compile time\nNamed access in likelihoods: Derived variable expressions can use descriptive names (e.g., θ_system.distance) rather than array indices","category":"section"},{"location":"dev/architecture/#3.-Bijection-Mechanisms","page":"Architecture Overview","title":"3. Bijection Mechanisms","text":"Location: src/logdensitymodel.jl:61-84, src/variables.jl:1289-1335","category":"section"},{"location":"dev/architecture/#Purpose-2","page":"Architecture Overview","title":"Purpose","text":"Most samplers (especially HMC/NUTS) work best in unconstrained space. Bijectors transform between constrained (natural parameter space) and unconstrained (sampling space) representations.","category":"section"},{"location":"dev/architecture/#Transformation-Functions","page":"Architecture Overview","title":"Transformation Functions","text":"","category":"section"},{"location":"dev/architecture/#1.-Bijector_linkvec:-Constrained-Unconstrained","page":"Architecture Overview","title":"1. Bijector_linkvec: Constrained → Unconstrained","text":"Used for initialization and diagnostics:\n\nθ_constrained = [0.5, 100.0]  # e ∈ [0,1], plx > 0\nθ_unconstrained = Bijector_linkvec(θ_constrained)\n# e.g., [-0.69, 4.61] (logit and log transforms)","category":"section"},{"location":"dev/architecture/#2.-make_Bijector_invlinkvec:-Unconstrained-Constrained","page":"Architecture Overview","title":"2. make_Bijector_invlinkvec: Unconstrained → Constrained","text":"Generated function used during sampling for maximum performance:\n\nBijector_invlinkvec = make_Bijector_invlinkvec(_list_priors(system))\n\n# Generated code applies appropriate inverse transforms:\nfunction (arr)\n    tuple(\n        Bijectors.invlink(Uniform(0,1), arr[1]),      # Logit⁻¹\n        Bijectors.invlink(Normal(50,0.1), arr[2]),    # Identity\n        Bijectors.invlink(LogNormal(0,1), arr[3]),    # Exp\n        ...\n    )\nend","category":"section"},{"location":"dev/architecture/#Common-Transformations","page":"Architecture Overview","title":"Common Transformations","text":"Distribution Transform Unconstrained Range\nUniform(a,b) Logit (scaled) ℝ\nNormal(μ,σ) Identity ℝ\nLogNormal(μ,σ) Log ℝ\nBeta(α,β) Logit ℝ\nTruncated(...) Custom bijector ℝ","category":"section"},{"location":"dev/architecture/#Jacobian-Corrections","page":"Architecture Overview","title":"Jacobian Corrections","text":"When sampling in transformed space, we must account for the change of variables in the probability density. This is handled automatically in logpdf_with_trans.","category":"section"},{"location":"dev/architecture/#4.-Log-Prior-Generation","page":"Architecture Overview","title":"4. Log Prior Generation","text":"Location: src/variables.jl:1047-1211","category":"section"},{"location":"dev/architecture/#Purpose-3","page":"Architecture Overview","title":"Purpose","text":"The make_ln_prior_transformed function generates an unrolled function to efficiently evaluate the log prior density across all parameters:\n\nln_prior_transformed = make_ln_prior_transformed(system)\nlp = ln_prior_transformed(θ_natural, sampled=true)","category":"section"},{"location":"dev/architecture/#Generated-Code-Pattern-2","page":"Architecture Overview","title":"Generated Code Pattern","text":"function (arr, sampled)\n    lp = zero(first(arr))  # Type-stable zero\n\n    # System priors\n    lp += logpdf_with_trans(Uniform(0,10), arr[1], sampled)\n    lp += logpdf_with_trans(Beta(1,2), arr[2], sampled)\n\n    # Planet priors\n    lp += logpdf_with_trans(Normal(0,1), arr[3], sampled)\n    lp += logpdf_with_trans(LogNormal(0,1), arr[4], sampled)\n    # ... continues for all priors\n\n    # User-defined likelihood constraints (from @variables)\n    lp += logpdf(Normal(0,1), arr[1] + arr[2])\n\n    return lp\nend","category":"section"},{"location":"dev/architecture/#The-sampled-Parameter","page":"Architecture Overview","title":"The sampled Parameter","text":"sampled=true: Includes Jacobian correction for transformed sampling (used during MCMC)\nsampled=false: Raw log probability (used for prior predictive checks)","category":"section"},{"location":"dev/architecture/#Performance-Characteristics","page":"Architecture Overview","title":"Performance Characteristics","text":"Fully unrolled: No loops or dynamic dispatch\nType stable: Return type is known at compile time\nSIMD friendly: Sequential memory access pattern\nAutomatic differentiation ready: Clean, differentiable code","category":"section"},{"location":"dev/architecture/#5.-Log-Likelihood-Generation","page":"Architecture Overview","title":"5. Log Likelihood Generation","text":"Location: src/likelihoods/system.jl","category":"section"},{"location":"dev/architecture/#Purpose-4","page":"Architecture Overview","title":"Purpose","text":"The make_ln_like function is the most complex generated function. It orchestrates:\n\nOrbit element construction from parameter values\nEpoch collection from all observations\nOrbit solving (Kepler's equation) at all epochs\nLikelihood evaluation for each observation","category":"section"},{"location":"dev/architecture/#High-Level-Structure","page":"Architecture Overview","title":"High-Level Structure","text":"flowchart LR\n    A[θ_nested] --> B[Construct Orbit Elements]\n    B --> C[Collect All Epochs]\n    C --> D[Pre-solve Orbits]\n    D --> E1[System Likelihood 1]\n    D --> E2[System Likelihood 2]\n    D --> P1[Planet 1 Likelihoods]\n    D --> P2[Planet 2 Likelihoods]\n    E1 & E2 & P1 & P2 --> F[Sum log likelihoods]\n\n    style D fill:#e1f5ff\n    style F fill:#e8f5e9","category":"section"},{"location":"dev/architecture/#Generated-Code-Pattern-3","page":"Architecture Overview","title":"Generated Code Pattern","text":"function (system::System, θ_system)\n    T = _system_number_type(θ_system)\n    ll0 = zero(T)\n\n    # Construct orbit element objects for each planet\n    planet_1 = VisualOrbit(;merge(θ_system, θ_system.planets[1])...)\n    planet_2 = ThieleInnesOrbit(;merge(θ_system, θ_system.planets[2])...)\n\n    ll_out = @no_escape begin  # Bumper.jl: stack allocation scope\n        elems = tuple(planet_1, planet_2)\n\n        # Collect all unique epochs from all observations\n        epochs = [50000.0, 50100.0, 50200.0, ...]\n\n        # Pre-solve orbits at all epochs (Kepler equation solving)\n        sols_planet_1 = [orbitsolve(planet_1, epoch) for epoch in epochs]\n        sols_planet_2 = [orbitsolve(planet_2, epoch) for epoch in epochs]\n\n        # Evaluate planet observation likelihoods\n        ll1 = ll0 + ln_like(\n            system.planets[1].observations[1],  # e.g., PlanetRelAstromLikelihood\n            θ_system,                            # System parameters\n            θ_system.planets[1],                 # Planet parameters\n            θ_obs,                               # Observation parameters\n            elems,                               # All orbit elements\n            (sols_planet_1, sols_planet_2),      # Pre-computed orbit solutions\n            1,                                   # Planet index\n            0                                    # Epoch start index\n        )\n\n        # Evaluate system observation likelihoods\n        ll2 = ll1 + ln_like(\n            system.observations[1],              # e.g., HGCALikelihood\n            θ_system,\n            θ_obs,\n            elems,\n            (sols_planet_1, sols_planet_2),\n            0                                    # System level (no specific planet)\n        )\n\n        ll2\n    end\n\n    return ll_out\nend","category":"section"},{"location":"dev/architecture/#Why-Pre-solve-Orbits?","page":"Architecture Overview","title":"Why Pre-solve Orbits?","text":"Solving Kepler's equation is expensive (iterative Newton-Raphson). Many observations may occur at the same epoch:\n\nRelative astrometry: RA and Dec at same epoch → solve once, use twice\nMulti-instrument: Different instruments observing simultaneously → solve once, use many times\n\nBy pre-solving all orbits at all unique epochs, we minimize redundant computation.","category":"section"},{"location":"dev/architecture/#Likelihood-Interface","page":"Architecture Overview","title":"Likelihood Interface","text":"Each likelihood type implements a common interface:\n\nfunction ln_like(\n    likeobj::AbstractLikelihood,    # The observation data\n    θ_system::NamedTuple,            # System parameters (M, plx, etc.)\n    θ_planet::NamedTuple,            # Planet parameters (a, e, i, etc.)\n    θ_obs::NamedTuple,               # Observation-specific parameters\n    elems::Tuple,                    # All orbit element objects\n    orbit_solutions::Tuple,          # Pre-computed orbit solutions\n    planet_index::Int,               # Which planet (0 for system-level)\n    epoch_start_index::Int           # Index into orbit_solutions\n)\n    # Calculate residuals: model predictions vs observations\n    # Return sum of log likelihoods\nend","category":"section"},{"location":"dev/architecture/#Allocation-Management","page":"Architecture Overview","title":"Allocation Management","text":"The @no_escape macro (from Bumper.jl) creates a stack-allocated memory arena:\n\nFast allocation: Stack bump allocation instead of heap\nAutomatic cleanup: Memory freed when block exits\nThread safe: Each thread has its own buffer\n\nThis is crucial for performance since likelihood evaluation happens millions of times during sampling.","category":"section"},{"location":"dev/architecture/#6.-The-LogDensityModel-Orchestrator","page":"Architecture Overview","title":"6. The LogDensityModel Orchestrator","text":"Location: src/logdensitymodel.jl","category":"section"},{"location":"dev/architecture/#Purpose-5","page":"Architecture Overview","title":"Purpose","text":"LogDensityModel ties everything together into an object that samplers can use:\n\nmodel = LogDensityModel(system)","category":"section"},{"location":"dev/architecture/#Construction-Process","page":"Architecture Overview","title":"Construction Process","text":"flowchart TD\n    A[LogDensityModel Construction] --> B[Generate Functions]\n\n    B --> C1[sample_priors]\n    B --> C2[ln_prior_transformed]\n    B --> C3[arr2nt]\n    B --> C4[Bijector_invlinkvec]\n\n    C1 & C2 & C3 --> D[Sample from priors]\n    D --> E[Generate ln_like with example θ]\n    C4 & E --> F[Create ℓπcallback]\n    F --> G[Create ∇ℓπcallback with AD]\n    G --> H[Test & Diagnose]\n    H --> I[Return LogDensityModel]\n\n    style B fill:#fff4e1\n    style F fill:#e1f5ff\n    style G fill:#e8f5e9","category":"section"},{"location":"dev/architecture/#Step-1:-Generate-Core-Functions","page":"Architecture Overview","title":"Step 1: Generate Core Functions","text":"sample_priors = make_prior_sampler(system)\nln_prior_transformed = make_ln_prior_transformed(system)\narr2nt = make_arr2nt(system)\nBijector_invlinkvec = make_Bijector_invlinkvec(_list_priors(system))","category":"section"},{"location":"dev/architecture/#Step-2:-Generate-Likelihood-with-Example","page":"Architecture Overview","title":"Step 2: Generate Likelihood with Example","text":"To create the likelihood function, we need an example parameter vector to determine types and structure:\n\nθ_example = arr2nt(sample_priors(rng))\nln_like_generated = make_ln_like(system, θ_example)","category":"section"},{"location":"dev/architecture/#Step-3:-Create-ℓπcallback-(Log-Posterior)","page":"Architecture Overview","title":"Step 3: Create ℓπcallback (Log Posterior)","text":"The callback orchestrates the complete evaluation pipeline:\n\nfunction ℓπcallback(θ_transformed)\n    # Transform from unconstrained to natural space\n    θ_natural = Bijector_invlinkvec(θ_transformed)\n\n    # Convert flat vector to nested named tuple\n    θ_structured = arr2nt(θ_natural)\n\n    # Evaluate log prior (with Jacobian correction)\n    lpost = ln_prior_transformed(θ_natural, sampled=true)\n\n    # Only evaluate likelihood if prior is finite\n    if isfinite(lpost)\n        lpost += ln_like_generated(system, θ_structured)\n    end\n\n    return lpost\nend","category":"section"},{"location":"dev/architecture/#Step-4:-Create-ℓπcallback-(Gradient)","page":"Architecture Overview","title":"Step 4: Create ∇ℓπcallback (Gradient)","text":"Using DifferentiationInterface.jl with ForwardDiff backend:\n\n∇ℓπcallback = DI.prepare_gradient(ℓπcallback, AutoForwardDiff(), θ_example)\n\nThis enables efficient Hamiltonian Monte Carlo sampling.","category":"section"},{"location":"dev/architecture/#Step-5:-Test-and-Diagnose","page":"Architecture Overview","title":"Step 5: Test and Diagnose","text":"The constructor runs test evaluations:\n\nChecks type stability\nVerifies gradient correctness (if AD is available)\nReports parameter count and compilation time","category":"section"},{"location":"dev/architecture/#The-Complete-Model-Object","page":"Architecture Overview","title":"The Complete Model Object","text":"struct LogDensityModel\n    ℓπcallback::Function              # Log posterior evaluation\n    ∇ℓπcallback::Function             # Log posterior + gradient\n    arr2nt::Function                  # Flat → Nested transformation\n    sample_priors::Function           # Prior sampling\n    link::Function                    # Constrained → Unconstrained\n    invlink::Function                 # Unconstrained → Constrained\n    # ... metadata fields\nend","category":"section"},{"location":"dev/architecture/#Usage-in-Sampling","page":"Architecture Overview","title":"Usage in Sampling","text":"# Initialize\nθ_init = model.link(model.sample_priors(rng))\n\n# Evaluate (called millions of times)\nlp = model.ℓπcallback(θ_current)\nlp, ∇lp = model.∇ℓπcallback(θ_current)\n\n# Post-process results\nθ_natural = model.invlink(θ_chain[i])\nθ_named = model.arr2nt(θ_natural)\n# Access: θ_named.planets.b.a","category":"section"},{"location":"dev/architecture/#7.-Design-Principles","page":"Architecture Overview","title":"7. Design Principles","text":"","category":"section"},{"location":"dev/architecture/#1.-Type-Stability","page":"Architecture Overview","title":"1. Type Stability","text":"All generated functions are fully type-stable. Julia can infer concrete types for all intermediate values, enabling:\n\nLLVM optimization\nEfficient memory layout\nElimination of dynamic dispatch","category":"section"},{"location":"dev/architecture/#2.-Zero-Runtime-Overhead","page":"Architecture Overview","title":"2. Zero Runtime Overhead","text":"Code generation moves work from runtime to compile time:\n\nNo loops over variable names\nNo dictionary lookups\nNo type checking at runtime","category":"section"},{"location":"dev/architecture/#3.-Separation-of-Concerns","page":"Architecture Overview","title":"3. Separation of Concerns","text":"Clean separation between:\n\nModel specification (@variables, Planet, System): User-facing, flexible\nCode generation (make_* functions): Implementation detail, optimized\nEvaluation (ℓπcallback, etc.): Simple, fast, differentiation-ready","category":"section"},{"location":"dev/architecture/#4.-Composability","page":"Architecture Overview","title":"4. Composability","text":"Likelihoods implement a common interface and compose freely:\n\nSystem(\n    likelihoods=[\n        HGCALikelihood(...),\n        GaiaDR4Likelihood(...),\n        CustomLikelihood(...)\n    ]\n)\n\nEach likelihood is independent and receives all information it needs via the standardized interface.","category":"section"},{"location":"dev/architecture/#5.-Allocation-Efficiency","page":"Architecture Overview","title":"5. Allocation Efficiency","text":"Strategic use of allocation management:\n\nRuntimeGeneratedFunctions: Generate functions once, reuse forever\n@no_escape: Stack allocation for temporary arrays\nPre-allocation: Orbit solutions computed once per likelihood evaluation","category":"section"},{"location":"dev/architecture/#8.-Example:-Complete-Flow","page":"Architecture Overview","title":"8. Example: Complete Flow","text":"Here's a concrete example showing the complete transformation pipeline:\n\n# ========================================\n# 1. Model Definition\n# ========================================\n\nastrom_data = PlanetRelAstromLikelihood(\n    (epoch=50000.0, ra=100.0, dec=50.0, σ_ra=1.0, σ_dec=1.0),\n    (epoch=50100.0, ra=98.0, dec=52.0, σ_ra=1.0, σ_dec=1.0)\n)\n\nplanet_vars = @variables begin\n    # Priors\n    a ~ truncated(Normal(10, 4), lower=0.1)\n    e ~ Uniform(0.0, 0.5)\n    i ~ Sine()\n    ω ~ UniformCircular()  # Expands to ωx, ωy priors + ω derived\n    Ω ~ UniformCircular()  # Expands to Ωx, Ωy priors + Ω derived\n    θ ~ UniformCircular()  # Expands to θx, θy priors + θ derived\n\n    # Derived variable\n    tp = θ_at_epoch_to_tperi(θ, 50000; M=system.M, e, a, i, ω, Ω)\nend\n\nb = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    variables=planet_vars,\n    observations=[astrom_data]\n)\n\nsystem_vars = @variables begin\n    M ~ truncated(Normal(1.2, 0.1), lower=0.1)\n    plx ~ truncated(Normal(50.0, 0.02), lower=0.1)\nend\n\nsystem = System(\n    name=\"HD82134\",\n    variables=system_vars,\n    companions=[b]\n)\n\n# ========================================\n# 2. Create Log Density Model\n# ========================================\n\nmodel = LogDensityModel(system)\n\n# This generates:\n# - sample_priors:  () -> [random draws from all priors]\n# - arr2nt:         [θ₁, θ₂, ...] -> (M=θ₁, plx=θ₂, planets=(b=(a=θ₃, ...)))\n# - ln_prior:       [θ₁, θ₂, ...] -> Σ log p(θᵢ)\n# - ln_like:        nested_θ -> Σ log p(data | θ)\n# - ℓπcallback:     θ_unconstrained -> log p(θ, data)\n# - ∇ℓπcallback:    θ_unconstrained -> (log p(θ, data), ∇ log p(θ, data))\n\n# ========================================\n# 3. Sampling\n# ========================================\n\n# Initialize in unconstrained space\nθ_init = model.link(model.sample_priors(rng))  # e.g., [-0.5, 4.6, 2.3, ...]\n\n# Sample (simplified pseudocode)\nfor iteration in 1:10000\n    # Evaluate log posterior and gradient (HMC/NUTS)\n    lp, ∇lp = model.∇ℓπcallback(θ_current)\n\n    # The above call executes:\n    # θ_current (unconstrained)\n    #   → Bijector_invlinkvec → θ_natural (constrained)\n    #   → arr2nt → θ_structured (nested named tuple)\n    #   → ln_prior_transformed(θ_natural) → log prior\n    #   → ln_like_generated(system, θ_structured) → log likelihood\n    #   → return log prior + log likelihood\n\n    # HMC/NUTS update step\n    θ_current = nuts_step(θ_current, lp, ∇lp)\nend\n\n# ========================================\n# 4. Post-Processing\n# ========================================\n\n# Convert chain to named tuples for analysis\nchain_named = map(model.arr2nt ∘ model.invlink, eachrow(chain_array))\n\n# Access structured results\nfor θ in chain_named\n    println(\"Planet b semi-major axis: \", θ.planets.b.a)\n    println(\"Planet b periastron time: \", θ.planets.b.tp)  # Derived variable!\nend","category":"section"},{"location":"dev/architecture/#Summary","page":"Architecture Overview","title":"Summary","text":"Octofitter's architecture achieves high performance through aggressive compile-time specialization:\n\nUser writes: Declarative model specification (@variables, Planet, System)\nOctofitter generates: Specialized, type-stable functions for this specific model\nSampler uses: Fast, allocation-efficient evaluation of log posterior and gradients\nUser receives: Structured results with named parameters and derived quantities","category":"section"},{"location":"mass-photometry/#mass-photometry","page":"Connect Mass and Photometry","title":"Connecting Mass with Photometry","text":"You can make connections between model variables using physical models with the help of Derived variables.\n\nFor this example, we will assume you are sampling from photometry data and have a model that takes a mass as input and returns the expected flux. The flux should be in the same units as the photometry measurements you included in the model.\n\nFor the sake of this example, we will assume you have photometry taken in two bands H and J. For demonstration purposes, we will just pretend that the flux can be calculated as the square root of the mass. In a real project, you would likely use an interpolation over some model grid. A good way to do this is Interpolations.jl.\n\nH_band_contrast_interp(mass) = sqrt(mass) # your model or function here\nJ_band_contrast_interp(mass) = sqrt(mass) # your model or function here\n\nFirst, create your photometry observations and likelihoods. Each PhotometryObs handles a single band with a flux variable defined in its variables block rather than in the planet definition. The name parameter is used for variable naming in the MCMC chain output (e.g., \"bHband_flux\"). This way, the flux variables will be calculated off of your model's mass parameter before getting compared to the photometry:\n\n# Create separate photometry likelihoods for each band\nH_band_table = Table(\n    phot=[15.2], σ_phot=[0.5],\n)\nH_band_data = PhotometryObs(\n    H_band_table,\n    name=\"H_band\",\n    variables=@variables begin\n        flux = $H_band_contrast_interp(system.mass)\n    end\n)\n\nJ_band_table = Table(\n    phot=[14.8], σ_phot=[0.3],\n)\nJ_band_data = PhotometryObs(\n    J_band_table,\n    name=\"J_band\", \n    variables=@variables begin\n        flux = $J_band_contrast_interp(system.mass)\n    end\n)\n\n# Define the planet with orbital parameters and mass\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[H_band_data, J_band_data],\n    variables=@variables begin\n        a ~ Normal(16, 3)\n        e ~ truncated(Normal(0.2, 0.2), lower=0, upper=0.99)\n        ω ~ Normal(0.6, 0.2)\n        i ~ Normal(0.5, 0.2)\n        Ω ~ Normal(0.0, 0.2)\n        mass ~ Uniform(0, 1)\n        \n        M = system.M\n        τ ~ UniformCircular(1.0)\n        P = √(a^3/M)\n        tp = τ*P*365.25 + 58849 # reference epoch for τ. Choose an MJD date near your data.\n    end\n)\n\nIf your model grids contain more independent variables, like age, surface gravity, etc. you can create a multi-dimensional interpolator. I recommend ThinPlate() from Interpolations.jl as a starting point.\n\nThis might look a little like this:\n\n# More complex interpolation function using multiple variables\nK_band_contrast_interp(mass, age, temp) = sqrt(mass) * (age/10) * sqrt(temp/1000)\n\n# Photometry likelihood with derived variable using system and planet properties\nK_band_table = Table(\n    phot=[13.5], σ_phot=[0.4],\n)\nK_band_data = PhotometryObs(\n    K_band_table,\n    name=\"K_band\",\n    variables=@variables begin\n        flux = $K_band_contrast_interp(system.mass, system.age, system.temp)\n    end\n)\n\n# Planet definition\nplanet_b = Planet(\n    name=\"b\", \n    basis=Visual{KepOrbit},\n    observations=[K_band_data],\n    variables=@variables begin\n        a ~ Normal(16, 3)\n        e ~ truncated(Normal(0.2, 0.2), lower=0, upper=0.99)\n        ω ~ Normal(0.6, 0.2)\n        i ~ Normal(0.5, 0.2)\n        Ω ~ Normal(0.0, 0.2)\n        mass ~ Uniform(0, 1)\n        temp ~ Normal(1200, 500)\n        age = system.age\n        \n        M = system.M\n        τ ~ UniformCircular(1.0)\n        P = √(a^3/M)\n        tp = τ*P*365.25 + 58849 # reference epoch for τ. Choose an MJD date near your data.\n    end\n)\n\n# System definition\nsys = System(\n    name=\"HD12345\",\n    companions=[planet_b],\n    observations=[],\n    variables=@variables begin\n        M ~ Normal(1.0, 0.1)\n        plx ~ Normal(12, 0.01)\n        age ~ Normal(15, 1)\n    end\n)\n\nHere the K_band_contrast_interp you supply accepts the mass of the planet, age of the system, and temperature of the planet as input, and returns the flux at K band in the same units as your photometry measurements.","category":"section"},{"location":"parallel-sampling/#Distributed-Sampling","page":"Distributed Sampling","title":"Distributed Sampling","text":"note: Note\nOctofitter's default sampler (Hamiltonian Monte Carlo) is not easily parallelizable; however, it performs excellently on a single core. Give it a try before assuming you need to sample with multiple cores or nodes.\n\nThis guide shows how you can sample from Octofitter models using a cluster. If you just want to sample across multiple cores on the same computer, start julia with multiple threads (julia --threads=auto) and use octofit_pigeons.\n\nIf your problem is challenging enough to benefit from parallel sampling across multiple nodes in a cluster, you might consider using Pigeons with MPI by following this guide. ","category":"section"},{"location":"parallel-sampling/#MPI-Launcher-Script","page":"Distributed Sampling","title":"MPI Launcher Script","text":"We will use a Julia script to submit the batch job to the cluster. The script will define the model and start the sampling process. The sampler can then run in the background, and you can periodically load the results in from the checkpoint file to examine them after each round of sampling.\n\nHere is an example:\n\nusing Octofitter\nusing OctofitterRadialVelocity\nusing PlanetOrbits\nusing CairoMakie\nusing PairPlots\nusing DataFrames\nusing Distributions\n\n# Specify your data as usual\nastrom_obs = PlanetRelAstromObs(\n    # Your data here:\n    (epoch = 50000, ra = -505.7637580573554, dec = -66.92982418533026, σ_ra = 10, σ_dec = 10, cor=0),\n    (epoch = 50120, ra = -502.570356287689, dec = -37.47217527025044, σ_ra = 10, σ_dec = 10, cor=0),\n    (epoch = 50240, ra = -498.2089148883798, dec = -7.927548139010479, σ_ra = 10, σ_dec = 10, cor=0),\n    (epoch = 50360, ra = -492.67768482682357, dec = 21.63557115669823, σ_ra = 10, σ_dec = 10, cor=0),\n    (epoch = 50480, ra = -485.9770335870402, dec = 51.147204404903704, σ_ra = 10, σ_dec = 10, cor=0),\n    (epoch = 50600, ra = -478.1095526888573, dec = 80.53589069730698, σ_ra = 10, σ_dec = 10, cor=0),\n    (epoch = 50720, ra = -469.0801731788123, dec = 109.72870493064629, σ_ra = 10, σ_dec = 10, cor=0),\n    (epoch = 50840, ra = -458.89628893460525, dec = 138.65128697876773, σ_ra = 10, σ_dec = 10, cor=0),\n)\n\n# build your model as usual\n@planet b Visual{KepOrbit} begin\n    a ~ Uniform(0, 100) # AU\n    e ~ Uniform(0.0, 0.99)\n    i ~ Sine() # radians\n    ω ~ UniformCircular()\n    Ω ~ UniformCircular()\n    θ ~ UniformCircular()\n    tp = θ_at_epoch_to_tperi(system,b,50000) # use MJD epoch of your data here!!\nend astrom_obs\n@system Tutoria begin # replace Tutoria with the name of your planetary system\n    M ~ truncated(Normal(1.2, 0.1), lower=0.1)\n    plx ~ truncated(Normal(50.0, 0.02), lower=0.1)\nend b\nmodel = Octofitter.LogDensityModel(Tutoria)","category":"section"},{"location":"parallel-sampling/#Launcher-Script","page":"Distributed Sampling","title":"Launcher Script","text":"Use this script to launch your MPI job.\n\ninclude(\"distributed-model.jl\")\npt = pigeons(\n    target = Pigeons.LazyTarget(MyLazyTarget()),\n    record = [traces; round_trip; record_default()],\n    on = Pigeons.MPIProcesses(\n        n_mpi_processes = n_chains,\n        n_threads = 1,\n        dependencies = [abspath(\"distributed-model.jl\")]\n    ),\n    # Pass additional flags to the HPC scheduler here\n    # See here for more details: https://pigeons.run/stable/reference/#Pigeons.MPIProcesses\n    # add_to_submission = [\"#PBS -A my_user_allocation_code\"] # pbs\n    add_to_submission = [ # slurm\n        \"#SBATCH --account=my_user_name\",\n        \"#SBATCH --time=24:00:00\",\n    ],\n     # HPC modules to load on each worker\n    environment_modules: [\"StdEnv/2023\", \"intel\", \"openmpi\", \"julia/1.10\", \"hdf5\"]\n)\n\ninfo: Info\nDon't submit this script to your cluster. Run it on a login node and it will submit the job for you.","category":"section"},{"location":"parallel-sampling/#Troubleshooting","page":"Distributed Sampling","title":"Troubleshooting","text":"If you run into library issues with MPI and/or HDF5, you may need to tell Julia to use the system provided versions. \n\nHere is an example that works on AllianceCanada clusters, and may be adaptable to other slurm-based systems:\n\nusing Preferences, HDF5\n\nset_preferences!(\n    HDF5,\n    \"libhdf5\" => ENV[\"EBROOTHDF5\"]*\"/lib/libhdf5_hl.so\",\n    \"libhdf5_hl\" => ENV[\"EBROOTHDF5\"]*\"/lib/libhdf5_hl.so\",\n    force = true\n)\n\nmodelfname = ARGS[1]\nn_proc = parse(Int, ARGS[2])\n\nPigeons.setup_mpi(\n    submission_system = :slurm,\n    environment_modules = [\"StdEnv/2023\", \"intel\", \"openmpi\", \"julia/1.10\", \"hdf5\"],\n    library_name = ENV[\"EBROOTOPENMPI\"]*\"/lib/libmpi\",\n    add_to_submission = [\n        \"#SBATCH --time=24:00:00\",\n        \"#SBATCH --account=def-account-name\",\n        \"#SBATCH --mem-per-cpu=8g\"\n    ]\n)\nprintln(\"Setup MPIProcesses\")","category":"section"},{"location":"parallel-sampling/#Examine-Results","page":"Distributed Sampling","title":"Examine Results","text":"After one or more sampling rounds have completed, you can run this command to load the results so far for analysis.\n\n\n# If still in current session, just pass the `pt` object:\nresults = Chains(model, pt)\n\n# Else, if the sampling has been running in the background, run:\npt = PT(mpi_run)\nmodel = pt.inputs.target\nresults = Chains(model, pt)\n\n\noctocorner(model, results, small=true)","category":"section"},{"location":"images/#fit-images","page":"Image Data (de-orbiting)","title":"Fitting Images","text":"One of the key features of Octofitter.jl is the ability to search for planets directly from images of the system. Sampling from images is much more computationally demanding than sampling from astrometry, but it allows for a few very powerful results:\n\nYou can search for a planet that is not well detected in a single image\n\nBy this, we mean you can feed in images of a system with no clear detections, and see if a planet is hiding in the noise based off of its Kepelerian motion.\n\nNot detecting a planet in a given image can be almost as useful as a detection for constraining its orbit. \n\nIf you have a clear detection in one epoch, but no detection in another, Octofitter can use the image from the second epoch to rule out large swathes of possible orbits.\n\nSampling from images can be freely combined with any known astrometry points, as well as astrometric acceleration. See advanced models for more details.\n\nnote: Note\nImage modelling is supported in Octofitter via the extension package OctofitterImages. To install it, run  pkg> add http://github.com/sefffal/Octofitter.jl:OctofitterImages","category":"section"},{"location":"images/#Preparing-images","page":"Image Data (de-orbiting)","title":"Preparing images","text":"The first step will be to load your images. For this, we will use our AstroImages.jl package.\n\nStart by loading your images:\n\nusing Octofitter\nusing OctofitterImages\nusing Distributions\nusing Pigeons\nusing AstroImages\nusing CairoMakie\n\n# Load individual iamges\n# image1 = load(\"image1.fits\")\n# image2 = load(\"image2.fits\")\n\n# Or slices from a cube:\n# cube = load(\"cube1.fits\")\n# image1 = cube[:,:,1] \n\n# Download sample images from GitHub\ndownload(\n    \"https://github.com/sefffal/Octofitter.jl/raw/main/docs/image-examples-1.fits\",\n    \"image-examples-1.fits\"\n)\n\n# Or multi-extension FITS (this example)\nimages = AstroImages.load(\"image-examples-1.fits\",:)\n\nYou can preview the image using imview from AstroImages:\n\n# imshow2(image1, cmap=:magma) # for a single image\nhcat(imview.(images, clims=(-1.0, 4.0))...)\n\nYour images should either be convolved with a gaussian of diameter one λ/D, or be matched filtered. This is so that the values of the pixels in the image represent the photometry at that location. \n\nIf you want to perform the convolution in Julia, see ImageFiltering.jl.","category":"section"},{"location":"images/#Build-the-model","page":"Image Data (de-orbiting)","title":"Build the model","text":"First, we create a table of our image observations:\n\nimage_dat = Table(;\n    epoch = [1238.6, 1584.7, 3220.0, 7495.9, 7610.4],\n    image = [\n        AstroImages.recenter(images[1]),\n        AstroImages.recenter(images[2]), \n        AstroImages.recenter(images[3]),\n        AstroImages.recenter(images[4]),\n        AstroImages.recenter(images[5])\n    ],\n    platescale = [10.0, 10.0, 10.0, 10.0, 10.0]\n)\n\nimage_obs = ImageObs(\n    image_dat,\n    name=\"SPHERE\",\n    variables=@variables begin\n        # Planet flux in image units -- could be contrast, mags, Jy, or arb. as long as it's consistent\n        flux ~ Normal(3.8, 0.5)\n        # The following are optional parameters for marginalizing over instrument systematics:\n        # Platescale uncertainty multiplier [could use: platescale ~ truncated(Normal(1, 0.01), lower=0)]\n        platescale = 1.0\n        # North angle offset in radians [could use: northangle ~ Normal(0, deg2rad(1))]\n        northangle = 0.0\n    end\n)\n\nProvide one entry for each image you want to sample from. Ensure that each image has been re-centered so that index [0,0] is the position of the star. Areas of the image where there is no data should be filled with NaN and will not contribute to the likelihood of your model. platescale should be the pixel scale of your images, in milliarseconds / pixel. epoch should be the Modified Julian Day (MJD) that your image was taken. You can use the mjd(\"2021-09-09\") function to calculate this for you. band should be a symbol that matches the name you supplied when you created the Planet.\n\nBy default, the contrast of the images is calculated automatically, but you can supply your own contrast curve as well by also passing contrast=OctofitterImages.contrast_interp(AstroImages.recenter(my_image)).\n\nYou can freely mix and match images from different instruments as long as you specify the correct platescale.  You can also provide images from multiple bands and they will be sampled independently. If you wish to tie them together, see Connecting Mass with Photometry.\n\nNow specify the planet:\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[image_obs],\n    variables=@variables begin\n        a ~ truncated(Normal(13, 4), lower=0.1, upper=100)\n        e ~ Uniform(0.0, 0.5)\n        i ~ Sine()\n        M = system.M\n        ω ~ UniformCircular()\n        Ω ~ UniformCircular()\n        θ ~ UniformCircular()\n        tp = θ_at_epoch_to_tperi(θ, 1238.6; M, e, a, i, ω, Ω)\n    end\n)\n\nNote how we provided a prior on the photometry called flux in the variables block of the ImageObs. This represents the expected flux of the planet in the image units.\n\nSee Fit PlanetRelAstromObs for a description of the different orbital parameters, and conventions used.\n\nFinally, create the system and pass in the planet.\n\nsys = System(\n    name=\"HD82134\",\n    companions=[planet_b],\n    observations=[],\n    variables=@variables begin\n        M ~ truncated(Normal(2.0, 0.1),lower=0.1)\n        plx ~ truncated(Normal(45., 0.02),lower=0.1)\n    end\n)\n\nIf you want to search for two or more planets in the same images, just create multiple Planets and pass the same images to each. You'll need to adjust the priors in some way to prevent overlap.\n\nYou can also do some very clever things like searching for planets that are co-planar and/or have a specific resonance between their periods. To do this, put the planet of the system or base period as variables of the system and derive the planet variables from those values of the system. ","category":"section"},{"location":"images/#Sampling","page":"Image Data (de-orbiting)","title":"Sampling","text":"Sampling from images is much more challenging than relative astrometry or proper motion anomaly, so the fitting process tends to take longer.\n\nThis is because the posterior is much \"bumpier\" with images. One way this manifests is very high tree depths. You might see a sampling report that says max_tree_depth_frac = 0.9 or even 1.0. To encourage the sampler to take larger steps and explore the images, it's recommended to lower the target acceptance ratio to around 0.5±0.2 and also increase the number of adapataion steps.\n\nmodel = Octofitter.LogDensityModel(sys)\n\nchain, pt = octofit_pigeons(model, n_rounds=10)\ndisplay(chain)\n\nnote: Note\noctofit_pigeons scales very well across multiple cores. Start julia with julia --threads=auto to make sure you have multiple threads available for sampling.","category":"section"},{"location":"images/#Diagnostics","page":"Image Data (de-orbiting)","title":"Diagnostics","text":"The first thing you should do with your results is check a few diagnostics to make sure the sampler converged as intended.\n\nThe acceptance rate should be somewhat lower than when fitting just astrometry, e.g. around the 0.6 target.\n\nYou can make a trace plot:\n\nlines(\n    chain[\"b_a\"][:],\n    axis=(;\n        xlabel=\"iteration\",\n        ylabel=\"semi-major axis (aU)\"\n    )\n)\n\nAnd an auto-correlation plot:\n\nusing StatsBase\nlines(\n    autocor(chain[\"b_e\"][:], 1:500),\n    axis=(;\n        xlabel=\"lag\",\n        ylabel=\"autocorrelation\",\n    )\n)\n\nFor this model, there is somewhat higher correlation between samples. Some thinning to remove this correlation is recommended.","category":"section"},{"location":"images/#Analysis","page":"Image Data (de-orbiting)","title":"Analysis","text":"We can now view the orbit fit:\n\nfig = octoplot(model, chain)\n\nWith a bit of work, we can plot one of the images under the orbit.\n\nfig = octoplot(model, chain)\nax = fig.content[1] # grap first axis in the figure\n\n# We have to do some annoying work to get the image orientated correctly,\n# since we want the RA axis increasing to the left.\nimage_idx = 2\nplatescale = image_dat.platescale[image_idx]\nimg = AstroImages.recenter(AstroImage(collect(image_dat.image[image_idx])[end:-1:begin,:]))\nimgax1 = dims(img,1) .* platescale\nimgax2 = dims(img,2) .* platescale\nh = heatmap!(ax, imgax1, imgax2, collect(img), colormap=:greys)\nMakie.translate!(h, 0,0,-1) # Send heatmap to back of the plot\n\n# Add colorbar for image\nColorbar(fig[1,2], h, label=\"image flux\")\n\nMakie.resize_to_layout!(fig)\nfig\n\nAnother useful view would be the orbits over a stack of the maximum pixel values of all images.\n\nfig = octoplot(model, chain)\nax = fig.content[1] # grap first axis in the figure\n\n# We have to do some annoying work to get the image orientated correctly\n# since we want the RA axis increasing to the left.\nplatescale = image_dat.platescale[image_idx]\nimgs = maximum(stack(image_dat.image),dims=3)[:,:]\nimg = AstroImages.recenter(AstroImage(imgs[end:-1:begin,:]))\nimgax1 = dims(img,1) .* platescale\nimgax2 = dims(img,2) .* platescale\nh = heatmap!(ax, imgax1, imgax2, collect(img), colormap=:greys)\nMakie.translate!(h, 0,0,-1) # Send heatmap to back of the plot\nMakie.resize_to_layout!(fig)\nfig","category":"section"},{"location":"images/#Pair-Plot","page":"Image Data (de-orbiting)","title":"Pair Plot","text":"We can show the relationships between variables on a pair plot (aka corner plot):\n\nusing CairoMakie, PairPlots\noctocorner(model, chain, small=true)\n\nNote that this time, we also show the recovered photometry in the corner plot.","category":"section"},{"location":"images/#Assessing-Detections","page":"Image Data (de-orbiting)","title":"Assessing Detections","text":"To assess a detection, we can treat all the orbital variables as nuisance parameters.  We start by plotting the marginal distribution of the flux parameter, H:\n\nhist(chain[\"b_SPHERE_flux\"][:], axis=(xlabel=\"flux\", ylabel=\"counts\"))\n\nWe can calculate an analog of the traditional signal to noise ratio (SNR) using that same histogram:\n\nflux = chain[\"b_SPHERE_flux\"]\nsnr = mean(flux)/std(flux)\n\nIt might be better to consider a related measure, like the median flux over the interquartile distance. This will depend on your application.","category":"section"},{"location":"hipparcos/#Hipparcos-Modelling","page":"Hipparcos IAD","title":"Hipparcos Modelling","text":"This tutorial explains how to model Hipparcos IAD data. The first example reproduces the catalog values of position, parallax, and proper motion. The second uses Hipparcos to constrain the mass of a directly imaged planet.","category":"section"},{"location":"hipparcos/#Reproduce-Catalog-Values","page":"Hipparcos IAD","title":"Reproduce Catalog Values","text":"This is the so-called \"Nielsen\" test from Nielsen et al (2020) and available in Orbitize!.\n\nWe start by using a system with a planet with zero mass to fit the straight line motion.\n\nusing Octofitter\nusing Distributions\nusing CairoMakie\n\nhip_obs = Octofitter.HipparcosIADObs(\n    hip_id=21547,\n    renormalize=true, # default: true\n    variables=@variables begin\n        # Optional: flux ratio for luminous companions, one entry per companion\n        # fluxratio ~ Product([Uniform(0, 1), Uniform(0, 1)])  # uncomment if needed for unresolved companions\n    end\n)\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=AbsoluteVisual{KepOrbit},\n    variables=@variables begin\n        mass = 0.\n        e = 0. \n        ω = 0. \n        a = 1.\n        i = 0\n        Ω = 0.\n        tp = 0.\n    end\n)\n\nsys = System(\n    name=\"c_Eri_straight_line\",\n    companions=[planet_b],\n    observations=[hip_obs],\n    variables=@variables begin\n        M = 1.0 # Host mass not important for this example\n        rv = 0.0 # system RV not significant for this example\n        plx ~ Uniform(10,100)\n        pmra ~ Uniform(-100, 100)\n        pmdec ~  Uniform(-100, 100)\n\n        # It is convenient to put a prior of the catalog value +- 10,000 mas on position\n        ra_hip_offset_mas ~  Normal(0, 10000)\n        dec_hip_offset_mas ~ Normal(0, 10000)\n        dec = $hip_obs.hip_sol.dedeg + ra_hip_offset_mas/60/60/1000\n        ra = $hip_obs.hip_sol.radeg + dec_hip_offset_mas/60/60/1000/cosd(dec)\n\n        ref_epoch = Octofitter.hipparcos_catalog_epoch_mjd\n    end\n)\n\nmodel = Octofitter.LogDensityModel(sys)\n\nLet's initialize the starting point for the chains to reasonable values\n\ninitialize!(model, (;\n    plx=34.,\n    pmra=44.25,\n    pmdec=-64.5,\n    ra_hip_offset_mas=0.,\n    dec_hip_offset_mas=0.,\n))\n\nWe can now sample from the model using Hamiltonian Monte Carlo. This should only take about 15 seconds.\n\nusing Pigeons\nchain,pt = octofit_pigeons(model, n_rounds=6)\n\nPlot the posterior values:\n\noctoplot(model,chain,show_astrom=false,show_astrom_time=false)\n\nWe now visualize the model fit compared to the Hipparcos catalog values:\n\nusing LinearAlgebra, StatsBase\nfig = Figure(size=(1080,720))\nj = i = 1\nfor prop in (\n    (;chain=:ra, hip=:radeg, hip_err=:e_ra), \n    (;chain=:dec, hip=:dedeg, hip_err=:e_de),\n    (;chain=:plx, hip=:plx, hip_err=:e_plx), \n    (;chain=:pmra, hip=:pm_ra, hip_err=:e_pmra), \n    (;chain=:pmdec, hip=:pm_de, hip_err=:e_pmde)\n)\n    global i, j, ax\n    ax = Axis(\n        fig[j,i],\n        xlabel=string(prop.chain),\n    )\n    i+=1\n    if i > 3\n        j+=1\n        i = 1\n    end\n    unc = hip_obs.hip_sol[prop.hip_err]\n    if prop.chain == :ra\n        unc /= 60*60*1000 * cosd(hip_obs.hip_sol.dedeg)\n    end\n    if prop.chain == :dec\n        unc /= 60*60*1000\n    end\n    if prop.hip == :zero\n        n = Normal(0, unc)\n    else\n        mu = hip_obs.hip_sol[prop.hip]\n        n = Normal(mu, unc)\n    end\n    n0,n1=quantile.(n,(1e-4, 1-1e-4))\n    nxs = range(n0,n1,length=200)\n    h = fit(Histogram, chain[prop.chain][:], nbins=55)\n    h = normalize(h, mode=:pdf)\n    barplot!(ax, (h.edges[1][1:end-1] .+ h.edges[1][2:end])./2, h.weights, gap=0, color=:red, label=\"posterior\")\n    lines!(ax, nxs, pdf.(n,nxs), label=\"Hipparcos Catalog\", color=:black, linewidth=2)\nend\nLegend(fig[i-1,j+1],ax,tellwidth=false)\nfig","category":"section"},{"location":"hipparcos/#Constrain-Planet-Mass","page":"Hipparcos IAD","title":"Constrain Planet Mass","text":"We now allow the planet to have a non zero mass and have free orbit. We start by specifying relative astrometry data on the planet, collated by Jason Wang and co. on whereistheplanet.com.\n\nastrom_dat = Table(;\n    epoch = [57009.1, 57052.1, 57053.1, 57054.3, 57266.4, 57332.2, 57374.2, 57376.2, 57415.0, 57649.4, 57652.4, 57739.1, 58068.3, 58442.2],\n    sep   = [454.24, 451.81, 456.8, 461.5, 455.1, 452.88, 455.91, 455.01, 454.46, 454.81, 451.43, 449.39, 447.54, 434.22],\n    σ_sep = [1.88, 2.06, 2.57, 23.9, 2.23, 5.41, 6.23, 3.03, 6.03, 2.02, 2.67, 2.15, 3.02, 2.01],\n    pa    = [2.98835, 2.96723, 2.97038, 2.97404, 2.91994, 2.89934, 2.89131, 2.89184, 2.8962, 2.82394, 2.82272, 2.79357, 2.70927, 2.61171],\n    σ_pa  = [0.00401426, 0.00453786, 0.00523599, 0.0523599, 0.00453786, 0.00994838, 0.00994838, 0.00750492, 0.00890118, 0.00453786, 0.00541052, 0.00471239, 0.00680678, 0.00401426]\n)\n\nastrom_obs1 = PlanetRelAstromObs(\n    astrom_dat,\n    name=\"VLT/SPHERE\",\n    variables=@variables begin\n        # Fixed values for this example - could be free variables:\n        jitter = 0        # mas [could use: jitter ~ Uniform(0, 10)]\n        northangle = 0    # radians [could use: northangle ~ Normal(0, deg2rad(1))]\n        platescale = 1    # relative [could use: platescale ~ truncated(Normal(1, 0.01), lower=0)]\n    end\n)\n\nWe specify our full model:\n\nplanet_b_mass = Planet(\n    name=\"b\",\n    basis=AbsoluteVisual{KepOrbit},\n    observations=[astrom_obs1],\n    variables=@variables begin\n        a ~ truncated(Normal(10,1),lower=0.1)\n        e ~ Uniform(0,0.99)\n        ω ~ Uniform(0, 2pi)\n        i ~ Sine()\n        Ω ~ Uniform(0, 2pi)\n        θ ~ Uniform(0, 2pi)\n        M = system.M\n        tp = θ_at_epoch_to_tperi(θ, 58442.2; M, e, a, i, ω, Ω) \n        mass = system.M_sec\n    end\n)\n\nsys_mass = System(\n    name=\"cEri\",\n    companions=[planet_b_mass],\n    observations=[hip_obs],\n    variables=@variables begin\n        M_pri ~ truncated(Normal(1.75,0.05), lower=0.03) # Msol\n        M_sec ~ LogUniform(0.1, 100) # MJup\n        M = M_pri + M_sec*Octofitter.mjup2msol # Msol\n\n        rv =  12.60e3 # m/s\n        plx ~ Uniform(20,40)\n        pmra ~ Uniform(-100, 100)\n        pmdec ~  Uniform(-100, 100)\n\n        # It is convenient to put a prior of the catalog value +- 1000 mas on position\n        ra_hip_offset_mas ~  Normal(0, 1000)\n        dec_hip_offset_mas ~ Normal(0, 1000)\n        dec = $hip_obs.hip_sol.dedeg + ra_hip_offset_mas/60/60/1000\n        ra = $hip_obs.hip_sol.radeg + dec_hip_offset_mas/60/60/1000/cos(dec)\n\n        ref_epoch = Octofitter.hipparcos_catalog_epoch_mjd\n    end\n)\n\nmodel = Octofitter.LogDensityModel(sys_mass)\n\nInitialize the starting points, and confirm the data are entered correcly:\n\ninit_chain = initialize!(model, (;\n    plx=34.,\n    pmra=44.25,\n    pmdec=-64.5,\n    ra_hip_offset_mas=0.,\n    dec_hip_offset_mas=0.,\n))\noctoplot(model, init_chain)\n\nNow we sample:\n\nusing Pigeons\nchain,pt = octofit_pigeons(model, n_rounds=8, explorer=SliceSampler())\nchain\n\noctoplot(model, chain, show_mass=true)\n\nWe see that we constrained both the orbit and the parallax. The mass is not strongly constrained by Hipparcos.","category":"section"},{"location":"prior-pred/#Prior-Predictive-Checks","page":"Prior Predictive Checks","title":"Prior Predictive Checks","text":"The prior predictive distributin of a Bayesian model what you get by sampling parameters directly from the priors and calculating where the model would place the data. For example, if sampling from relative astrometry, the prior predictive model is the distribution of (simulated) astrometry points corresponding to orbits drawn from the prior. For radial velocity data, these would be simulated RV points based on an RV curve drawn from the priors.\n\nTo generate a prior predictive distribution, one first needs to create a model. We will use the model and sample data from the Fit Astrometry tutorial:\n\nusing Octofitter\nusing CairoMakie\nusing PairPlots\nusing Distributions\n\nastrom_dat = Table(;\n    epoch= [50000,50120,50240,50360,50480,50600,50720,50840,],\n    ra = [-505.764,-502.57,-498.209,-492.678,-485.977,-478.11,-469.08,-458.896,],\n    dec = [-66.9298,-37.4722,-7.92755,21.6356, 51.1472, 80.5359, 109.729, 138.651,],\n    σ_ra = fill(50.0, 8),\n    σ_dec = fill(50.0, 8),\n    cor = fill(0.0, 8)\n)\nastrom_obs = PlanetRelAstromObs(astrom_dat, name=\"relastrom\")\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[astrom_obs],\n    variables=@variables begin\n        M = system.M\n        a ~ truncated(Normal(10, 4), lower=0, upper=100)\n        e ~ Uniform(0.0, 0.5)\n        i ~ Sine()\n        ω ~ UniformCircular()\n        Ω ~ UniformCircular()\n        θ_x ~ Normal()\n        θ_y ~ Normal()\n        θ = atan(θ_y, θ_x)\n        tp = θ_at_epoch_to_tperi(θ, 50420; M, e, a, i, ω, Ω)  # reference epoch for θ. Choose an MJD date near your data.\n    end\n)\n\nsys = System(\n    name=\"Tutoria\",\n    companions=[planet_b],\n    observations=[],\n    variables=@variables begin\n        M ~ truncated(Normal(1.2, 0.1), lower=0.1)\n        plx ~ truncated(Normal(50.0, 0.02), lower=0.1)\n    end\n)\nnothing #hide\n\nWe can now draw one sample from the prior:\n\nprior_draw_system = generate_from_params(sys)\nprior_draw_astrometry = prior_draw_system.planets.b.observations[1]\n\nAnd plot the generated astrometry:\n\nMakie.scatter(prior_draw_astrometry.table.ra, prior_draw_astrometry.table.dec,color=:black, axis=(;autolimitaspect=1,xreversed=true))\n\nWe can repeat this many times to get a feel for our chosen priors in the domain of our data:\n\nusing Random\nRandom.seed!(1)\n\n\nfig = Figure()\nax = Axis(\n    fig[1,1], xlabel=\"ra offset [mas]\", ylabel=\"dec offset [mas]\",\n    xreversed=true,\n    aspect=1\n)\nfor i in 1:50\n    prior_draw_system = generate_from_params(sys)\n    prior_draw_astrometry = prior_draw_system.planets.b.observations[1]\n    Makie.scatter!(\n        ax,\n        prior_draw_astrometry.table.ra,\n        prior_draw_astrometry.table.dec,\n        color=Makie.cgrad(:turbo)[i/50],\n    )\nend\n\n\nMakie.errorbars!(ax,astrom_dat.ra,astrom_dat.dec,astrom_dat.σ_dec,color=:black,linewidth=3)\nMakie.errorbars!(ax,astrom_dat.ra,astrom_dat.dec,astrom_dat.σ_ra,direction=:x,color=:black,linewidth=3)\n\nfig\n\nThe heavy black crosses are our actual data, while the colored ones are simulations drawn from our priors. Notice that our real data lies at a greater separation than most draws from the prior? That might mean the priors could be tweaked.","category":"section"},{"location":"rvpostplot/#RV-Visualization-with-rvpostplot","page":"RV plots with rvpostplot","title":"RV Visualization with rvpostplot","text":"While octoplot provides a broad overview of all your data and orbital fits, rvpostplot specializes in detailed visualization of radial velocity data. It creates a multi-panel figure showing:\n\nThe full RV time series with model fits\nResiduals from the model\nPhase-folded curves for each planet\n\nTwo versions are available:\n\nrvpostplot(model, chain): Shows a single posterior sample\nrvpostplot_animated(model, chain): Creates an animation cycling through different posterior samples\n\nHere is an example:\n\n(Image: )","category":"section"},{"location":"rvpostplot/#Basic-Usage","page":"RV plots with rvpostplot","title":"Basic Usage","text":"# Plot a single sample (by default, the maximum posterior sample)\nfig = rvpostplot(model, chain)\n\n# Create an animation\nfig = rvpostplot_animated(model, chain)","category":"section"},{"location":"rvpostplot/#Understanding-the-Plot-Panels","page":"RV plots with rvpostplot","title":"Understanding the Plot Panels","text":"","category":"section"},{"location":"rvpostplot/#Time-Series-Panel","page":"RV plots with rvpostplot","title":"Time Series Panel","text":"The top panel shows:\n\nRV measurements from each instrument (different colors)\nModel fits including any Gaussian Process stellar activity model\nError bars:\nColored bars: Raw measurement uncertainty\nGrey bars: Measurement + instrument jitter\nColored bands: uncertainty from the GP model (if used)\nOptional perspective aka. secular acceleration line for models based on AbsoluteVisual{...} orbit","category":"section"},{"location":"rvpostplot/#Residuals-Panel","page":"RV plots with rvpostplot","title":"Residuals Panel","text":"Shows the difference between the data and model. Note that in the residuals and phase-folded plots, the grey bars included the GP uncertainty too.","category":"section"},{"location":"rvpostplot/#Phase-Folded-Panels","page":"RV plots with rvpostplot","title":"Phase-Folded Panels","text":"For each planet in your model, a phase-folded panel shows:\n\nData folded at the planet's orbital period\nOther planet signals subtracted from the data\nBinned data points (red) with uncertainties\nModel curve in blue\n\nOptional text summary showing orbital parameters and uncertainties (pass show_summary = true)","category":"section"},{"location":"rvpostplot/#Detailed-Options-and-Customization","page":"RV plots with rvpostplot","title":"Detailed Options and Customization","text":"","category":"section"},{"location":"rvpostplot/#Panel-Selection","page":"RV plots with rvpostplot","title":"Panel Selection","text":"# Plot the maximum posterior sample with options\nrvpostplot(model, chain;\n    show_perspective=true,   # Show perspective acceleration line\n    show_summary=true,      # Show orbital parameter summary text\n)","category":"section"},{"location":"rvpostplot/#Orbit-Sample-Selection","page":"RV plots with rvpostplot","title":"Orbit Sample Selection","text":"By default, rvpostplot shows the maximum posterior sample. You can specify a different sample:\n\n# Plot a specific sample\ni_sample = 42\nfig = rvpostplot(model, chain, i_sample)\n\n# Plot the first sample\nfig = rvpostplot(model, chain, 1)","category":"section"},{"location":"rvpostplot/#Animation-Options","page":"RV plots with rvpostplot","title":"Animation Options","text":"The rvpostplot_animated function creates an animation that cycles through different posterior samples, helping visualize the range of orbits consistent with your data.\n\n# Basic animation with default settings\nanim = rvpostplot_animated(model, chain)\n\n# Customize animation parameters\nanim = rvpostplot_animated(model, chain;\n    N = 50,            # Number of frames (default)\n    framerate = 4,     # Frames per second\n    compression = 1,   # Video compression level\n    fname = \"rv-posterior.mp4\"  # Output filename\n)\n\nnote: Note\nThe default of 50 frames usually provides a good balance between smooth animation and reasonable processing time.","category":"section"},{"location":"rvpostplot/#Advanced-Animation-Control","page":"RV plots with rvpostplot","title":"Advanced Animation Control","text":"For fine-grained control over each frame, you can provide a callback function:\n\n# Example: Customize axis limits for each frame\nfunction adjust_frame(fig)\n    ax = fig.content[1]  # Get first axis\n    ylims!(ax, -100, 100)  # Set y limits\n    return fig\nend\n\nanim = rvpostplot_animated(model, chain, callback=adjust_frame)","category":"section"},{"location":"fit-interfere/#Fitting-Interferometric-Observables","page":"Interferometer Data","title":"Fitting Interferometric Observables","text":"In this tutorial, we fit a planet & orbit model to a sequence of interferometric observations. Closure phases and squared visibilities are supported.\n\nWe load the observations in OI-FITS format and model them as a point source orbiting a star.\n\nnote: Note\nInterferometer modelling is supported in Octofitter via the extension package OctofitterInterferometry. To install it, run  pkg> add http://github.com/sefffal/Octofitter.jl:OctofitterInterferometry\n\nusing Octofitter\nusing OctofitterInterferometry\nusing Distributions\nusing CairoMakie\nusing PairPlots\n\nDownload simulated JWST AMI observations from our examples folder on GitHub:\n\ndownload(\"https://github.com/sefffal/Octofitter.jl/raw/main/examples/AMI_data/Sim_data_2023_1_.oifits\", \"Sim_data_2023_1_.oifits\")\ndownload(\"https://github.com/sefffal/Octofitter.jl/raw/main/examples/AMI_data/Sim_data_2023_2_.oifits\", \"Sim_data_2023_2_.oifits\")\ndownload(\"https://github.com/sefffal/Octofitter.jl/raw/main/examples/AMI_data/Sim_data_2024_1_.oifits\", \"Sim_data_2024_1_.oifits\")\n\nCreate the likelihood object:\n\ndata = Table([\n    (; filename=\"Sim_data_2023_1_.oifits\", epoch=mjd(\"2023-06-01\"), use_vis2=false),\n    (; filename=\"Sim_data_2023_2_.oifits\", epoch=mjd(\"2023-08-15\"), use_vis2=false),\n    (; filename=\"Sim_data_2024_1_.oifits\", epoch=mjd(\"2024-06-01\"), use_vis2=false),\n])\nvis_obs = InterferometryObs(\n    data,\n    name=\"NIRISS-AMI\",\n    variables=@variables begin\n        # For single planet:\n        flux ~ truncated(Normal(0, 0.1), lower=0)  # Planet flux/contrast (array with one element)\n        \n        # For multiple planets (array - one per planet):\n        # flux ~ Product([truncated(Normal(0, 0.1), lower=0), truncated(Normal(0, 0.1), lower=0)])\n        \n        # Optional calibration parameters:\n        platescale = 1.0               # Platescale multiplier [could use: platescale ~ truncated(Normal(1, 0.01), lower=0)]\n        northangle = 0.0               # North angle offset in radians [could use: northangle ~ Normal(0, deg2rad(1))]\n        σ_cp_jitter = 0.0  # closure phase jitter [could use ~ LogUniform(0.1, 100))\n    end\n)\n\nnote: Note\nIf you want to include multiple bands, group these into different InterferometryObs objects with different instrument names (i.e. include the band in the name for the sake of bookkeeping)\n\nPlot the closure phases:\n\nfig = Makie.Figure()\nax = Axis(\n    fig[1,1],\n    xlabel=\"index\",\n    ylabel=\"closure phase\",\n)\nMakie.stem!(\n    vis_obs.table.cps_data[1][:],\n    label=\"epoch 1\",\n)\nMakie.stem!(\n    vis_obs.table.cps_data[2][:],\n    label=\"epoch 2\"\n)\nMakie.stem!(\n    vis_obs.table.cps_data[3][:],\n    label=\"epoch 3\"\n)\nMakie.Legend(fig[1,2], ax)\nfig\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[],\n    variables=@variables begin\n        M = system.M\n        a ~ truncated(Normal(2,0.1), lower=0.1)\n        e ~ truncated(Normal(0, 0.05),lower=0, upper=0.90)\n        i ~ Sine()\n        ω ~ UniformCircular()\n        Ω ~ UniformCircular()\n\n        θ ~ UniformCircular()\n        tp = θ_at_epoch_to_tperi(θ, 60171; M, e, a, i, ω, Ω)  # reference epoch for θ. Choose an MJD date near your data.\n    end\n)\n\nsys = System(\n    name=\"Tutoria\",\n    companions=[planet_b],\n    observations=[vis_obs],\n    variables=@variables begin\n        M ~ truncated(Normal(1.5, 0.01), lower=0.1)\n        plx ~ truncated(Normal(100., 0.1), lower=0.1)\n    end\n)\n\nCreate the model object and run octofit_pigeons:\n\nmodel = Octofitter.LogDensityModel(sys)\n\nusing Pigeons\nresults,pt = octofit_pigeons(model, n_rounds=10);\nnothing # hide\n\nNote that we use Pigeons paralell tempered sampling (octofit_pigeons) instead of HMC (octofit) because interferometry data is almost always multi-modal (or more precisely non-convex, there is often still a single mode that dominates).\n\nExamine the recovered photometry posterior:\n\nhist(results[:NIRISS_AMI_flux][:], axis=(;xlabel=\"flux\"))\n\nDetermine the significance of the detection:\n\nusing Statistics\nphot = results[:NIRISS_AMI_flux][:]\nsnr = mean(phot)/std(phot)\n\nPlot the resulting orbit:\n\noctoplot(model, results)\n\nPlot only the position at each epoch:\n\nusing PlanetOrbits\nels = Octofitter.construct_elements(model, results,:b,:);\nfig = Makie.Figure()\nax = Makie.Axis(\n    fig[1,1],\n    autolimitaspect = 1,\n    xreversed=true,\n    xlabel=\"ΔR.A. (mas)\",\n    ylabel=\"ΔDec. (mas)\",\n)\nfor epoch in vis_obs.table.epoch\n    Makie.scatter!(\n        ax,\n        raoff.(els, epoch)[:],\n        decoff.(els, epoch)[:],\n        label=string(mjd2date(epoch)),\n        markersize=1.5,\n    )\nend\nMakie.Legend(fig[1,2], ax, \"date\")\nfig\n\nFinally we can examine the joint photometry and orbit posterior as a corner plot:\n\nusing PairPlots\nusing CairoMakie: Makie\noctocorner(model, results)","category":"section"},{"location":"priors/#priors","page":"Priors","title":"Priors","text":"All parameters to your model must have a prior defined. You may provide any continuous, univariate distribution from the Distributions.jl. A few useful distributions include:\n\nNormal\nUniform\nLogNormal\nLogUniform\nTrucatedNormal\nVonMises\n\nThis pacakge also defines the Sine() distribution for e.g. inclination priors and UniformCircular() for periodic variables. Internally, UniformCircular() creates two standard normal variables and finds the angle between them using arctan. This allows the sampler to smoothly cycle past the ends of the domain. You can specify a different circular domain than (0,2pi) by passing the size of the domain e.g. τ = UniformCircular(1.0).\n\nThe VonMise distribution is notable but not commonly used. It is the analog of a normal distribution defined on a circular domain (-π, +π). If you have a Gaussian prior on an angular parameter, a Von Mises distribution is probably more appropriate.\n\nBehind the scenes, Octofitter remaps your parameters to unconstrained domains using the Bijectors.jl (and corrects the priors accordingly). This is essential for good sampling efficiency with HMC based samplers.\n\nThis means that e.g. if you define the eccentricity prior as e=Uniform(0,0.5), the sampler will actually generate values across the whole real line and transform them back into the [0,0.5] range before evaluating the orbit. It is therefore essential that your priors do not include invalid domains.\n\nFor example, setting a=Normal(3,2) will result in poor sampling efficiency as sometimes negative values for semi-major axis will be drawn (especially if you're using the parallel tempered sampler).\n\nInstead, for parameters like semi-major axis, eccentricity, parallax, and masses, you should truncate any distributions that have negative tails. This can easily be accomplished with TrauncatedNormal or Trunacted(dist, low, high) for any arbitrary distribution.","category":"section"},{"location":"priors/#Kernel-Density-Estimate-Priors","page":"Priors","title":"Kernel Density Estimate Priors","text":"Octofitter has support for sampling from smoothed kernel density estimate priors. These are non-parametric distributions fit to a 1D dataset consisting of random draws. This is one way to include the output of a different model as the prior to a new model. That said, it's usually best to try and incorporate the model directly into the code. There are a few examples on GitHub of this, including atmosphere model grids, cooling tracks, etc.","category":"section"},{"location":"priors/#Using-a-KDE","page":"Priors","title":"Using a KDE","text":"First, we will generate some data. In the real world, you would load this data eg. from a CSV file.\n\nusing Octofitter, Distributions\n\n# create a smoothed KDE estimate of the samples from a 10+-1 gaussian\nkde = Octofitter.KDEDist(randn(1000).+10)\n\nNote that in Octofitter the KDE will have its support truncated to the minimum and maximum values that occur in your dataset, ie. it doesn't allow for infinite long tails.\n\nNow add it to your model as a prior:\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[],\n    variables=@variables begin\n        a ~ kde # Sample from the KDE here\n        e ~ Uniform(0.0, 0.99)\n        i ~ Sine()\n        M = system.M\n        ω ~ UniformCircular()\n        Ω ~ UniformCircular()\n        θ ~ UniformCircular()\n        tp = θ_at_epoch_to_tperi(θ, 50000; M, e, a, i, ω, Ω)\n    end\n)\n\nsys = System(\n    name=\"Tutoria\",\n    companions=[planet_b],\n    observations=[],\n    variables=@variables begin\n        M ~ truncated(Normal(1.2, 0.1), lower=0.1)\n        plx ~ truncated(Normal(50.0, 0.02), lower=0.1)\n    end\n)\n\nmodel = Octofitter.LogDensityModel(sys)\nchain = octofit(model)\n\nWe now examine the posterior and verify that it matches our KDE prior:\n\ndat = chain[:b_a][:]\n@show mean(dat) std(dat)\nnothing # hide","category":"section"},{"location":"priors/#Observable-Based-Priors","page":"Priors","title":"Observable Based Priors","text":"Octofitter implements observable-based priors from O'Neil 2019 for relative astrometry. You can fit a model to astrometry using observable-based priors using the following recipe:\n\nusing Octofitter, Distributions\n\nastrom_dat = Table(\n    epoch=[mjd(\"2020-12-20\")], \n    ra=[400.0], \n    σ_ra=[5.0], \n    dec=[400.0], \n    σ_dec=[5.0]\n)\nastrom_obs = PlanetRelAstromObs(astrom_dat, name=\"rel astrom. 1\")\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[ObsPriorAstromONeil2019(astrom_obs)],\n    variables=@variables begin\n        # For using with ObsPriors:\n        P ~ Uniform(0.001, 1000)\n        M = system.M\n        a = cbrt(M * P^2)\n\n        e ~ Uniform(0.0, 1.0)\n        i ~ Sine()\n        ω ~ UniformCircular()\n        Ω ~ UniformCircular()\n        mass ~ LogUniform(0.01, 100)\n\n        τ ~ UniformCircular(1.0)\n        tp = τ*P*365.25 + 58849 # reference epoch for τ. Choose an MJD date near your data.\n    end\n)\n\nsys = System(\n    name=\"System1\",\n    companions=[planet_b],\n    observations=[],\n    variables=@variables begin\n        plx ~ Normal(21.219, 0.060)\n        M ~ truncated(Normal(1.1, 0.2),lower=0.1)\n    end\n)","category":"section"},{"location":"fit-coplanar/#Hierarchical-Co-Planar,-Near-Resonant-Model","page":"Resonant Co-Planar Model","title":"Hierarchical Co-Planar, Near-Resonant Model","text":"This example shows how you can fit a two planet model to relative astrometry data. This functionality would work equally well with RV, images, etc.\n\nWe will demonstrate two models: the first, where the planets are exactly co-planar (using a single set of variables for the inlination and position angle of ascending node for both planets), and a second, where the planets are approximately co-planar according to a custom prior.\n\nFor this example, we will use astrometry from the HR8799 system collated by Jason Wang and retrieved from the website Whereistheplanet.com.","category":"section"},{"location":"fit-coplanar/#Data","page":"Resonant Co-Planar Model","title":"Data","text":"using Octofitter\nusing CairoMakie\nusing PairPlots\nusing Distributions\nusing PlanetOrbits\n\nastrom_dat_b = Table(;\n    epoch = [53200.0, 54314.0, 54398.0, 54727.0, 55042.0, 55044.0, 55136.0, 55390.0, 55499.0, 55763.0, 56130.0, 56226.0, 56581.0, 56855.0, 58798.03906, 59453.245, 59454.231],\n    ra    = [1471.0, 1504.0, 1500.0, 1516.0, 1526.0, 1531.0, 1524.0, 1532.0, 1535.0, 1541.0, 1545.0, 1549.0, 1545.0, 1560.0, 1611.002, 1622.924, 1622.872],\n    dec   = [887.0, 837.0, 836.0, 818.0, 797.0, 794.0, 795.0, 783.0, 766.0, 762.0, 747.0, 743.0, 724.0, 725.0, 604.893, 570.534, 571.296],\n    σ_ra  = [6.0, 3.0, 7.0, 4.0, 4.0, 7.0, 10.0, 5.0, 15.0, 5.0, 5.0, 4.0, 22.0, 13.0, 0.133, 0.32, 0.204],\n    σ_dec = [6.0, 3.0, 7.0, 4.0, 4.0, 7.0, 10.0, 5.0, 15.0, 5.0, 5.0, 4.0, 22.0, 13.0, 0.199, 0.296, 0.446],\n    cor   = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.406, -0.905, -0.79]\n)\n\nastrom_dat_c = Table(;\n    epoch = [53200.0, 54314.0, 54398.0, 54727.0, 55042.0, 55136.0, 55390.0, 55499.0, 55763.0, 56130.0, 56226.0, 56581.0, 56855.0],\n    ra    = [-739.0, -683.0, -678.0, -663.0, -639.0, -636.0, -619.0, -607.0, -595.0, -578.0, -572.0, -542.0, -540.0],\n    dec   = [612.0, 671.0, 678.0, 693.0, 712.0, 720.0, 728.0, 744.0, 747.0, 761.0, 768.0, 784.0, 799.0],\n    σ_ra  = [6.0, 4.0, 7.0, 3.0, 4.0, 9.0, 4.0, 12.0, 4.0, 5.0, 3.0, 22.0, 12.0],\n    σ_dec = [6.0, 4.0, 7.0, 3.0, 4.0, 9.0, 4.0, 12.0, 4.0, 5.0, 3.0, 22.0, 12.0],\n    cor   = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n)\n\nastrom_b = PlanetRelAstromObs(\n    astrom_dat_b,\n    name = \"GPI\",\n    variables = @variables begin\n        # Fixed values for this example - could be free variables:\n        jitter = 0        # mas [could use: jitter ~ Uniform(0, 10)]\n        northangle = 0    # radians [could use: northangle ~ Normal(0, deg2rad(1))]\n        platescale = 1    # relative [could use: platescale ~ truncated(Normal(1, 0.01), lower=0)]\n    end\n)\n\nastrom_c = PlanetRelAstromObs(\n    astrom_dat_c,\n    name = \"GPI\",\n    variables = @variables begin\n        # Fixed values for this example - could be free variables:\n        jitter = 0        # mas [could use: jitter ~ Uniform(0, 10)]\n        northangle = 0    # radians [could use: northangle ~ Normal(0, deg2rad(1))]\n        platescale = 1    # relative [could use: platescale ~ truncated(Normal(1, 0.01), lower=0)]\n    end\n)\n\nfig = scatter(astrom_b.table.ra, astrom_b.table.dec, axis=(;autolimitaspect=1))\nscatter!(astrom_c.table.ra, astrom_c.table.dec)\nscatter!([0], [0], marker='⋆', markersize=50, color=:black)\nfig","category":"section"},{"location":"fit-coplanar/#Exact-Co-Planar-Model","page":"Resonant Co-Planar Model","title":"Exact Co-Planar Model","text":"This model will use a single pair of i and Ω variables for both planets to enforce exact co-planarity.\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[astrom_b],\n    variables=@variables begin\n        e = 0.0\n        ω = 0.0\n        M_pri = system.M_pri\n        M_b = system.M_b\n        M_c = system.M_c\n        M = M_pri + M_b*Octofitter.mjup2msol + M_c*Octofitter.mjup2msol\n        mass = M_b\n\n        # Use the system inclination and longitude of ascending node\n        # variables\n        i = system.i\n        Ω = system.Ω\n\n        # Specify the period as ~ 1% around 2X the P_nominal variable\n        P_mul ~ Normal(1, 0.1)\n        P_nominal = system.P_nominal\n        P = 2*P_nominal * P_mul\n\n        a = cbrt(M * P^2)\n        θ ~ UniformCircular()\n        tp = θ_at_epoch_to_tperi(θ, 59454.231; M, e, a, i, ω, Ω)  # reference epoch for θ. Choose an MJD date near your data.\n    end\n)\n\nplanet_c = Planet(\n    name=\"c\",\n    basis=Visual{KepOrbit},\n    observations=[astrom_c],\n    variables=@variables begin\n        e = 0.0\n        ω = 0.0\n        M_pri = system.M_pri\n        M_b = system.M_b\n        M_c = system.M_c\n        M = M_pri + M_b*Octofitter.mjup2msol\n        mass = M_c\n\n        # Use the system inclination and longitude of ascending node\n        # variables\n        i = system.i\n        Ω = system.Ω\n\n        # Specify the period as ~ 1% the P_nominal variable\n        P_mul ~ truncated(Normal(1, 0.1), lower=0.1)\n        P_nominal = system.P_nominal\n        P = P_nominal * P_mul\n\n        a = cbrt(M * P^2)\n\n        θ ~ UniformCircular()\n        tp = θ_at_epoch_to_tperi(θ, 59454.231; M, e, a, i, ω, Ω)  # reference epoch for θ. Choose an MJD date near your data.\n    end\n)\n\nsys = System(\n    name=\"HR8799_res_co\",\n    companions=[planet_b, planet_c],\n    observations=[],\n    variables=@variables begin\n        plx ~ gaia_plx(;gaia_id=2832463659640297472)\n        M_pri ~ truncated(Normal(1.5, 0.02), lower=0.1)\n        M_b ~ Uniform(0, 12)\n        M_c ~ Uniform(0, 12)\n        # We create inclination and longitude of ascending node variables at the\n        # system level.\n        i ~ Sine()\n        Ω ~ UniformCircular()\n        # We create a nominal period of planet c variable. \n        P_nominal ~ Uniform(50, 300) # years\n    end\n)\n\nmodel = Octofitter.LogDensityModel(sys)\n\nInitialize the starting points, and confirm the data are entered correcly:\n\ninit_chain = initialize!(model, (;\n    plx =24.4549,\n  M_pri = 1.48,\n    M_b = 5.73,\n    M_c = 5.14,\n    P_nominal = 230,\n))\noctoplot(model, init_chain)\n\nNow sample from the model using Pigeons parallel tempering:\n\nusing Pigeons\nresults,pt = octofit_pigeons(model, n_rounds=10);\nnothing # hide\n\nPlots the orbits:\n\noctoplot(model, results)\n\nCorner plot:\n\noctocorner(model, results, small=true)\n\nNow examine the period ratio:\n\nhist(\n    results[:b_P][:] ./ results[:c_P][:],\n    axis=(;\n        xlabel=\"period ratio\",\n        ylabel=\"counts\",\n    )\n)","category":"section"},{"location":"fit-coplanar/#Approximately-Co-Planar-Model","page":"Resonant Co-Planar Model","title":"Approximately Co-Planar Model","text":"We now set up two planets with their own separate i and Ω variables, calculate the mutual inclination, and add a prior that this mutual inclination is 0 pm 10 degree.\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[astrom_b],\n    variables=@variables begin\n        e = 0.0\n        ω = 0.0\n        M_pri = system.M_pri\n        M_b = system.M_b\n        M_c = system.M_c\n        M = M_pri + M_b*Octofitter.mjup2msol + M_c*Octofitter.mjup2msol\n        mass = M_b\n\n        # Use the system inclination and longitude of ascending node\n        # variables\n        i = system.i_b\n        Ω = system.Ω_b\n\n        # Specify the period as ~ 1% around 2X the P_nominal variable\n        P_mul ~ Normal(1, 0.1)\n        P_nominal = system.P_nominal\n        P = 2*P_nominal * P_mul\n\n        a = cbrt(M * P^2)\n        θ ~ UniformCircular()\n        tp = θ_at_epoch_to_tperi(θ, 59454.231; M, e, a, i, ω, Ω)  # reference epoch for θ. Choose an MJD date near your data.\n    end\n)\n\nplanet_c = Planet(\n    name=\"c\",\n    basis=Visual{KepOrbit},\n    observations=[astrom_c],\n    variables=@variables begin\n        e = 0.0\n        ω = 0.0\n        M_pri = system.M_pri\n        M_b = system.M_b\n        M_c = system.M_c\n        M = M_pri + M_b*Octofitter.mjup2msol\n        mass = M_c\n\n        # Use the system inclination and longitude of ascending node\n        # variables\n        i = system.i_c\n        Ω = system.Ω_c\n\n        # Specify the period as ~ 1% the P_nominal variable\n        P_mul ~ truncated(Normal(1, 0.1), lower=0.1)\n        P_nominal = system.P_nominal\n        P = P_nominal * P_mul\n\n        a = cbrt(M * P^2)\n\n        θ ~ UniformCircular()\n        tp = θ_at_epoch_to_tperi(θ, 59454.231; M, e, a, i, ω, Ω)  # reference epoch for θ. Choose an MJD date near your data.\n    end\n)\n\nsys = System(\n    name=\"HR8799_approx_res_co\",\n    companions=[planet_b, planet_c],\n    observations=[],\n    variables=@variables begin\n        plx ~ gaia_plx(;gaia_id=2832463659640297472)\n        M_pri ~ truncated(Normal(1.5, 0.02), lower=0.1)\n        M_b ~ Uniform(0, 12)\n        M_c ~ Uniform(0, 12)\n        # We create inclination and longitude of ascending node variables at the\n        # system level.\n        i_b ~ Sine()\n        Ω_b ~ UniformCircular()\n\n        i_c ~ Sine()\n        Ω_c ~ UniformCircular()\n\n\n        # Calculate the mutual inclination\n        mut_inc_b_c = acos(\n            cos(i_b) * cos(i_c) +\n            sin(i_b) * sin(i_c) * cos(Ω_b - Ω_c)\n        )\n        # Add a prior on the mutual inclination\n        mut_inc_b_c ~ truncated(Normal(0, 10), lower=0)\n\n        # We create a nominal period of planet c variable. \n        P_nominal ~ Uniform(50, 300) # years\n    end\n)\n\nmodel = Octofitter.LogDensityModel(sys)\n\nInitialize the starting points, and confirm the data are entered correcly:\n\ninit_chain = initialize!(model, (;\n    plx =24.4549,\n    M_pri = 1.48,\n    M_b = 5.73,\n    M_c = 5.14,\n    P_nominal = 230,\n))\noctoplot(model, init_chain)\n\nNow sample from the model using Pigeons parallel tempering:\n\nusing Pigeons\nresults,pt = octofit_pigeons(model, n_rounds=10);\nnothing # hide\n\nPlots the orbits:\n\noctoplot(model, results)\n\nCorner plot:\n\noctocorner(model, results, small=true)\n\nNow examine the mutual inclination:\n\nhist(\n    rad2deg.( results[:mut_inc_b_c][:] ),\n    axis=(;\n        xlabel=\"mutual inclination [deg]\",\n        ylabel=\"counts\",\n    )\n)","category":"section"},{"location":"fit-rv-astrom/#fit-rv-astrom","page":"RV and Relative Astrometry","title":"Fit Radial Velocity and Astrometry","text":"You can use Octofitter to jointly fit relative astrometry data and radial velocity data.  Below is an example. For more information on these functions, see previous guides.\n\nImport required packages\n\nusing Octofitter\nusing OctofitterRadialVelocity\nusing CairoMakie\nusing PairPlots\nusing Distributions\nusing PlanetOrbits\n\nWe now use PlanetOrbits.jl to create sample data. We start with a template orbit and record it's positon and velocity at a few epochs.\n\norb_template = orbit(\n    a = 1.0,\n    e = 0.7,\n    i= pi/4,\n    Ω = 0.1,\n    ω = 1π/4,\n    M = 1.0,\n    plx=100.0,\n    m =0,\n    tp =58829-40\n)\nMakie.lines(orb_template,axis=(;autolimitaspect=1))\n\nSample position and store as relative astrometry measurements:\n\nepochs = [58849,58852,58858,58890]\nastrom_dat = Table(\n    epoch=epochs,\n    ra=raoff.(orb_template, epochs),\n    dec=decoff.(orb_template, epochs),\n    σ_ra=fill(1.0, size(epochs)),\n    σ_dec=fill(1.0, size(epochs)),\n    cor=fill(0.0, size(epochs))\n)\n\nastrom = PlanetRelAstromObs(\n    astrom_dat,\n    name = \"simulated\",\n    variables = @variables begin\n        # Fixed values for this example - could be free variables:\n        jitter = 0        # mas [could use: jitter ~ Uniform(0, 10)]\n        northangle = 0    # radians [could use: northangle ~ Normal(0, deg2rad(1))]\n        platescale = 1    # relative [could use: platescale ~ truncated(Normal(1, 0.01), lower=0)]\n    end\n)\n\nAnd plot our simulated astrometry measurments:\n\nfig = Makie.lines(orb_template,axis=(;autolimitaspect=1))\nMakie.scatter!(astrom.table.ra, astrom.table.dec)\nfig\n\nGenerate a simulated RV curve from the same orbit:\n\nusing Random\nRandom.seed!(1)\n\nepochs = 58849 .+ range(0,step=1.5, length=20)\nplanet_sim_mass = 0.001 # solar masses here\n\n\nrvlike = MarginalizedStarAbsoluteRVObs(\n    Table(\n        epoch=epochs,\n        rv=radvel.(orb_template, epochs, planet_sim_mass) .+ 150,\n        σ_rv=fill(5.0, size(epochs)),\n    ),\n    name=\"inst1\",\n    variables=@variables begin\n        jitter ~ LogUniform(0.1, 100) # m/s\n    end\n)\n\nepochs = 58949 .+ range(0,step=1.5, length=20)\n\nrvlike2 = MarginalizedStarAbsoluteRVObs(\n    Table(\n        epoch=epochs,\n        rv=radvel.(orb_template, epochs, planet_sim_mass) .- 150,\n        σ_rv=fill(5.0, size(epochs)),\n    ),\n    name=\"inst2\",\n    variables=@variables begin\n        jitter ~ LogUniform(0.1, 100) # m/s\n    end\n)\n\nfap = Makie.scatter(rvlike.table.epoch[:], rvlike.table.rv[:])\nMakie.scatter!(rvlike2.table.epoch[:], rvlike2.table.rv[:])\nfap\n\nNow specify model and fit it:\n\n\nplanet_b = Planet(\n    name=\"b\",\n    basis=Visual{KepOrbit},\n    observations=[astrom],\n    variables=@variables begin\n        e ~ Uniform(0,0.999999)\n        a ~ truncated(Normal(1, 1),lower=0.1)\n        mass ~ truncated(Normal(1, 1), lower=0.)\n        i ~ Sine()\n        M = system.M\n        Ω ~ UniformCircular()\n        ω ~ UniformCircular()\n        θ ~ UniformCircular()\n        tp = θ_at_epoch_to_tperi(θ, 58849.0; M, e, a, i, ω, Ω)  # reference epoch for θ. Choose an MJD date near your data.\n    end\n)\n\nsys = System(\n    name=\"test\",\n    companions=[planet_b],\n    observations=[rvlike, rvlike2],\n    variables=@variables begin\n        M ~ truncated(Normal(1, 0.04),lower=0.1) # (Baines & Armstrong 2011).\n        plx = 100.0\n    end\n)\n\nmodel = Octofitter.LogDensityModel(sys)\n\nusing Random\nrng = Xoshiro(0) # seed the random number generator for reproducible results\n\nresults = octofit(rng, model, max_depth=9, adaptation=300, iterations=400)\n\nDisplay results as a corner plot:\n\noctocorner(model,results, small=true)\n\nPlot RV curve, phase folded curve, and binned residuals:\n\nOctofitter.rvpostplot(model, results)\n\nDisplay RV, PMA, astrometry, relative separation, position angle, and 3D projected views:\n\noctoplot(model, results)","category":"section"},{"location":"samplers/#samplers","page":"Sampler","title":"Samplers","text":"We recommend using one of the following MCMC samplers:\n\nNo U-turn Hamiltonian Monte Carlo (via octofit)\nNon-reversible parallel tempered Monte Carlo  (via octofit_pigeons)\n\nMany additional samplers can be used through the LogDensityProblems.jl interface, but they are not tested.","category":"section"},{"location":"samplers/#Workflow","page":"Sampler","title":"Workflow","text":"When you're testing a new model and/or data, we recommend you test it quickly with Pathfinder (chains = octoquick(model)). This will return a rough approximation of the posterior and will pick up if it contains multiple modes. \n\nIf the posterior is unimodal (even if it has a complicated shape), go ahead and use AdvancedHMC (chains = octofit(model)). This uses a single computer core and is in many cases very efficient.\n\nIf the posterior is multimodal, and the modes are quite separated, then use Pigeons (chains, pt = octofit_pigeons(model, n_rounds=12)).\n\nRead mode about these samplers below.","category":"section"},{"location":"samplers/#Pathfinder","page":"Sampler","title":"Pathfinder","text":"You can use the function octoquick to generate a very rough approximation of the posterior. This uses the multi-pathfinder approximate inference algorithm.\n\nThe useage of octoquick is similar to octofit:\n\nchain = octoquick(model)\n\nThese results are not statistically meaningful, but should give you some very rough idea of how the model fits the data in just a few seconds.","category":"section"},{"location":"samplers/#Hamiltonian-Monte-Carlo-(NUTS)","page":"Sampler","title":"Hamiltonian Monte Carlo (NUTS)","text":"The recommended choice for almost all problems is Hamiltonian Monte Carlo. It can be run using the octofit function:\n\nchain = octofit(model)\n\nnote: Note\nStart julia with julia --threads=auto to make sure you have multiple threads available. octofit is single-threaded, but may calculate the likelihood of your model in parallel if you have many data points (100s or more).\n\nThis sampling  method makes use of derivative information, and is much more efficient. This package by default uses the No U-Turn sampler, as implemented in AdvancedHMC.jl.\n\nDerviatives for a complex model are usualy tedious to code, but Octofitter uses ForwardDiff.jl to generate them automatically.\n\nWhen using HMC, only a few chains are necessary. This is in contrast to Affine Invariant MCMC based packages where hundreds or thousands of walkers are required. One chain should be enough to cover the whole posterior, but you can run a few different chains to make sure each has converged to the same distribution.\n\nSimilarily, fewer samples are required. This is because unlike Affine Invariant MCMC, HMC produces samples that are much less correlated after each step (i.e. the autocorrelation time is much shorter).\n\noctofit will internally use Pathfinder to warm up the sampler, reducing convergence times signficantly. \n\nThe method signature of octofit is as follows:\n\noctofit(\n    [rng::Random.AbstractRNG],\n    model::Octofitter.LogDensityModel,\n    target_accept::Number=0.8,\n    adaptation=1000,\n    iterations=1000,\n    drop_warmup=true,\n    max_depth=12,\n    verbosity=2,\n)\n\nThe only required arguments are model, adaptation, and iterations. The two positional arguments are model, the model you wish to sample; and target_accept, the acceptance rate that should be targeted during windowed adaptation. During this time, the step size and mass matrix will be adapted (see AdvancedHMC.jl for more information). The number of steps taken during adaptation is controlled by adaptation. You can prevent these samples from being dropped by pasing include_adaptation=false. The total number of posterior samples produced are given by iterations. These include the adaptation steps that may be discarded. max_depth controls the maximum tree depth of the sampler. ","category":"section"},{"location":"samplers/#Pigeons-Non-Reversible-Parallel-Tempering","page":"Sampler","title":"Pigeons Non-Reversible Parallel Tempering","text":"Pigeons implements non-reversible parallel tempering. You can read more about it here: http://pigeons.run. Pigeons is slower if you only run it on a single (or a few) computer cores, but can scale up very well over many cores or compute nodes. It can reliably sample from multimodal posteriors.\n\nnote: Note\n\n\nPigeons must be installed as a separate package install it, run      pkg> add Pigeons\n\nPigeons can be run locally with one or more Julia threads.\n\nnote: Note\nStart julia with julia --threads=auto to make sure you have multiple threads available for sampling.\n\nYou can get started with Pigeons by running:\n\nusing Pigeons\nmodel = Octofitter.LogDensityModel(System)\nchain, pt = octofit_pigeons(model)\n\nThe method signature of octofit_pigeons is as follows:\n\nchain, pt = octofit_pigeons(\n    target::Octofitter.LogDensityModel;\n    n_rounds::Int,\n    pigeons_kw... # forwarded to Pigeons.Inputs\n)\n\nBy default, this will use:\n\n16 chains between the posterior and the prior\n16 chains between the posterior and a variational reference\nthe SliceSampler local explorer\n\nThe number of chains should ideally be set to twice the value of Λ in the resulting table. If you notice Λ is not approximately 8, you should adjust n_chains and n_chains_variational to be approximately twice the value of Λ and Λ_var respectively.\n\nA nice feature of Pigeons is that you can resume sampler for additional rounds without having to start over:\n\npt = increment_n_rounds!(pt, 1)\nchain, pt = octofit_pigeons(pt)","category":"section"},{"location":"samplers/#Distributed-Sampling","page":"Sampler","title":"Distributed Sampling","text":"This guide shows how you can sample from Octofitter models using a cluster. If you just want to sample across multiple cores on the same computer, start julia with multiple threads (julia --threads=auto) and use octofit_pigeons.\n\nIf your problem is challenging enough to benefit from parallel sampling across multiple nodes in a cluster, you might consider using Pigeons with MPI by following this guide. ","category":"section"},{"location":"samplers/#MPI-Launcher-Script","page":"Sampler","title":"MPI Launcher Script","text":"We will use a Julia script to submit the batch job to the cluster. The script will define the model and start the sampling process. The sampler can then run in the background, and you can periodically load the results in from the checkpoint file to examine them after each round of sampling.\n\nHere is an example:\n\nusing Octofitter\nusing OctofitterRadialVelocity\nusing PlanetOrbits\nusing CairoMakie\nusing PairPlots\nusing DataFrames\nusing Distributions\n\n# Specify your data as usual\nastrom_obs = PlanetRelAstromObs(\n    # Your data here:\n    (epoch = 50000, ra = -505.7637580573554, dec = -66.92982418533026, σ_ra = 10, σ_dec = 10, cor=0),\n    (epoch = 50120, ra = -502.570356287689, dec = -37.47217527025044, σ_ra = 10, σ_dec = 10, cor=0),\n    (epoch = 50240, ra = -498.2089148883798, dec = -7.927548139010479, σ_ra = 10, σ_dec = 10, cor=0),\n    (epoch = 50360, ra = -492.67768482682357, dec = 21.63557115669823, σ_ra = 10, σ_dec = 10, cor=0),\n    (epoch = 50480, ra = -485.9770335870402, dec = 51.147204404903704, σ_ra = 10, σ_dec = 10, cor=0),\n    (epoch = 50600, ra = -478.1095526888573, dec = 80.53589069730698, σ_ra = 10, σ_dec = 10, cor=0),\n    (epoch = 50720, ra = -469.0801731788123, dec = 109.72870493064629, σ_ra = 10, σ_dec = 10, cor=0),\n    (epoch = 50840, ra = -458.89628893460525, dec = 138.65128697876773, σ_ra = 10, σ_dec = 10, cor=0),\n)\n\n# build your model as usual\n@planet b Visual{KepOrbit} begin\n    a ~ Uniform(0, 100) # AU\n    e ~ Uniform(0.0, 0.99)\n    i ~ Sine() # radians\n    ω ~ UniformCircular()\n    Ω ~ UniformCircular()\n    θ ~ UniformCircular()\n    tp = θ_at_epoch_to_tperi(system,b,50000) # use MJD epoch of your data here!!\nend astrom_obs\n@system Tutoria begin # replace Tutoria with the name of your planetary system\n    M ~ truncated(Normal(1.2, 0.1), lower=0.1)\n    plx ~ truncated(Normal(50.0, 0.02), lower=0.1)\nend b\nmodel = Octofitter.LogDensityModel(Tutoria)","category":"section"},{"location":"samplers/#Launcher-Script","page":"Sampler","title":"Launcher Script","text":"Use this script to launch your MPI job.\n\ninclude(\"distributed-model.jl\")\npt = pigeons(\n    target = Pigeons.LazyTarget(MyLazyTarget()),\n    record = [traces; round_trip; record_default()],\n    on = Pigeons.MPIProcesses(\n        n_mpi_processes = n_chains,\n        n_threads = 1,\n        dependencies = [abspath(\"distributed-model.jl\")]\n    ),\n    # Pass additional flags to the HPC scheduler here\n    # See here for more details: https://pigeons.run/stable/reference/#Pigeons.MPIProcesses\n    # add_to_submission = [\"#PBS -A my_user_allocation_code\"] # pbs\n    add_to_submission = [ # slurm\n        \"#SBATCH --account=my_user_name\",\n        \"#SBATCH --time=24:00:00\",\n    ],\n     # HPC modules to load on each worker\n    environment_modules: [\"StdEnv/2023\", \"intel\", \"openmpi\", \"julia/1.10\", \"hdf5\"]\n)\n\ninfo: Info\nDon't submit this script to your cluster. Run it on a login node and it will submit the job for you.","category":"section"},{"location":"samplers/#Troubleshooting","page":"Sampler","title":"Troubleshooting","text":"If you run into library issues with MPI and/or HDF5, you may need to tell Julia to use the system provided versions. \n\nHere is an example that works on AllianceCanada clusters, and may be adaptable to other slurm-based systems:\n\nusing Preferences, HDF5\n\nset_preferences!(\n    HDF5,\n    \"libhdf5\" => ENV[\"EBROOTHDF5\"]*\"/lib/libhdf5_hl.so\",\n    \"libhdf5_hl\" => ENV[\"EBROOTHDF5\"]*\"/lib/libhdf5_hl.so\",\n    force = true\n)\n\nmodelfname = ARGS[1]\nn_proc = parse(Int, ARGS[2])\n\nPigeons.setup_mpi(\n    submission_system = :slurm,\n    environment_modules = [\"StdEnv/2023\", \"intel\", \"openmpi\", \"julia/1.10\", \"hdf5\"],\n    library_name = ENV[\"EBROOTOPENMPI\"]*\"/lib/libmpi\",\n    add_to_submission = [\n        \"#SBATCH --time=24:00:00\",\n        \"#SBATCH --account=def-account-name\",\n        \"#SBATCH --mem-per-cpu=8g\"\n    ]\n)\nprintln(\"Setup MPIProcesses\")","category":"section"},{"location":"samplers/#Examine-Results","page":"Sampler","title":"Examine Results","text":"After one or more sampling rounds have completed, you can run this command to load the results so far for analysis.\n\n\n# If still in current session, just pass the `pt` object:\nresults = Chains(model, pt)\n\n# Else, if the sampling has been running in the background, run:\npt = PT(mpi_run)\nmodel = pt.inputs.target\nresults = Chains(model, pt)\n\n\noctocorner(model, results, small=true)","category":"section"},{"location":"samplers/#Advanced-Usage:-Additional-Samplers","page":"Sampler","title":"Advanced Usage: Additional Samplers","text":"This section is for people interested in developing support for new samplers with Octofitter.\n\nOctofitter converts your model specification into an Octofitter.LogDensityModel which implements the LogDensityProblems.jl interface.\n\nThat way, you can sample from your model using a wide variety of Julia based samplers. These samplers may return results in less convenient formats, and for example, may need you to map their results back to the natural domain of your variables using model.link or model.invlink.\n\nFor convenience, Octofitter bundles special support for the No U-Turn Sampler (NUTS) as implemented by AdvancedHMC.jl (see above).\n\nIn order to use the results of most other samplers, you will need a function to map results from their transformed variables back to their natural domain and reconstruct the chains:\n\n# Results are in normalized parameter space and need to be mapped back to their constrained support\n\n# Function to map the samples back to their natural domain\nfunction remapchain(mc_samples)\n    logpost = map(s->s.lp, mc_samples)\n    # Transform samples back to constrained support\n    samples = map(mc_samples) do s\n        θ_t = s.params\n        θ = model.invlink(θ_t)\n        return θ\n    end\n    chain_res = model.arr2nt.(samples)\n    chain = Octofitter.result2mcmcchain(chain_res)\n    return MCMCChains.setinfo(\n        chain,\n        (;\n            # start_time,\n            # stop_time,\n            model=model.system,\n            logpost=logpost,\n        )\n    )\nend","category":"section"},{"location":"samplers/#AdvancedMH","page":"Sampler","title":"AdvancedMH","text":"Here is an example of using a separate package to sample from a model–-in this case, AdvancedHM. For other packages, see their documentation for full details.\n\nNote: this sampler does not work well and is just provided as a reference for how to use an arbitrary sampling package.\n\nusing AdvancedMH\nusing MCMCChains: Chains\n\n# Construct model from a system (see elsewhere in docs)\nmodel = Octofitter.LogDensityModel(system)\n\n# Set up a random walk sampler with a joint multivariate Normal proposal.\nusing LinearAlgebra\nspl = RWMH(MvNormal(zeros(model.D), I))\n\n# Find initial guess by drawing from priors\ninitial_θ = Octofitter.guess_starting_position(model,50_000)[1]\ninitial_θ_t = model.link(initial_θ) # Map to unconstrainted parameterization\n\n# Sample from the posterior.\nchn_norm = sample(\n    model,\n    spl,\n    1_000_000;\n    chain_type=Any,\n    init_params=initial_θ_t\n)\n\nchn_mh = remapchain(chn_norm)","category":"section"},{"location":"samplers/#Emcee-(affine-invariant-sampler)","page":"Sampler","title":"Emcee (affine invariant sampler)","text":"warning: Warning\nThis example is under construction\n\nWe can use the AdvancedMH package to implement a sampler that is similar to emcee.py. This might be helpful for reproducing the results of packages like orbitize! that are based on this sampler, but is not recommended otherwise.\n\nusing AdvancedMH\nusing MCMCChains: MCMCChains, Chains, chainscat\n\n# Construct model from a system (see elsewhere in docs)\nmodel = Octofitter.LogDensityModel(system)\n\ninitial_θ = Octofitter.guess_starting_position(model,50_000)[1]\ninitial_θ_t = model.link(initial_θ) # Map to unconstrainted parameterization\n\n\nusing LinearAlgebra\n\n# Set up our sampler with a joint multivariate Normal proposal.\nspl = Ensemble(1_000, StretchProposal(MvNormal(zeros(model.D), I)))\n\n# Sample from the posterior.\nstart_time = time()\nchn_raw = sample(\n    model,\n    spl,\n    1_000;\n    chain_type=Any,\n    init_params=initial_θ_t\n)\nstop_time = time()\n# Results are in normalized parameter space and need to be mapped back to their constrained support\n\n# Function to map the samples from all walkers back to their natural domain\nfunction remapchain(mc_samples_by_chain)\n    chains = map(mc_samples_by_chain) do mc_samples\n        logpost = map(s->s.lp, mc_samples)\n        # Transform samples back to constrained support\n        samples = map(mc_samples) do s\n            θ_t = s.params\n            θ = model.invlink(θ_t)\n            return θ\n        end\n        chain_res = model.arr2nt.(samples)\n        chain = Octofitter.result2mcmcchain(chain_res)\n        return MCMCChains.setinfo(\n            chain,\n            (;\n                start_time,\n                stop_time,\n                model=model.system,\n                logpost=logpost,\n            )\n        )\n    end\n    chainscat(chains...)\nend\n# Remap back to natural domain \nchn_all = remapchain(chn_raw)\n# Discard some burn in\nchn = chn_all[500:end,:,:];","category":"section"},{"location":"samplers/#Tempering","page":"Sampler","title":"Tempering","text":"The package MCMCTempering can be used to temper most Julia MCMC samplers. Here is an example with AdvancedMH. \n\nnote: Note\nMCMCTempering is under active development. The API might evolve, and you may need to ensure you're using the latest #main branch rather than published release.\n\nusing MCMCTempering, AdvancedMH, MCMCChains\nMCMCTempering.getparams(transition::AdvancedMH.Transition) = transition.params\n\ntempered_sampler = tempered(sampler, 25);\n\n# Sample from the posterior.\nchn_norm = sample(\n    model, tempered_sampler, 1_000_000;\n    discard_initial=100_000, chain_type=Any,\n    init_params=initial_θ_t\n)\n\n\nchn = remapchain(chn_norm)","category":"section"},{"location":"samplers/#Customized-NUTS-Sampling","page":"Sampler","title":"Customized NUTS Sampling","text":"This example shows how to customize different aspects of the default NUTS sampler.\n\nusing AdvancedHMC\ninitial_θ = Octofitter.guess_starting_position(model,150_000)[1]\ninitial_θ_t = model.link(initial_θ)\nmetric = DenseEuclideanMetric(model.D)\nhamiltonian = Hamiltonian(metric, model)\nϵ = find_good_stepsize(hamiltonian, initial_θ_t)\n\nintegrator = JitteredLeapfrog(ϵ, 0.1) # 10% normal distribution on step size to help in areas of high curvature. \n# integrator = Leapfrog(ϵ)\n# κ = NUTS{MultinomialTS,GeneralisedNoUTurn}(integrator, max_depth=12)\nκ = NUTS{SliceTS,GeneralisedNoUTurn}(integrator, max_depth=12)\n\nmma = MassMatrixAdaptor(metric)\nssa = StepSizeAdaptor(0.75, integrator)\nadaptor = StanHMCAdaptor(mma, ssa) \nsampler = AdvancedHMC.HMCSampler(κ, metric, adaptor)\n\n# Sample from the posterior.\nchn_norm = sample(\n    # model, tempered_sampler, 500;\n    model, sampler, 500,\n    nadapts = 250,\n    discard_initial=250, chain_type=Any,\n    init_params=initial_θ_t\n)\n\nfunction remapchain(mc_samples::AbstractArray{<:AdvancedHMC.Transition})\n    stat = map(s->s.stat, mc_samples)\n    logpost = map(s->s.z.ℓπ.value, mc_samples)\n    \n    mean_accept = mean(getproperty.(stat, :acceptance_rate))\n    ratio_divergent_transitions = mean(getproperty.(stat, :numerical_error))\n    mean_tree_depth = mean(getproperty.(stat, :tree_depth))\n\n    println(\"\"\"\n    Sampling report for chain:\n    mean_accept         = $mean_accept\n    ratio_divergent_transitions        = $ratio_divergent_transitions\n    mean_tree_depth     = $mean_tree_depth\\\n    \"\"\")\n\n    # Report some warnings if sampling did not work well\n    if ratio_divergent_transitions == 1.0\n        @error \"Numerical errors encountered in ALL iterations. Check model and priors.\"\n    elseif ratio_divergent_transitions > 0.1\n        @warn \"Numerical errors encountered in more than 10% of iterations\" ratio_divergent_transitions\n    end\n    # Transform samples back to constrained support\n    samples = map(mc_samples) do s\n        θ_t = s.z.θ\n        θ = model.invlink(θ_t)\n        return θ\n    end\n    chain_res = model.arr2nt.(samples)\n    chain = Octofitter.result2mcmcchain(chain_res)\n    return MCMCChains.setinfo(\n        chain,\n        (;\n            # start_time,\n            # stop_time,\n            model=model.system,\n            logpost=logpost,\n        )\n    )\nend\n\nchn = remapchain(chn_norm)\n","category":"section"}]
}
